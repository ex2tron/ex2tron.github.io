<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ex2tron&#39;s Blog</title>
  <subtitle>Excelsior!</subtitle>
  <link href="/atom.xaml" rel="self"/>
  
  <link href="http://ex2tron.coding.me/"/>
  <updated>2018-04-09T00:17:12.266Z</updated>
  <id>http://ex2tron.coding.me/</id>
  
  <author>
    <name>Tony Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>构建：查表法</title>
    <link href="http://ex2tron.coding.me/2018/04/08/%E6%9E%84%E5%BB%BA%EF%BC%9A%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/"/>
    <id>http://ex2tron.coding.me/2018/04/08/构建：表驱动法/</id>
    <published>2018-04-08T10:54:04.000Z</published>
    <updated>2018-04-09T00:17:12.266Z</updated>
    
    <content type="html"><![CDATA[<p>每次谈到查表，我都会先想到下面这个简单的例子：<a id="more"></a></p>
<blockquote>
<p><em>宁在一思进，莫在一思停。</em>——<a href="https://movie.douban.com/subject/3821067/" target="_blank" rel="external">《一代宗师》</a></p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如果你需要根据月份计算当月的天数（不考虑闰年），你会怎么写？</p>
<p>如果使用if语句，你的代码可能会像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python示例（其他语言中Switch/case也一样）</span></div><div class="line"><span class="keyword">if</span> (month == <span class="number">1</span>):</div><div class="line">    day = <span class="number">31</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">2</span>):</div><div class="line">    day = <span class="number">28</span></div><div class="line"><span class="keyword">elif</span>(month == <span class="number">3</span>):</div><div class="line">    day = <span class="number">31</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">4</span>):</div><div class="line">    day = <span class="number">30</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">5</span>):</div><div class="line">    day = <span class="number">31</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">6</span>):</div><div class="line">    day = <span class="number">30</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">7</span>):</div><div class="line">    day = <span class="number">31</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">8</span>):</div><div class="line">    day = <span class="number">31</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">9</span>):</div><div class="line">    day = <span class="number">30</span></div><div class="line"><span class="keyword">elif</span>(month == <span class="number">10</span>):</div><div class="line">    day = <span class="number">31</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">11</span>):</div><div class="line">    day = <span class="number">30</span></div><div class="line"><span class="keyword">elif</span> (month == <span class="number">12</span>):</div><div class="line">    day = <span class="number">31</span></div></pre></td></tr></table></figure>
<p>很显然，这是一种既冗长又比较笨的方法，那如何更简洁和优雅呢？这就要用到“表”了，为什么强调简洁和优雅？因为人生苦短呀( ╯□╰ )：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dayOfMonth = [<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]</div><div class="line">day = dayOfMonth[month - <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>怎么样，2行够简洁了吗？</p>
<p><em>本文内容是我阅读《代码大全：表驱动法p411》时的笔记，加入了自己的案例和总结。</em></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p><strong>表驱动法：从表中查找信息而不是使用逻辑语句（if/else/switch/case），也可称查表法。</strong></p>
</blockquote>
<p>对于简单的情况，逻辑判断更简单和易理解，但数据量和逻辑链增大的时候，查表法在灵活性、可维护性等方面有着显著的优势。</p>
<p><strong>查表法的核心在于如果构建表</strong>。前面的例子中，月份不重复，以月份为索引建立一个数组即可。但如果逻辑判断是个区间，比如对于下面的考试成绩，应该如何建表呢？</p>
<p>90-100分：优 | 70-90分：良 | 60-70分：及格 | 60分以下：不及格</p>
<h3 id="直接查表"><a href="#直接查表" class="headerlink" title="直接查表"></a>直接查表</h3><p>月份的例子就是直接查表，查询的信息（月份）可以直接转为表中的索引，一目了然。下面再看个例子：</p>
<p>有一个根据汽车速度计算转弯距离的程序：速度30马以下，距离为固定值a；100马以上也为固定值b；31~99之间，每个速度对应1个数值。这时如何建表呢？</p>
<p><strong>1.重复数据，直接使用键值</strong></p>
<p>第一种方式可以把a复制31次，100以上也复制多次，那表应该像这样：</p>
<p><img src="http://pic.ex2tron.top/repeat_key_table_driven_method.jpg" alt=""></p>
<p>显然，这种方式很蠢，不仅有很多冗余的数据，而且很容易出错。</p>
<p><strong>2.转换键值</strong></p>
<p>我们可以用一个函数将键值做下转换：因为0~30是同一值，所以将0~30转成一个键值，100以上转成一个键值，中间的数据本身作为键值。对于这种转换，可以一句话搞定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python语言示例</span></div><div class="line">newKey = max(min(<span class="number">100</span>, speed), <span class="number">30</span>)</div></pre></td></tr></table></figure>
<p>其他语言中<code>max/min</code>函数一般在Math相关模块中可以找到。这样完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">distanceOfSpeed = [a, n31, n32, ……, n99, b]</div><div class="line">result = distanceOfSpeed[max(min(<span class="number">100</span>, speed), <span class="number">30</span>) - <span class="number">30</span>]</div></pre></td></tr></table></figure>
<h3 id="阶梯查表"><a href="#阶梯查表" class="headerlink" title="阶梯查表"></a>阶梯查表</h3><p>前面考试成绩的例子，不同的成绩范围对应不同的数据，如同台阶一样：</p>
<p><img src="http://pic.ex2tron.top/stair_table_look_up_method.jpg" alt=""></p>
<p>这时可以使用阶梯查表：表内的数据是对应不同的数据范围，而不是对应不同的数据点。阶梯法查表就是循环检查每个区间的上限。当分数第一次超过某个区间的上限时，就可以得到想要的等级（留心端点的值噢：&lt;和&lt;=的区别）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python语言示例</span></div><div class="line">scoreLimit = [<span class="number">60.0</span>, <span class="number">70.0</span>, <span class="number">90.0</span>, <span class="number">100.0</span>]</div><div class="line">grade = [<span class="string">"不及格"</span>, <span class="string">"及格"</span>, <span class="string">"良"</span>, <span class="string">"优"</span>]</div><div class="line"></div><div class="line">score, index, result = <span class="number">45</span>, <span class="number">0</span>, <span class="string">'优'</span></div><div class="line"><span class="comment"># 这个条件语句很重要噢！</span></div><div class="line"><span class="keyword">while</span> (result == <span class="string">'优'</span> <span class="keyword">and</span> index &lt; len(grade) - <span class="number">1</span>):</div><div class="line">    <span class="keyword">if</span> (score &lt; scoreLimit[index]):</div><div class="line">        result = grade[index]</div><div class="line">    index += <span class="number">1</span></div><div class="line"></div><div class="line">print(result) <span class="comment"># 不及格</span></div></pre></td></tr></table></figure>
<p>这种阶梯方法很适合处理区间、等级评价和键值无规则的场合。</p>
<p>除了上面两种方法外，还有索引查表法：相当于书的目录。先从目录中找到页码，再根据页码找到对应的记录。在程序中，就是先建一张索引表，从索引表中找出值，再在主表中查到数据，数据库经常用到，这里不详细介绍了。</p>
<p><strong>另外，可以将表存储在外部，这样可以在不更改逻辑代码的情况下，改变表的值。</strong></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/blob/master/Build/build_table_driven_methods.py" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://www.lofter.com/lpost/1d7338a1_10204bea" target="_blank" rel="external">旧版：构建法——表驱动法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次谈到查表，我都会先想到下面这个简单的例子：
    
    </summary>
    
      <category term="Build篇" scheme="http://ex2tron.coding.me/categories/Build%E7%AF%87/"/>
    
    
      <category term="构建法" scheme="http://ex2tron.coding.me/tags/%E6%9E%84%E5%BB%BA%E6%B3%95/"/>
    
      <category term="表驱动法" scheme="http://ex2tron.coding.me/tags/%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95/"/>
    
      <category term="查表法" scheme="http://ex2tron.coding.me/tags/%E6%9F%A5%E8%A1%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程18：理解特征</title>
    <link href="http://ex2tron.coding.me/2018/03/15/Python-OpenCV%E6%95%99%E7%A8%8B18%EF%BC%9A%E7%90%86%E8%A7%A3%E7%89%B9%E5%BE%81/"/>
    <id>http://ex2tron.coding.me/2018/03/15/Python-OpenCV教程18：理解特征/</id>
    <published>2018-03-15T12:13:55.000Z</published>
    <updated>2018-03-15T14:12:22.045Z</updated>
    
    <content type="html"><![CDATA[<p>学习和了解图像特征的重要性。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>理解图像特征</li>
<li>图像特征的重要性和用途</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="拼图游戏"><a href="#拼图游戏" class="headerlink" title="拼图游戏"></a>拼图游戏</h3><p>相信大部分人都玩过拼图游戏：根据散落的图片小块最终拼接成一副完整的图片。那么，你是怎么拼起来的呢？</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_features_jigsaw_puzzle.jpg" alt=""></p>
<p>我们是通过小块间的相似性来拼的，但我们很难具体说出来这个”像”，谁叫我们的大脑已经被上帝编好程序了呢(￣_￣)。现在做个假设，如果能让计算机找到这些小块间的相似性，是不是也可以让计算机玩拼图游戏呢？</p>
<h3 id="理解特征"><a href="#理解特征" class="headerlink" title="理解特征"></a>理解特征</h3><p>那这些特征有哪些？如何找到这些特征呢？我们来看下这幅图片：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_features_building.jpg" alt=""></p>
<p>图的上面有6个小块，都是图中的某一部分。你能找到这6个小块在图中的具体位置吗？</p>
<ul>
<li><p>A和B很难确定具体的位置，因为它们在原图中的很多地方都有。可以把这些地方称为扁平的区域。</p>
</li>
<li><p>C和D相对容易点，因为它们是建筑物的边缘。虽然也比较难确定具体位置，但可以找到一个大致的位置。</p>
<p><strong>可以说边缘是比扁平区域更好的一种特征。</strong></p>
</li>
<li><p>最后，E和F就好找多了，因为它们是建筑物的角点。在角点位置上，不论将小块怎么移动，都会得到不同的结果。</p>
<p><strong>所以说角点是比边缘更好的一种特征。</strong></p>
</li>
</ul>
<p>可以简单地用下面这个图来表示这三种特征：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_features.jpg" alt=""></p>
<ul>
<li>蓝色方块代表的扁平区域很难定位，因为不论移动到哪儿，结果都一样；</li>
<li>黑色方块表示边缘，如果我们垂直移动它，它就会改变，但水平移动，结果仍然不变；</li>
<li>最后红色方块表示角点，随便移动它，它都会改变，说明它是唯一的。<strong>所以，角点对图像来说就是一个比较好的特征。</strong></li>
</ul>
<p>现在我们就回答了”什么是特征？”这个问题，那么我们如何找到特征呢？其实不难发现，对于角点，我们可以通过移动图像中的一个小区域，找出图像中变化量最大的地方，这就叫<strong>特征检测</strong>。找到特征后，我们可以这样描述图片：图的上面是天空，下面是一个建筑物，建筑物外层是玻璃等等，这就叫<strong>特征描述</strong>。特征检测和特征描述就是我们接下来要学习的内容。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_feature2d/py_features_meaning/py_features_meaning.html" target="_blank" rel="external">Understanding Features</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习和了解图像特征的重要性。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="特征" scheme="http://ex2tron.coding.me/tags/%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
  <entry>
    <title>【片单】推荐几部优秀的传记电影</title>
    <link href="http://ex2tron.coding.me/2018/03/15/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91%E6%8E%A8%E8%8D%90%E5%87%A0%E9%83%A8%E4%BC%98%E7%A7%80%E7%9A%84%E4%BC%A0%E8%AE%B0%E7%94%B5%E5%BD%B1/"/>
    <id>http://ex2tron.coding.me/2018/03/15/【片单】推荐几部优秀的传记电影/</id>
    <published>2018-03-15T05:46:50.000Z</published>
    <updated>2018-03-15T07:43:52.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><em>“Look up at the stars, not down at your feet.”</em> ——<a href="https://baike.baidu.com/item/斯蒂芬·威廉·霍金?fromtitle=%E9%9C%8D%E9%87%91&amp;fromid=171893" target="_blank" rel="external"><em>Stephen Hawking</em></a></p>
</blockquote>
<p><em>昨天看到霍金去世的新闻，无比震惊，走在路上，停留了片刻。也许就像很多人说的，他，属于星辰大海！</em><a id="more"></a></p>
<p>以下是我看过的一些优秀传记片，推荐给大家（大部分片源来自人人影视字幕组，点击片名即可下载）：</p>
<p><a href="thunder://QUFmdHA6Ly95Z2R5ODp5Z2R5OEB5MjAxLmR5Z29kLm9yZzoxMTk2L1vpmLPlhYnnlLXlvbF3d3cueWdkeTguY29tXS7kuIfniannkIborrouQkQuNzIwcC7kuK3oi7Hlj4zlrZfluZUucm12Ylpa/" target="_blank" rel="external"><strong>万物理论(The Theory of Everything)</strong></a> | 霍金 | <a href="https://movie.douban.com/subject/24815950/" target="_blank" rel="external">豆瓣8.1</a></p>
<p><img src="https://image.tmdb.org/t/p/original/jIh6T8re0iFYEqBXlBMkAUhLgpr.jpg" alt=""></p>
<p><a href="thunder://QUFmdHA6Ly93d3c6cGlhb2h1YS5jb21AZHkxMjYucGlhb2h1YS5jb206MjAzODYv6aOY6Iqx55S15b2xcGlhb2h1YS5jb23mqKHku7/muLjmiI9CRDEyODDpq5jmuIXkuK3oi7Hlj4zlrZcucm12Ylpa" target="_blank" rel="external"><strong>模仿游戏(The Imitation Game)</strong></a> | 图灵 | <a href="https://movie.douban.com/subject/10463953/" target="_blank" rel="external">豆瓣8.5</a></p>
<p><img src="https://image.tmdb.org/t/p/original/hctIo3ugW79kzV6F9d6A1sMIAyP.jpg" alt=""></p>
<p><a href="ed2k://|file|A.Beautiful.Mind.2001.美丽心灵.双语字幕.HR-HDTV.AAC.1024X576.X264.V2.mkv|1977242953|DD244C62B44BE40049378CD976893F16|h=MJIMBKGOI6MP5RQ4FTBRDEB3IGWO7VRO|/" target="_blank" rel="external"><strong>美丽心灵(A Beautiful Mind)</strong></a> | 约翰·纳什 | <a href="https://movie.douban.com/subject/1306029/" target="_blank" rel="external">豆瓣8.9</a></p>
<p><img src="https://image.tmdb.org/t/p/original/fKiBtKwQqpdRUGHCvay8SpRLLLs.jpg" alt=""></p>
<p><a href="ed2k://|file|【AllForBC-字幕组】Hawking霍金的故事[中英双语字幕].mp4|731100250|4f3dcebd153d9f2f9759a818aea7e0fd|h=lh2wetq7fkmjvc535dqpaoxnxlxpgwcr|/" target="_blank" rel="external"><strong>霍金传(Hawing)</strong></a> | 霍金 | <a href="https://movie.douban.com/subject/1482022/" target="_blank" rel="external">豆瓣8.6</a></p>
<p><a href="ed2k://|file|The.Last.Emperor.末代皇帝.双语字幕.HR-HDTV.AC3.960X528.x264-人人影视制作.avi|2449821696|98A14ABD516F8FA9A9314233D238414B|h=NGA6HDRD5M6P7GVVZKDVUVEMZC2ILHXB|/" target="_blank" rel="external"><strong>末代皇帝(The Last Emperor)</strong></a> | 爱新觉罗·溥仪 | <a href="https://movie.douban.com/subject/1293172/" target="_blank" rel="external">豆瓣8.9</a></p>
<p><a href="ed2k://|file|007.Thunderball.007%E5%9B%9B%E4%B9%8B%E9%9C%B9%E9%9B%B3%E5%BC%B9.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2076483141|57CF7BC6E559112294768D5E917178F4|h=CT4WTGA5BQPNIO7HQBABGSCKH7SMSA7Z|/" target="_blank" rel="external"><strong>当幸福来敲门(The Pursuit of Happyness)</strong></a> | 克里斯·加德纳 | <a href="https://movie.douban.com/subject/1849031/" target="_blank" rel="external">豆瓣8.9</a></p>
<p><img src="https://image.tmdb.org/t/p/original/dpU1cVA2CVI2wyaY2IPRFlG6Wt8.jpg" alt=""></p>
<p><a href="ed2k://|file|The.Pianist.2002.钢琴家.双语字幕.HR-HDTV.AC3.1024X576.x264-人人影视制作.mkv|2326015948|095FFBBAED4F58F44067B6FFBC2E4C11|h=VTRFXAM4VHWIVESJTQCYCCS5UNOFEYVU|/" target="_blank" rel="external"><strong>钢琴家(The Pianist)</strong></a> | 席皮尔曼 | <a href="https://movie.douban.com/subject/1296736/" target="_blank" rel="external">豆瓣9.0</a></p>
<p><img src="https://image.tmdb.org/t/p/original/kwsJVYfro0lGsgBqFyaXduG5b7Z.jpg" alt=""></p>
<p><a href="ed2k://|file|Dangal.2016.%E6%91%94%E8%B7%A4%E5%90%A7%EF%BC%81%E7%88%B8%E7%88%B8.720p.Chi_Eng.ZMZ-BD-MP4.mp4|2405783249|e3f8ed512d49ff9cce59b34aa4ae1d33|h=rsc4gxnyx2yh6zgc4s7ptv3gaaigczd6|/" target="_blank" rel="external"><strong>摔跤吧！爸爸(Dangal)</strong></a> | 马哈维亚·辛格·珀尕 | <a href="https://movie.douban.com/subject/26387939/" target="_blank" rel="external">豆瓣9.1</a></p>
<p><a href="ed2k://|file|%E8%87%B3%E6%9A%97%E6%97%B6%E5%88%BB.Darkest.Hour.2017.%E4%B8%AD%E8%8B%B1%E5%AD%97%E5%B9%95.BDrip.AAC.720p.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86.mp4|1866691403|976fe39e6588834f4cbc558514be9501|h=5xo7mlahblltdioq6mw2wx3fupo2gdes|/" target="_blank" rel="external"><strong>至暗时刻(Darkest Hour)</strong></a> | 丘吉尔 | <a href="https://movie.douban.com/subject/26761416/" target="_blank" rel="external">豆瓣8.6</a></p>
<p><img src="https://image.tmdb.org/t/p/original/krrhg14FJJdvV39EUxEP9eADCH1.jpg" alt=""></p>
<p><a href="ed2k://|file|The.Kings.Speech.2010.国王的演讲.双语字幕.HR-HDTV.AC3.1024x576.x264-人人影视制作.V2.mkv|2112773229|3E9437264012697BC145453BE58ACBAD|h=RKHJF33WHPADPWH7KITNBAIX3IKXFG7D|/" target="_blank" rel="external"><strong>国王的演讲(The King’s Speech)</strong></a> | 乔治六世 | <a href="https://movie.douban.com/subject/4023638/" target="_blank" rel="external">豆瓣8.3</a></p>
<p><a href="ed2k://|file|The.Blind.Side.2009.弱点.双语字幕.HR-HDTV.AC3.1024x576.x264-人人影视.mkv|2107478665|97231C2D62D0653128980F159A70FA9D|h=5VVOFNOXNN423DXW746JZX37OXARWQXB|/" target="_blank" rel="external"><strong>弱点(The Blind Side)</strong></a> | 迈克尔·奥赫 | <a href="https://movie.douban.com/subject/3552028/" target="_blank" rel="external">豆瓣8.4</a></p>
<p><img src="https://image.tmdb.org/t/p/original/qVjKZMB0IdOc2JlwiiGsuKTvTJs.jpg" alt=""></p>
<p><a href="ed2k://|file|Braveheart.1995.%E5%8B%87%E6%95%A2%E7%9A%84%E5%BF%83.720p.Chi_Eng.ZMZ-BD-MP4.mp4|2658811653|50c0521f74fc897f0f691cc4f7758855|h=j4mar2cxatqfb33qtib4ca6z3zxizkju|/" target="_blank" rel="external"><strong>勇敢的心(Braveheart)</strong></a> | 威廉·华莱士 | <a href="https://movie.douban.com/subject/1294639/" target="_blank" rel="external">豆瓣8.8</a></p>
<p><a href="ed2k://|file|%E5%90%AF%E5%8A%9F.1080p.HD%E5%9B%BD%E8%AF%AD%E4%B8%AD%E5%AD%97%E3%80%906v%E7%94%B5%E5%BD%B1www.6vhao.net%E3%80%91.mkv|807501501|E87261DF2946615885BD941BEAB689DF|h=WL4KAS6KIYAZSXOUSX4UB4NB35O6COGQ|/" target="_blank" rel="external"><strong>启功(The Calligraphy Master)</strong></a> | 启功 | <a href="https://movie.douban.com/subject/26440017/" target="_blank" rel="external">豆瓣7.6</a></p>
<p><img src="http://pic.ex2tron.top/qigong.jpg" alt=""></p>
<p>其实还有很多好的传记片，上面这几个是看过能立马想起来的，有机会再补充！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“Look up at the stars, not down at your feet.”&lt;/em&gt; ——&lt;a href=&quot;https://baike.baidu.com/item/斯蒂芬·威廉·霍金?fromtitle=%E9%9C%8D%E9%87%91&amp;amp;fromid=171893&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;Stephen Hawking&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;昨天看到霍金去世的新闻，无比震惊，走在路上，停留了片刻。也许就像很多人说的，他，属于星辰大海！&lt;/em&gt;
    
    </summary>
    
      <category term="谈电影" scheme="http://ex2tron.coding.me/categories/%E8%B0%88%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="传记片" scheme="http://ex2tron.coding.me/tags/%E4%BC%A0%E8%AE%B0%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程17：霍夫变换</title>
    <link href="http://ex2tron.coding.me/2017/12/28/Python-OpenCV%E6%95%99%E7%A8%8B17%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"/>
    <id>http://ex2tron.coding.me/2017/12/28/Python-OpenCV教程17：霍夫变换/</id>
    <published>2017-12-28T03:35:11.000Z</published>
    <updated>2017-12-29T02:59:29.861Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用霍夫变换识别出图像中的直线和圆。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>理解霍夫变换的实现</li>
<li>分别使用霍夫线变换和圆变换检测图像中的直线和圆</li>
<li>OpenCV函数：cv2.HoughLines(), cv2.HoughLinesP(), cv2.HoughCircles()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="理解霍夫变换"><a href="#理解霍夫变换" class="headerlink" title="理解霍夫变换"></a>理解霍夫变换</h3><p>霍夫变换常用来在图像中提取直线和圆等几何形状，实现原理在维基百科上解释的非常清楚：<a href="https://en.wikipedia.org/wiki/Hough_transform" target="_blank" rel="external">Hough transform</a>，我来做个简易的解释，感兴趣的可以一看，否则划掉(●ˇ∀ˇ●)：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_hough_transform.jpg" alt=""></p>
<p>学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示：</p>
<p><img src="http://pic.ex2tron.top/cv2_line_expression_in_coordinate.jpg" alt=""></p>
<p>那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示：$ r_\theta=x_0\cdot\cos \theta+y_0\cdot\sin \theta$</p>
<p>也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点：</p>
<p>  <img src="http://pic.ex2tron.top/cv2_curve_of_r_theta.jpg" alt=""> </p>
<p>OpenCV中首先计算(r,θ) 累加数，累加数超过一定值后就认为在同一直线上（有点拗口，不懂也没关系，暂时会用就行）。</p>
<h3 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h3><p>OpenCV中用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.加载图片，转为二值图</span></div><div class="line">img = cv2.imread(<span class="string">'shapes.jpg'</span>)</div><div class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</div><div class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</div><div class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2.霍夫直线变换</span></div><div class="line">lines = cv2.HoughLines(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>)</div></pre></td></tr></table></figure>
<p>函数中：</p>
<ul>
<li>参数1：要检测的二值图（一般是阈值分割或边缘检测后的图）</li>
<li>参数2：距离r的精度，值越大，考虑越多的线</li>
<li>参数3：角度θ的精度，值越小，考虑越多的线</li>
<li>参数4：累加数阈值，值越小，考虑越多的线</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 3.将检测的线画出来（注意是极坐标噢）</span></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</div><div class="line">    rho, theta = line[<span class="number">0</span>]</div><div class="line">    a = np.cos(theta)</div><div class="line">    b = np.sin(theta)</div><div class="line">    x0 = a * rho</div><div class="line">    y0 = b * rho</div><div class="line">    x1 = int(x0 + <span class="number">1000</span> * (-b))</div><div class="line">    y1 = int(y0 + <span class="number">1000</span> * (a))</div><div class="line">    x2 = int(x0 - <span class="number">1000</span> * (-b))</div><div class="line">    y2 = int(y0 - <span class="number">1000</span> * (a))</div><div class="line"></div><div class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_hough_line_function.jpg" alt=""></p>
<h3 id="统计概率霍夫直线变换"><a href="#统计概率霍夫直线变换" class="headerlink" title="统计概率霍夫直线变换"></a>统计概率霍夫直线变换</h3><p>前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r和θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</div><div class="line"><span class="comment"># 3.统计概率霍夫线变换</span></div><div class="line">lines = cv2.HoughLinesP(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>,</div><div class="line">                        minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>前面几个参数跟之前的一样，有两个可选参数：</p>
<ul>
<li>minLineLength：最短长度阈值，比这个长度短的线会被排除</li>
<li>maxLineGap：同一直线两点之间的最大距离</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 3.将检测的线画出来</span></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</div><div class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>]</div><div class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, lineType=cv2.LINE_AA)</div></pre></td></tr></table></figure>
<p><code>cv2.LINE_AA</code>在之前绘图功能中讲解过，表示抗锯齿线型。</p>
<p><img src="http://pic.ex2tron.top/cv2_hough_lines_p_function.jpg" alt=""></p>
<h3 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h3><p>霍夫圆变换跟直线变换类似，只不过线是用(r,θ)表示，圆是用(x_center,y_center,r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：<a href="https://en.wikipedia.org/wiki/Circle_Hough_Transform" target="_blank" rel="external">Circle Hough Transform</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</div><div class="line"><span class="comment"># 2.霍夫圆变换</span></div><div class="line">circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">20</span>, param2=<span class="number">30</span>)</div><div class="line">circles = np.int0(np.around(circles))</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>参数2：变换方法，一般使用霍夫梯度法，详情：<a href="https://docs.opencv.org/3.3.1/d7/dbd/group__imgproc.html#ga073687a5b96ac7a3ab5802eb5510fe65" target="_blank" rel="external">HoughModes</a></li>
<li>参数3 dp=1：表示霍夫梯度法中累加器图像的分辨率与原图一致</li>
<li>参数4：两个不同圆圆心的最短距离</li>
<li>参数5：param2跟霍夫直线变换中的累加数阈值一样</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将检测的圆画出来</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</div><div class="line">    cv2.circle(drawing, (i[<span class="number">0</span>], i[<span class="number">1</span>]), i[<span class="number">2</span>], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)  <span class="comment"># 画出外圆</span></div><div class="line">    cv2.circle(drawing, (i[<span class="number">0</span>], i[<span class="number">1</span>]), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>)  <span class="comment"># 画出圆心</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_hough_circles_function.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>霍夫变换用来提取图像中的直线和圆等几何形状</li>
<li>霍夫直线变换：cv2.HoughLines()（整条直线）, cv2.HoughLinesP()</li>
<li>霍夫圆变换：cv2.HoughCircles()</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/17.%20%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html" target="_blank" rel="external">Hough Line Transform</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghcircles/py_houghcircles.html" target="_blank" rel="external">Hough Circle Transform</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用霍夫变换识别出图像中的直线和圆。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="霍夫变换" scheme="http://ex2tron.coding.me/tags/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程16：模板匹配</title>
    <link href="http://ex2tron.coding.me/2017/12/27/Python-OpenCV%E6%95%99%E7%A8%8B16%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"/>
    <id>http://ex2tron.coding.me/2017/12/27/Python-OpenCV教程16：模板匹配/</id>
    <published>2017-12-27T08:45:31.000Z</published>
    <updated>2018-01-18T02:14:14.760Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用模板匹配在图像中寻找物体。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>使用模板匹配在图像中寻找物体</li>
<li>OpenCV函数：cv2.matchTemplate(), cv2.minMaxLoc()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p><a href="https://baike.baidu.com/item/模板匹配" target="_blank" rel="external">模板匹配</a>就是用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_template_matching.jpg" alt=""></p>
<p>用<code>cv2.matchTemplate()</code>实现模板匹配。首先我们来读入图片和模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>, <span class="number">0</span>)</div><div class="line">template = cv2.imread(<span class="string">'face.jpg'</span>, <span class="number">0</span>)</div><div class="line">h, w = template.shape[:<span class="number">2</span>]  <span class="comment"># rows-&gt;h, cols-&gt;w</span></div></pre></td></tr></table></figure>
<p>匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。使用<code>cv2.minMaxLoc()</code>函数可以得到最大匹配值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span></div><div class="line">res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)</div><div class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</div><div class="line"></div><div class="line">left_top = max_loc  <span class="comment"># 左上角</span></div><div class="line">right_bottom = (left_top[<span class="number">0</span>] + w, left_top[<span class="number">1</span>] + h)  <span class="comment"># 右下角</span></div><div class="line">cv2.rectangle(img, left_top, right_bottom, <span class="number">255</span>, <span class="number">2</span>)  <span class="comment"># 画出矩形位置</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_ccoeff_matching_template.jpg" alt=""></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>这部分可看可不看，不太理解也没关系，还记得前面的方法吗？不懂得就划掉(✿◕‿◕✿)</p>
</blockquote>
<p>模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有6种不同的比较方法，详情可参考：<a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="external">TemplateMatchModes</a></p>
<ul>
<li>平方差匹配CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为0</li>
<li>归一化平方差匹配CV_TM_SQDIFF_NORMED</li>
<li>相关匹配CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好</li>
<li>归一化相关匹配CV_TM_CCORR_NORMED</li>
<li>相关系数匹配CV_TM_CCOEFF：用两者的相关系数匹配，1表示完美的匹配，-1表示最差的匹配</li>
<li>归一化相关系数匹配CV_TM_CCOEFF_NORMED</li>
</ul>
<p>这些方法的对比代码可到<a href="#引用">源码处</a>查看。模板匹配也是应用卷积来实现的：假设原图大小为W×H，模板图大小为w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。</p>
<h3 id="匹配多个物体"><a href="#匹配多个物体" class="headerlink" title="匹配多个物体"></a>匹配多个物体</h3><p>前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.读入原图和模板</span></div><div class="line">img_rgb = cv2.imread(<span class="string">'mario.jpg'</span>)</div><div class="line">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)</div><div class="line">template = cv2.imread(<span class="string">'mario_coin.jpg'</span>, <span class="number">0</span>)</div><div class="line">h, w = template.shape[:<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="comment"># 2.标准相关模板匹配</span></div><div class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</div><div class="line">threshold = <span class="number">0.8</span> </div><div class="line"></div><div class="line"><span class="comment"># 3.这边是Python/Numpy的知识，后面解释</span></div><div class="line">loc = np.where(res &gt;= threshold)  <span class="comment"># 匹配程度大于%80的坐标y,x</span></div><div class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> zip(*loc[::<span class="number">-1</span>]):  <span class="comment"># *号表示可选参数</span></div><div class="line">    right_bottom = (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h)</div><div class="line">    cv2.rectangle(img_rgb, pt, right_bottom, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_template_matching_multi.jpg" alt=""></p>
<p>第3步有几个Python/Numpy的重要知识，来大致看下：</p>
<ul>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" target="_blank" rel="external">np.where</a>在这里返回res中值大于0.8的所有坐标，如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</div><div class="line">print(np.where(x &gt; <span class="number">5</span>))</div><div class="line"><span class="comment"># 结果(先y坐标，再x坐标)：(array([2, 2, 2]), array([0, 1, 2]))</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_np_where_function.jpg" alt=""></p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="external">zip</a>函数，功能很强大到难以解释，举个简单例子就知道了：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">print(list(zip(x, y)))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></div></pre></td></tr></table></figure>
<p>这样大家就能理解前面代码的用法了吧：因为loc是先y坐标再x坐标，所以用loc[::-1]翻转一下，然后再用zip函数拼接在一起。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>之前我们有学过形状匹配，不论形状旋转/缩放都可以匹配到。思考一下，图片旋转或缩放的话模板匹配还有作用吗？</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>模板匹配用来在大图中找小图</li>
<li>cv2.matchTemplate()用来进行模板匹配</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/16.%20%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html" target="_blank" rel="external">Template Matching</a></li>
<li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/template_matching/template_matching.html#template-matching" target="_blank" rel="external">模板匹配</a></li>
<li><a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="external">TemplateMatchModes</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用模板匹配在图像中寻找物体。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="模板匹配" scheme="http://ex2tron.coding.me/tags/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程15：直方图</title>
    <link href="http://ex2tron.coding.me/2017/12/23/Python-OpenCV%E6%95%99%E7%A8%8B15%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
    <id>http://ex2tron.coding.me/2017/12/23/Python-OpenCV教程15：直方图/</id>
    <published>2017-12-23T09:48:30.000Z</published>
    <updated>2017-12-26T05:29:28.740Z</updated>
    
    <content type="html"><![CDATA[<p>学习计算并绘制直方图，直方图均衡化等。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>计算并绘制直方图</li>
<li>（自适应）直方图均衡化</li>
<li>OpenCV函数：cv2.calcHist(), cv2.equalizeHist()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="啥叫直方图"><a href="#啥叫直方图" class="headerlink" title="啥叫直方图"></a>啥叫直方图</h3><p>直方图简单来说就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为0的有多少个，1的多少个……直方图是一种分析图片的手段：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_histogram.jpg" alt=""></p>
<p>在计算直方图之前，有几个术语先来了解一下：</p>
<ul>
<li>dims：要计算的通道数，对于灰度图dims=1</li>
<li>range：要计算的像素值范围，一般为[0,256]（不包括256）</li>
<li>bins：子区段数目，如果我们统计0~255每个像素值，bins=256；如果划分区间，比如0~15, 16~31…240~255这样16个区间，bins=16</li>
</ul>
<h3 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h3><p>OpenCV和Numpy中都提供了计算直方图的函数，我们对比下它们的性能。</p>
<h4 id="OpenCV中直方图计算"><a href="#OpenCV中直方图计算" class="headerlink" title="OpenCV中直方图计算"></a>OpenCV中直方图计算</h4><p>使用<code>cv2.calcHist(images, channels, mask, histSize, ranges)</code>计算，其中：</p>
<ul>
<li>参数1：要计算的原图，以方括号的传入，如：[img]</li>
<li>参数2：类似前面提到的dims，灰度图写[0]就行，彩色图B/G/R分别传入[0]/[1]/[2]</li>
<li>参数3：要计算的区域，计算整幅图的话，写None</li>
<li>参数4：前面提到的bins</li>
<li>参数5：前面提到的range</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'hist.jpg'</span>, <span class="number">0</span>)</div><div class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="keyword">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.025288 s</span></div></pre></td></tr></table></figure>
<h4 id="Numpy中直方图计算"><a href="#Numpy中直方图计算" class="headerlink" title="Numpy中直方图计算"></a>Numpy中直方图计算</h4><p>也可用Numpy的函数计算，其中<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="external">ravel()</a>函数将二维矩阵展平变成一维数组，之前有提到过：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hist, bins = np.histogram(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.020628 s</span></div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：Numpy中还有一种更高效的方式：（还记得怎么评估性能吗：<a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">番外篇：代码性能优化</a>）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hist = np.bincount(img.ravel(), minlength=<span class="number">256</span>)  <span class="comment"># 性能：0.003163 s</span></div></pre></td></tr></table></figure>
<p>计算出直方图之后，怎么把它画出来呢？</p>
<h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><p>其实Matplotlib自带了一个计算并绘制直方图的功能，不需要用到上面的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>当然，也可以用前面计算出来的结果绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plt.plot(hist); plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_calc_draw_histogram.jpg" alt=""></p>
<p>从直方图上可以看到图片的大部分区域集中在150偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。</p>
<blockquote>
<p>使用OpenCV的画线功能也可以画直方图，不过太麻烦了，有兴趣的可以看下官方示例：<a href="https://github.com/opencv/opencv/blob/master/samples/python/hist.py" target="_blank" rel="external">hist.py</a></p>
</blockquote>
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96" target="_blank" rel="external">维基百科：直方图均衡化</a></p>
<p><img src="http://pic.ex2tron.top/cv2_understand_histogram_equalization.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">equ = cv2.equalizeHist(img)</div></pre></td></tr></table></figure>
<p>OpenCV中用<code>cv2.equalizeHist()</code>实现均衡化。我们把两张图片并排显示，对比一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.imshow(<span class="string">'equalization'</span>, np.hstack((img, equ)))  <span class="comment"># 并排显示</span></div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_before_after_equalization.jpg" alt=""></p>
<p><img src="http://pic.ex2tron.top/cv2_before_after_equalization_histogram.jpg" alt="均衡化前后的直方图对比"></p>
<p>可以看到均衡化后图片的亮度和对比度效果明显好于原图。</p>
<h3 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h3><p>不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_adaptive_histogram.jpg" alt=""></p>
<p>很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。</p>
<p>自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认8×8）进行直方图均衡化。当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：<strong>对比度受限的自适应直方图均衡化</strong>CLAHE <a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="external">Contrast Limited Adaptive Histogram Equalization</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 自适应均衡化，参数可选</span></div><div class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</div><div class="line">cl1 = clahe.apply(img)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_adaptive_histogram.jpg" alt=""></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>cv2.calcHist()函数中的参数3是指要计算的区域(mask：目标区域白色，其余黑色)，编写一个只计算图片左上角200×200区域直方图的程序</li>
</ol>
<p><img src="http://pic.ex2tron.top/cv2_histogram_mask.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>直方图是一种分析图像的手段</li>
<li>cv2.calcHist()和numpy.bincount()均可用来计算直方图，使用Matplotlib绘制直方图</li>
<li>均衡化用来使图像的直方图分布更加均匀，提升亮度和对比度</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/15.%20%E7%9B%B4%E6%96%B9%E5%9B%BE" target="_blank" rel="external">本节源码</a></li>
<li><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histograms-getting-started" target="_blank" rel="external">Histograms - 1 : Find, Plot, Analyze !!!</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization" target="_blank" rel="external">Histograms - 2: Histogram Equalization</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96" target="_blank" rel="external">维基百科：直方图均衡化</a></li>
<li><a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="external">维基百科：自适应直方图均衡化</a></li>
<li><a href="http://www.cambridgeincolour.com/tutorials/histograms1.htm" target="_blank" rel="external">Cambridge in Color website</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习计算并绘制直方图，直方图均衡化等。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="直方图" scheme="http://ex2tron.coding.me/tags/%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程14：轮廓特征</title>
    <link href="http://ex2tron.coding.me/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B14%EF%BC%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/"/>
    <id>http://ex2tron.coding.me/2017/12/20/Python-OpenCV教程14：轮廓特征/</id>
    <published>2017-12-20T10:46:19.000Z</published>
    <updated>2018-01-22T08:19:33.291Z</updated>
    
    <content type="html"><![CDATA[<p>学习计算轮廓特征，如面积、周长、最小外接矩形等。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>计算物体的周长、面积、质心、最小外接矩形等</li>
<li>OpenCV函数：cv2.contourArea(), cv2.arcLength(), cv2.approxPolyDP() 等</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>在计算轮廓特征之前，我们先用上一节的代码把轮廓找到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'handwriting.jpg'</span>, <span class="number">0</span>)</div><div class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</div><div class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 以数字3的轮廓为例</span></div><div class="line">cnt = contours[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</div><div class="line">img_color2 = np.copy(img_color1)</div><div class="line">cv2.drawContours(img_color1, [cnt], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">area = cv2.contourArea(cnt)  <span class="comment"># 4386.5</span></div></pre></td></tr></table></figure>
<p>注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p>
<blockquote>
<p>如果统计二值图中像素点个数，应尽量避免循环，可以使用<code>cv2.countNonZero()</code>，更加高效</p>
</blockquote>
<h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perimeter = cv2.arcLength(cnt, <span class="keyword">True</span>)  <span class="comment"># 585.7</span></div></pre></td></tr></table></figure>
<p>参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p>
<h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><p>矩可以理解为图像的各类几何特征，详情请参考：[<a href="http://en.wikipedia.org/wiki/Image_moment" target="_blank" rel="external">Image Moments</a>]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">M = cv2.moments(cnt)</div></pre></td></tr></table></figure>
<p>M中包含了很多轮廓的特征信息，比如<code>M[&#39;m00&#39;]</code>表示轮廓面积，与前面<code>cv2.contourArea()</code>计算结果是一样的。质心也可以用算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cx, cy = M[<span class="string">'m10'</span>] / M[<span class="string">'m00'</span>], M[<span class="string">'m01'</span>] / M[<span class="string">'m00'</span>]  <span class="comment"># (205, 281)</span></div></pre></td></tr></table></figure>
<h3 id="外接矩形"><a href="#外接矩形" class="headerlink" title="外接矩形"></a>外接矩形</h3><p>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</p>
<p><img src="http://pic.ex2tron.top/cv2_min_rect_rect_bounding.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x, y, w, h = cv2.boundingRect(cnt)  <span class="comment"># 外接矩形</span></div><div class="line">cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rect = cv2.minAreaRect(cnt)  <span class="comment"># 最小外接矩形</span></div><div class="line">box = np.int0(cv2.boxPoints(rect))  <span class="comment"># 矩形的四个角点取整</span></div><div class="line">cv2.drawContours(img_color1, [box], <span class="number">0</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>其中<code>np.int0(x)</code>是把x取整的操作，比如377.93就会变成377，也可以用<code>x.astype(np.int)</code></p>
<h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>外接圆跟外接矩形一样，找到一个能包围物体的最小圆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</div><div class="line">(x, y, radius) = np.int0((x, y, radius))  <span class="comment"># 圆心和半径取整</span></div><div class="line">cv2.circle(img_color2, (x, y), radius, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_min_enclosing_circle.jpg" alt=""></p>
<h3 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h3><p>我们可以用得到的轮廓拟合出一个椭圆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ellipse = cv2.fitEllipse(cnt)</div><div class="line">cv2.ellipse(img_color2, ellipse, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_fitting_ellipse.jpg" alt=""></p>
<h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回<strong>值越小，越相似</strong>。先读入下面这张图片：</p>
<p><img src="http://pic.ex2tron.top/cv2_match_shape_shapes.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'shapes.jpg'</span>, <span class="number">0</span>)</div><div class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</div><div class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</div><div class="line">img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  <span class="comment"># 用于绘制的彩色图</span></div></pre></td></tr></table></figure>
<p>图中有3条轮廓，我们用A/B/C表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cnt_a, cnt_b, cnt_c = contours[<span class="number">0</span>], contours[<span class="number">1</span>], contours[<span class="number">2</span>]</div><div class="line">print(cv2.matchShapes(cnt_b, cnt_b, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.0</span></div><div class="line">print(cv2.matchShapes(cnt_b, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 2.17e-05</span></div><div class="line">print(cv2.matchShapes(cnt_b, cnt_a, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.418</span></div></pre></td></tr></table></figure>
<p>可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，详情可参考：<a href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f" target="_blank" rel="external">ShapeMatchModes</a>，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p>
<p>形状匹配是通过图像的Hu矩来实现的(<code>cv2.HuMoments()</code>)，大家如果感兴趣，可以参考：<a href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments" target="_blank" rel="external">Hu-Moments</a></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>前面我们是对图片中的数字3进行轮廓特征计算的，大家换成数字1看看</li>
<li>（选做）用形状匹配比较两个字母或数字（这相当于很简单的一个<a href="https://baike.baidu.com/item/%E5%85%89%E5%AD%A6%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/4162921?fr=aladdin&amp;fromid=25995&amp;fromtitle=OCR" target="_blank" rel="external">OCR</a>噢）</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>常用的轮廓特征：</p>
<ul>
<li>cv2.contourArea()算面积，cv2.arcLength()算周长，cv2.boundingRect()算外接矩</li>
<li>cv2.minAreaRect()算最小外接矩，cv2.minEnclosingCircle()算最小外接圆</li>
<li>cv2.matchShapes()进行形状匹配</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/14.%20%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html" target="_blank" rel="external">Contour Features</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html" target="_blank" rel="external">Contours : More Functions</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习计算轮廓特征，如面积、周长、最小外接矩形等。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="轮廓" scheme="http://ex2tron.coding.me/tags/%E8%BD%AE%E5%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇10：凸包及更多轮廓特征</title>
    <link href="http://ex2tron.coding.me/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8710%EF%BC%9A%E5%87%B8%E5%8C%85%E5%8F%8A%E6%9B%B4%E5%A4%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/"/>
    <id>http://ex2tron.coding.me/2017/12/20/Python-OpenCV教程番外篇10：凸包及更多轮廓特征/</id>
    <published>2017-12-20T05:41:11.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p>计算凸包及更多轮廓特征。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<h2 id="多边形逼近"><a href="#多边形逼近" class="headerlink" title="多边形逼近"></a>多边形逼近</h2><p>前面我们学习过最小外接矩和最小外接圆，那么可以用一个最小的多边形包围物体吗？当然可以：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.先找到轮廓</span></div><div class="line">img = cv2.imread(<span class="string">'unregular.jpg'</span>, <span class="number">0</span>)</div><div class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</div><div class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</div><div class="line">cnt = contours[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment"># 2.进行多边形逼近，得到多边形的角点</span></div><div class="line">approx = cv2.approxPolyDP(cnt, <span class="number">3</span>, <span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># 3.画出多边形</span></div><div class="line">image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</div><div class="line">cv2.polylines(image, [approx], <span class="keyword">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>其中<code>cv2.approxPolyDP()</code>的参数2(epsilon)是一个距离值，表示多边形的轮廓接近实际轮廓的程度，值越小，越精确；参数3表示是否闭合。</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_approxpoly.jpg" alt=""></p>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p><a href="https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150?fr=aladdin" target="_blank" rel="external">凸包</a>跟多边形逼近很像，只不过它是物体最外层的”凸”多边形：集合A内连接任意两个点的直线都在A的内部，则称集合A是凸形的。如下图，红色的部分为手掌的凸包，双箭头部分表示凸缺陷(Convexity Defects)，凸缺陷常用来进行手势识别等：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_convex.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.先找到轮廓</span></div><div class="line">img = cv2.imread(<span class="string">'convex.jpg'</span>, <span class="number">0</span>)</div><div class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</div><div class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</div><div class="line">cnt = contours[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="comment"># 2.寻找凸包，得到凸包的角点</span></div><div class="line">hull = cv2.convexHull(cnt)</div><div class="line"></div><div class="line"><span class="comment"># 3.绘制凸包</span></div><div class="line">image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</div><div class="line">cv2.polylines(image, [hull], <span class="keyword">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_convex_hull.jpg" alt=""></p>
<p>其中函数<code>cv2.convexHull()</code>有个可选参数<code>returnPoints</code>，默认是True，代表返回角点的x/y坐标；如果为False的话，表示返回轮廓中是凸包角点的索引，比如说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(hull[<span class="number">0</span>])  <span class="comment"># [[362 184]]（坐标）</span></div><div class="line">hull2 = cv2.convexHull(cnt, returnPoints=<span class="keyword">False</span>)</div><div class="line">print(hull2[<span class="number">0</span>])  <span class="comment"># [510]（cnt中的索引）</span></div><div class="line">print(cnt[<span class="number">510</span>])  <span class="comment"># [[362 184]]</span></div></pre></td></tr></table></figure>
<p>当使用<code>cv2.convexityDefects()</code>计算凸包缺陷时，<code>returnPoints</code>需为False，详情可参考：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="external">Convexity Defects</a></p>
<p>另外可以用下面的语句来判断轮廓是否是凸形的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(cv2.isContourConvex(hull))  <span class="comment"># True</span></div></pre></td></tr></table></figure>
<h2 id="点到轮廓距离"><a href="#点到轮廓距离" class="headerlink" title="点到轮廓距离"></a>点到轮廓距离</h2><p><code>cv2.pointPolygonTest()</code>函数计算点到轮廓的最短距离（也就是垂线），又称多边形测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dist = cv2.pointPolygonTest(cnt, (<span class="number">100</span>, <span class="number">100</span>), <span class="keyword">True</span>)  <span class="comment"># -3.53</span></div></pre></td></tr></table></figure>
<p>其中参数3为True时表示计算距离值：点在轮廓外面值为负，点在轮廓上值为0，点在轮廓里面值为正；参数3为False时，只返回-1/0/1表示点相对轮廓的位置，不计算距离。</p>
<p>更多轮廓特征，如当量直径、平均强度等，我目前也没用到过，以后用到再写吧，感兴趣的可以参看：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="external">Contour Properties</a>、<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="external">Contours Hierarchy</a></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇10.%20凸包及更多轮廓特征" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="external">Convexity Defects</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="external">Contour Properties</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="external">Contours Hierarchy</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算凸包及更多轮廓特征。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="凸包" scheme="http://ex2tron.coding.me/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇9：轮廓层级</title>
    <link href="http://ex2tron.coding.me/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%879%EF%BC%9A%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7/"/>
    <id>http://ex2tron.coding.me/2017/12/20/Python-OpenCV教程番外篇9：轮廓层级/</id>
    <published>2017-12-20T04:41:11.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p>了解轮廓间的层级关系。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<p>前面我们使用<code>cv2.findContours()</code>寻找轮廓时，参数3表示轮廓的寻找方式(<code>RetrievalModes</code>)，当时我们传入的是<code>cv2.RETR_TREE</code>，它表示什么意思呢？另外，函数返回值hierarchy有什么用途呢？下面我们就来回答这两个问题。</p>
<h2 id="理解轮廓层级"><a href="#理解轮廓层级" class="headerlink" title="理解轮廓层级"></a>理解轮廓层级</h2><p>很多情况下，图像中的形状之间是有关联的，比如说下图：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_hierarchy.jpg" alt=""></p>
<p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p>
<ul>
<li>轮廓0/1/2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li>
<li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li>
<li>同样3是2a的子轮廓，轮廓3处于一个等级：2级</li>
<li>类似的，3a是3的子轮廓，等等…………</li>
</ul>
<p>这里面OpenCV关注的就是两个概念：同一轮廓等级和轮廓间的子属关系。</p>
<h2 id="OpenCV中轮廓等级的表示"><a href="#OpenCV中轮廓等级的表示" class="headerlink" title="OpenCV中轮廓等级的表示"></a>OpenCV中轮廓等级的表示</h2><p>如果我们打印出<code>cv2.findContours()</code>函数的返回值hierarchy，会发现它是一个包含4个值的数组：<strong>[Next, Previous, First Child, Parent]</strong></p>
<ul>
<li><em>Next：与当前轮廓处于同一层级的下一条轮廓</em></li>
</ul>
<p>举例来说，前面图中跟0处于同一层级的下一条轮廓是1，所以Next=1；同理，对轮廓1来说，Next=2；那么对于轮廓2呢？没有与它同一层级的下一条轮廓了，此时Next=-1。</p>
<ul>
<li><em>Previous：与当前轮廓处于同一层级的上一条轮廓</em></li>
</ul>
<p>跟前面一样，对于轮廓1来说，Previous=0；对于轮廓2，Previous=1；对于轮廓1，没有上一条轮廓了，所以Previous=-1。</p>
<ul>
<li><em>First Child：当前轮廓的第一条子轮廓</em></li>
</ul>
<p>比如对于轮廓2，第一条子轮廓就是轮廓2a，所以First Child=2a；对轮廓3a，First Child=4。</p>
<ul>
<li><em>Parent：当前轮廓的父轮廓</em></li>
</ul>
<p>比如2a的父轮廓是2，Parent=2；轮廓2没有父轮廓，所以Parent=-1。</p>
<p>下面我们通过代码验证一下：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.读入图片</span></div><div class="line">img = cv2.imread(<span class="string">'hierarchy.jpg'</span>)</div><div class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</div><div class="line">_, thresh = cv2.threshold(img_gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</div><div class="line"></div><div class="line"><span class="comment"># 2.寻找轮廓</span></div><div class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 3.绘制轮廓</span></div><div class="line">print(len(contours),hierarchy)  <span class="comment"># 8条</span></div><div class="line">cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：OpenCV中找到的轮廓序号跟前面讲的不同噢，如下图：</p>
</blockquote>
<p><img src="http://pic.ex2tron.top/cv2_hierarchy_RETR_TREE.jpg" alt=""></p>
<p>现在既然我们了解了层级的概念，那么类似<code>cv2.RETR_TREE</code>的轮廓寻找方式又是啥意思呢？</p>
<h2 id="轮廓寻找方式"><a href="#轮廓寻找方式" class="headerlink" title="轮廓寻找方式"></a>轮廓寻找方式</h2><p>OpenCV中有四种轮廓寻找方式<a href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="external">RetrievalModes</a>，下面分别来看下：</p>
<h3 id="1-RETR-LIST"><a href="#1-RETR-LIST" class="headerlink" title="1. RETR_LIST"></a>1. RETR_LIST</h3><p>这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。这样的话，hierarchy中的后两个值<code>[First Child, Parent]</code>都为-1。比如同样的图，我们使用RETR_LIST来寻找轮廓：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_, _, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, <span class="number">2</span>)</div><div class="line">print(hierarchy)</div><div class="line"><span class="comment"># 结果如下</span></div><div class="line">[[[ <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">2</span>  <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">3</span>  <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">4</span>  <span class="number">2</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">5</span>  <span class="number">3</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">6</span>  <span class="number">4</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">7</span>  <span class="number">5</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [<span class="number">-1</span>  <span class="number">6</span> <span class="number">-1</span> <span class="number">-1</span>]]]</div></pre></td></tr></table></figure>
<p>因为没有从属关系，所以轮廓0的下一条是1，1的下一条是2……</p>
<blockquote>
<p>经验之谈：如果你不需要轮廓层级信息的话，<code>cv2.RETR_LIST</code>更推荐使用，因为性能更好</p>
</blockquote>
<h3 id="2-RETR-TREE"><a href="#2-RETR-TREE" class="headerlink" title="2. RETR_TREE"></a>2. RETR_TREE</h3><p><code>cv2.RETR_TREE</code>就是之前我们一直在使用的方式，它会完整建立轮廓的层级从属关系，前面已经详细说明过了。</p>
<h3 id="3-RETR-EXTERNAL"><a href="#3-RETR-EXTERNAL" class="headerlink" title="3. RETR_EXTERNAL"></a>3. RETR_EXTERNAL</h3><p>这种方式只寻找最高层级的轮廓，也就是它只会找到前面我们所说的3条0级轮廓：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, <span class="number">2</span>)</div><div class="line">print(len(contours), hierarchy, sep=<span class="string">'\n'</span>)</div><div class="line"><span class="comment"># 结果如下</span></div><div class="line"><span class="number">3</span></div><div class="line">[[[ <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">2</span>  <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [<span class="number">-1</span>  <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span>]]]</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_hierarchy_RETR_EXTERNAL.jpg" alt=""></p>
<h3 id="4-RETR-CCOMP"><a href="#4-RETR-CCOMP" class="headerlink" title="4. RETR_CCOMP"></a>4. RETR_CCOMP</h3><p>相比之下<code>cv2.RETR_CCOMP</code>比较难理解，但其实也很简单：它把所有的轮廓只分为2个层级，不是外层的就是里层的。结合代码和图片，我们来理解下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, <span class="number">2</span>)</div><div class="line">print(hierarchy)</div><div class="line"><span class="comment"># 结果如下</span></div><div class="line">[[[ <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">2</span>  <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [ <span class="number">4</span>  <span class="number">1</span>  <span class="number">3</span> <span class="number">-1</span>]</div><div class="line">  [<span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>  <span class="number">2</span>]</div><div class="line">  [ <span class="number">6</span>  <span class="number">2</span>  <span class="number">5</span> <span class="number">-1</span>]</div><div class="line">  [<span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>  <span class="number">4</span>]</div><div class="line">  [ <span class="number">7</span>  <span class="number">4</span> <span class="number">-1</span> <span class="number">-1</span>]</div><div class="line">  [<span class="number">-1</span>  <span class="number">6</span> <span class="number">-1</span> <span class="number">-1</span>]]]</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_hierarchy_RETR_CCOMP.jpg" alt=""></p>
<blockquote>
<p>注意：使用这个参数找到的轮廓序号与之前不同</p>
</blockquote>
<p>图中括号里面1代表外层轮廓，2代表里层轮廓。比如说对于轮廓2，Next就是4，Previous是1，它有里层的轮廓3，所以First Child=3，但因为只有两个层级，它本身就是外层轮廓，所以Parent=-1。大家可以针对其他的轮廓自己验证一下。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>如下图，找到3个圆环的内环，然后填充成<code>(180,215,215)</code>这种颜色：</li>
</ol>
<p><img src="http://pic.ex2tron.top/cv2_hierarchy_fill_holes.jpg" alt=""></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇9.%20轮廓层级" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html#contours-hierarchy" target="_blank" rel="external">Contours Hierarchy</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解轮廓间的层级关系。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="轮廓层级" scheme="http://ex2tron.coding.me/tags/%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程13：轮廓</title>
    <link href="http://ex2tron.coding.me/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B13%EF%BC%9A%E8%BD%AE%E5%BB%93/"/>
    <id>http://ex2tron.coding.me/2017/12/20/Python-OpenCV教程13：轮廓/</id>
    <published>2017-12-20T01:44:23.000Z</published>
    <updated>2018-01-22T08:19:33.291Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何寻找并绘制轮廓。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>了解轮廓概念</li>
<li>寻找并绘制轮廓</li>
<li>OpenCV函数：cv2.findContours(), cv2.drawContours()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="啥叫轮廓"><a href="#啥叫轮廓" class="headerlink" title="啥叫轮廓"></a>啥叫轮廓</h3><p>轮廓是一系列相连的点组成的曲线，代表了物体的基本外形。</p>
<p>谈起轮廓不免想到边缘，它们确实很像。简单的说，轮廓是连续的，边缘并不全都连续（下图）。其实边缘主要是作为图像的特征使用，比如可以用边缘特征可以区分脸和手，而轮廓主要用来分析物体的形态，比如物体的周长和面积等，可以说边缘包括轮廓。</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_contours.jpg" alt=""></p>
<p>寻找轮廓的操作一般用于二值化图，所以通常会使用阈值分割或Canny边缘检测先得到二值图。</p>
<blockquote>
<p>经验之谈：<strong>寻找轮廓是针对白色物体的</strong>，一定要保证物体是白色，而背景是黑色，<em>*不然很多人在寻找轮廓时会找到图片最外面的一个框</em></p>
</blockquote>
<h3 id="寻找轮廓"><a href="#寻找轮廓" class="headerlink" title="寻找轮廓"></a>寻找轮廓</h3><p>使用<code>cv2.findContours()</code>寻找轮廓：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'handwriting.jpg'</span>)</div><div class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</div><div class="line">ret, thresh = cv2.threshold(img_gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</div><div class="line"><span class="comment"># 寻找二值化图中的轮廓</span></div><div class="line">image, contours, hierarchy = cv2.findContours(</div><div class="line">    thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</div><div class="line">print(len(contours))  <span class="comment"># 结果应该为2</span></div></pre></td></tr></table></figure>
<ul>
<li>参数2：轮廓的查找方式，一般使用<code>cv2.RETR_TREE</code>，表示提取所有的轮廓并建立轮廓间的层级。更多请参考：<a href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="external">RetrievalModes</a></li>
<li>参数3：轮廓的近似方法。比如对于一条直线，我们可以存储该直线的所有像素点，也可以只存储起点和终点。使用<code>cv2.CHAIN_APPROX_SIMPLE</code>就表示用尽可能少的像素点表示轮廓。更多请参考：<a href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga4303f45752694956374734a03c54d5ff" target="_blank" rel="external">ContourApproximationModes</a></li>
<li>简便起见，这两个参数也可以直接用真值<code>3</code>和<code>2</code>表示。</li>
</ul>
<p>函数有3个返回值，image还是原来的二值化图片，hierarchy是轮廓间的层级关系（<a href="/2017/12/20/Python-OpenCV教程番外篇9%EF%BC%9A轮廓层级/">番外篇：轮廓层级</a>），这两个暂时不用理会。我们主要看contours，它就是找到的轮廓了，以数组形式存储，记录了每条轮廓的所有像素点的坐标<code>(x,y)</code>。</p>
<p><img src="http://pic.ex2tron.top/cv2_find_contours_contours.jpg" alt=""></p>
<h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><p>轮廓找出来后，为了方便观看，可以像前面图中那样用红色画出来：<code>cv2.drawContours()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>其中参数2就是得到的contours，参数3表示要绘制哪一条轮廓，-1表示绘制所有轮廓，参数4是颜色（B/G/R通道，所以(0,0,255)表示红色），参数5是线宽，之前在绘制图形中介绍过。</p>
<blockquote>
<p>经验之谈：很多人画图时明明用了彩色，但没有效果，请检查你是在哪个图上画，画在灰度图和二值图上显然是没有彩色的(⊙o⊙)</p>
</blockquote>
<p>一般情况下，我们会首先获得要操作的轮廓，再进行轮廓绘制及分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cnt = contours[<span class="number">1</span>]</div><div class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>轮廓特征非常有用，使用cv2.findContours()寻找物体的轮廓，cv2.drawContours()绘制轮廓</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/13.%20%E8%BD%AE%E5%BB%93" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_begin/py_contours_begin.html" target="_blank" rel="external">Contours : Getting Started</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何寻找并绘制轮廓。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="轮廓" scheme="http://ex2tron.coding.me/tags/%E8%BD%AE%E5%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程12：腐蚀与膨胀</title>
    <link href="http://ex2tron.coding.me/2017/12/19/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/"/>
    <id>http://ex2tron.coding.me/2017/12/19/Python-OpenCV教程12：腐蚀与膨胀/</id>
    <published>2017-12-19T12:52:23.000Z</published>
    <updated>2018-01-22T08:17:22.194Z</updated>
    
    <content type="html"><![CDATA[<p>学习常用形态学操作：腐蚀膨胀，开运算和闭运算。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>了解形态学操作的概念</li>
<li>学习膨胀、腐蚀、开运算和闭运算等形态学操作</li>
<li>OpenCV函数：cv2.erode(), cv2.dilate(), cv2.morphologyEx()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="啥叫形态学操作"><a href="#啥叫形态学操作" class="headerlink" title="啥叫形态学操作"></a>啥叫形态学操作</h3><p>形态学操作其实就是<strong>改变物体的形状</strong>，比如腐蚀就是”变瘦”，膨胀就是”变胖”，看下图就明白了：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_morphological.jpg" alt=""></p>
<blockquote>
<p>形态学操作一般作用于二值化图，来连接相邻的元素或分离成独立的元素。<strong>腐蚀和膨胀是针对图片中的白色部分！</strong></p>
</blockquote>
<h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p>腐蚀的效果是把图片”变瘦”，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有0和255，所以小区域内有一个是0该像素点就为0：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_erosion.jpg" alt=""></p>
<p>这样原图中边缘地方就会变成0，达到了瘦身目的（小胖福利(●ˇ∀ˇ●)）</p>
<p>OpenCV中用<code>cv2.erode()</code>函数进行腐蚀，只需要指定核的大小就行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'j.bmp'</span>, <span class="number">0</span>)</div><div class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</div><div class="line">erosion = cv2.erode(img, kernel)  <span class="comment"># 腐蚀</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的。结构元素可以是矩形/椭圆/十字形，可以用<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素，比如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构</span></div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 椭圆结构</span></div><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字形结构</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_morphological_struct_element.jpg" alt=""></p>
<h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀与腐蚀相反，取的是局部最大值，效果是把图片”变胖”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dilation = cv2.dilate(img, kernel)  <span class="comment"># 膨胀</span></div></pre></td></tr></table></figure>
<h3 id="开-闭运算"><a href="#开-闭运算" class="headerlink" title="开/闭运算"></a>开/闭运算</h3><p>先腐蚀后膨胀叫开运算（因为先腐蚀会分开物体，这样容易记住），其作用是：分离物体，消除小区域。这类形态学操作用<code>cv2.morphologyEx()</code>函数实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 定义结构元素</span></div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'j_noise_out.bmp'</span>, <span class="number">0</span>)</div><div class="line">opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></div></pre></td></tr></table></figure>
<p>闭运算则相反：先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除/“闭合”物体里面的小黑洞，所以叫闭运算）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'j_noise_in.bmp'</span>, <span class="number">0</span>)</div><div class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_morphological_opening_closing.jpg" alt=""></p>
<blockquote>
<p>经验之谈：很多人对开闭运算的作用不是很清楚（好吧，其实是比较容易混◑﹏◐），但看上图↑，不用怕：如果我们的目标物体外面有很多无关的小区域，就用开运算去除掉；如果物体内部有很多小黑洞，就用闭运算填充掉</p>
</blockquote>
<p>接下来的3种形态学操作并不常用，大家有兴趣可以看看（因为较短，没有做成番外篇）：</p>
<h3 id="其他形态学操作"><a href="#其他形态学操作" class="headerlink" title="其他形态学操作"></a>其他形态学操作</h3><ul>
<li>形态学梯度：膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'school.bmp'</span>, <span class="number">0</span>)</div><div class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_morphological_gradient.jpg" alt=""></p>
<ul>
<li>顶帽：原图减去开运算后的图：<code>src - opening</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)</div></pre></td></tr></table></figure>
<ul>
<li>黑帽：闭运算后的图减去原图：<code>closing - src</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>形态学操作就是改变物体的形状，如腐蚀使物体”变瘦”，膨胀使物体”变胖”</li>
<li>先腐蚀后膨胀会分离物体，所以叫开运算，常用来去除小区域物体</li>
<li>先膨胀后腐蚀会消除物体内的小洞，所以叫闭运算。开/闭理解了之后很容易记忆噢(⊙o⊙)</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/12.%20%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm" target="_blank" rel="external">Morphological Operations</a></li>
<li><a href="http://szeliski.org/Book/" target="_blank" rel="external">Computer Vision: Algorithms and Applications</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习常用形态学操作：腐蚀膨胀，开运算和闭运算。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="腐蚀" scheme="http://ex2tron.coding.me/tags/%E8%85%90%E8%9A%80/"/>
    
      <category term="膨胀" scheme="http://ex2tron.coding.me/tags/%E8%86%A8%E8%83%80/"/>
    
      <category term="形态学" scheme="http://ex2tron.coding.me/tags/%E5%BD%A2%E6%80%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程11：边缘检测</title>
    <link href="http://ex2tron.coding.me/2017/12/18/Python-OpenCV%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
    <id>http://ex2tron.coding.me/2017/12/18/Python-OpenCV教程11：边缘检测/</id>
    <published>2017-12-18T09:11:48.000Z</published>
    <updated>2018-01-05T04:39:30.831Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用Canny获取图像的边缘。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>Canny边缘检测的简单概念</li>
<li>OpenCV函数：cv2.Canny()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="废话不多说，直接上"><a href="#废话不多说，直接上" class="headerlink" title="废话不多说，直接上"></a>废话不多说，直接上</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'handwriting.jpg'</span>, <span class="number">0</span>)</div><div class="line">edges = cv2.Canny(img, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment"># canny边缘检测</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_canny_edge_detection.jpg" alt=""></p>
<p><code>cv2.Canny()</code>进行边缘检测，参数2、3表示最低、高阈值，看完后面的理论就理解了。</p>
<blockquote>
<p>经验之谈：之前我们用低通滤波的方式模糊了图片，那如果反过来，想得到物体的边缘，就需要用到高通滤波。如果你要理解接下来要说的Canny检测原理，请先阅读：<a href="/2017/12/18/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/">番外篇：图像梯度</a></p>
</blockquote>
<h3 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h3><p>Canny边缘检测方法常被誉为边缘检测的最优方法，具体步骤如下：</p>
<p>1，使用5×5高斯滤波消除噪声：</p>
<p>边缘检测本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理。</p>
<p>2，计算图像梯度的方向：</p>
<p>首先使用Sobel算子计算梯度<code>Gx</code>和<code>Gy</code>，然后算出梯度的方向：<code>θ=arctan(Gy/Gx)</code>，保留这四个方向的梯度：0°/45°/90°/135°，有什么用呢？我们接着看。</p>
<p>3，取局部极大值：</p>
<p>梯度其实已经表示了轮廓，为了进一步筛选，可以在上面的四个角度方向上再取局部极大值：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_canny_direction.jpg" alt=""></p>
<p>比如，A点在45°方向上大于B/C点，那就保留它，把B/C设置为0。</p>
<p>4，滞后阈值：</p>
<p>经过前面三步，就只剩下0和可能的边缘像素值了，为了最终确定下来，需要设定高低阈值：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_canny_max_min_val.jpg" alt=""></p>
<ul>
<li>像素点的值大于最高阈值，那肯定是边缘（上图A）</li>
<li>同理像素值小于最低阈值，那肯定不是边缘</li>
<li>像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘，所以上图中C算，B不算</li>
</ul>
<p>Canny推荐的高低阈值比在<code>2:1</code>到<code>3:1</code>之间。</p>
<h3 id="先阈值分割"><a href="#先阈值分割" class="headerlink" title="先阈值分割"></a>先阈值分割</h3><p>其实很多情况下，阈值分割后再检测边缘，效果会更好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</div><div class="line">edges = cv2.Canny(thresh, <span class="number">30</span>, <span class="number">70</span>)</div></pre></td></tr></table></figure>
<p>代码中我用了<a href="/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/">番外篇：Otsu阈值法</a>中的自动阈值分割，如果你不太了解，大可以使用传统的方法，不过如果是下面这种图片，推荐用Otsu阈值法。另外Python中某个值不用的话，就写个下划线’_’。</p>
<p><img src="http://pic.ex2tron.top/cv2_canny_edge_detection_threshold.jpg" alt=""></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>（选做）如果你不太理解高低阈值的效果，创建两个滑动条来调节它们的值看看：</li>
</ol>
<p><img src="http://pic.ex2tron.top/cv2_trackbar_maxval_minval_canny.gif" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Canny是用的最多的边缘检测算法，用cv2.Canny()实现</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/11.%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" target="_blank" rel="external">Canny Edge Detection</a></li>
<li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html" target="_blank" rel="external">Canny 边缘检测</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用Canny获取图像的边缘。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="边缘" scheme="http://ex2tron.coding.me/tags/%E8%BE%B9%E7%BC%98/"/>
    
      <category term="Canny" scheme="http://ex2tron.coding.me/tags/Canny/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇8：图像梯度</title>
    <link href="http://ex2tron.coding.me/2017/12/18/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/"/>
    <id>http://ex2tron.coding.me/2017/12/18/Python-OpenCV教程番外篇8：图像梯度/</id>
    <published>2017-12-18T02:51:43.000Z</published>
    <updated>2018-01-19T05:36:11.748Z</updated>
    
    <content type="html"><![CDATA[<p>了解图像梯度和边缘检测的相关概念。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<p>还记得前面<a href="/2017/12/15/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/">平滑图像</a>中提到的滤波与模糊的区别吗？我们说低通滤波器是模糊，高通滤波器是锐化，这节我们就来看看高通滤波器。</p>
<h2 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a><a href="https://baike.baidu.com/item/图像梯度/8528837?fr=aladdin" target="_blank" rel="external">图像梯度</a></h2><p>如果你还记得高数中用一阶导数来求极值的话，就很容易理解了：把图片想象成连续函数，因为边缘部分的像素值是与旁边像素明显有区别的，所以对图片局部求极值，就可以得到整幅图片的边缘信息了。不过图片是二维的离散函数，导数就变成了差分，这个差分就称为图像的梯度。</p>
<p>当然，大部分人应该是早忘记高数了(￣▽￣)”，所以看不懂的话，就把上面的解释划掉，我们重新从卷积的角度来看看。</p>
<h3 id="垂直边缘提取"><a href="#垂直边缘提取" class="headerlink" title="垂直边缘提取"></a>垂直边缘提取</h3><p>滤波是应用卷积来实现的，卷积的关键就是卷积核，我们来考察下面这个卷积核：</p>
<p>$$<br>k1 = \left[<br> \begin{matrix}<br>   -1 &amp; 0 &amp; 1 \newline<br>   -2 &amp; 0 &amp; 2 \newline<br>   -1 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p>
<p>这个核是用来提取图片中的垂直边缘的，怎么做到的呢？看下图：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_sobel_edge_detection.jpg" alt=""></p>
<p>当前列左右两侧的元素进行差分，由于边缘的值明显小于（或大于）周边像素，所以边缘的差分结果会明显不同，这样就提取出了垂直边缘。同理，把上面那个矩阵转置一下，就是提取水平边缘。这种差分操作就叫图像的梯度计算：</p>
<p>$$<br>k2 = \left[<br> \begin{matrix}<br>   -1 &amp; -2 &amp; -1 \newline<br>   0 &amp; 0 &amp; 0 \newline<br>   1 &amp; 2 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p>
<p><img src="http://pic.ex2tron.top/cv2_horizen_vertical_edge_detection.jpg" alt="垂直和水平边缘提取"></p>
<blockquote>
<p>还记得滤波函数<code>cv2.filter2D()</code>吗？（<a href="/2017/12/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/">番外篇：卷积基础</a>）我们来手动实现上面的功能：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'sudoku.jpg'</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 自己进行垂直边缘提取</span></div><div class="line">kernel = np.array([[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</div><div class="line">                   [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>],</div><div class="line">                   [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]], dtype=np.float32)</div><div class="line">dst_v = cv2.filter2D(img, <span class="number">-1</span>, kernel)</div><div class="line"><span class="comment"># 自己进行水平边缘提取</span></div><div class="line">dst_h = cv2.filter2D(img, <span class="number">-1</span>, kernel.T)</div><div class="line"><span class="comment"># 横向并排对比显示</span></div><div class="line">cv2.imshow(<span class="string">'edge'</span>, np.hstack((img, dst_v, dst_h)))</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>上面的这种差分方法就叫<a href="https://baike.baidu.com/item/Sobel%E7%AE%97%E5%AD%90/11000092?fr=aladdin" target="_blank" rel="external">Sobel算子</a>，它先在垂直方向计算梯度Gx=k1×src，再在水平方向计算梯度Gy=k2×src，最后求出总梯度：\(G=\sqrt{Gx^2+Gy^2}\)</p>
<p>我们可以把前面的代码用Sobel算子更简单地实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sobelx = cv2.Sobel(img, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算x方向</span></div><div class="line">sobely = cv2.Sobel(img, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算y方向</span></div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：很多人疑问，Sobel算子的卷积核这几个值是怎么来的呢？事实上，并没有规定，你可以用你自己的。当然，3×3下另外一个卷积核相比Sobel更好用，叫<strong>Scharr算子</strong>，大家可以了解下：</p>
</blockquote>
<p>$$<br>K = \left[<br> \begin{matrix}<br>   -3 &amp; 0 &amp; 3 \newline<br>   -10 &amp; 0 &amp; 10 \newline<br>   -3 &amp; 0 &amp; 3<br>  \end{matrix}<br>  \right]<br>$$</p>
<h3 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h3><p>好开心，又要扯到高数的东西辣(￣_,￣ )高数中用一阶导数求极值，在这些极值的地方，二阶导数为0，所以可以通过求二阶导计算梯度：\(dst=\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2}\)</p>
<p>这就是<a href="https://baike.baidu.com/item/Laplacian%E7%AE%97%E5%AD%90" target="_blank" rel="external">Laplacian算子</a>，了解了之后，最关键的是要会用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">laplacian = cv2.Laplacian(img, <span class="number">-1</span>)  <span class="comment"># 使用Laplacian算子</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_laplacian.jpg" alt=""></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>（选做）同志们有空补补高数<del>姿势</del>（知识）呗！(✿◕‿◕✿)</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇8.%20图像梯度" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_gradients/py_gradients.html" target="_blank" rel="external">Image Gradients</a></li>
<li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/sobel_derivatives/sobel_derivatives.html#sobel-derivatives" target="_blank" rel="external">Sobel导数</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解图像梯度和边缘检测的相关概念。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="梯度" scheme="http://ex2tron.coding.me/tags/%E6%A2%AF%E5%BA%A6/"/>
    
      <category term="Sobel" scheme="http://ex2tron.coding.me/tags/Sobel/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程10：平滑图像</title>
    <link href="http://ex2tron.coding.me/2017/12/15/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/"/>
    <id>http://ex2tron.coding.me/2017/12/15/Python-OpenCV教程10：平滑图像/</id>
    <published>2017-12-15T01:44:24.000Z</published>
    <updated>2018-01-22T08:16:47.654Z</updated>
    
    <content type="html"><![CDATA[<p>学习模糊/平滑图像，消除噪点。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>模糊/平滑图片来消除图片噪声</li>
<li>OpenCV函数：cv2.blur(), cv2.GaussianBlur(), cv2.medianBlur(), cv2.bilateralFilter()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="滤波与模糊"><a href="#滤波与模糊" class="headerlink" title="滤波与模糊"></a>滤波与模糊</h3><p>推荐大家先阅读：<a href="/2017/12/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/">番外篇：卷积基础(图片边框)</a>，有助于理解卷积和滤波的概念。</p>
<p>关于滤波和模糊，很多人分不清，我来给大家理理（虽说如此，我后面也会混着用,,ԾㅂԾ,,）：</p>
<ul>
<li>它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言）</li>
<li>低通滤波器是模糊，高通滤波器是锐化</li>
</ul>
<p>低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。</p>
<blockquote>
<p>常见噪声有<a href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958?fr=aladdin" target="_blank" rel="external">椒盐噪声</a>和<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0" target="_blank" rel="external">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声；这样解释并不准确，只要能简单分辨即可</p>
</blockquote>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p>
<p>$$<br> kernel = \frac{1}{9}\left[<br> \begin{matrix}<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</div><div class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 均值模糊</span></div></pre></td></tr></table></figure>
<blockquote>
<p>所有的滤波函数都有一个可选参数borderType，还记得吗？这个参数就是我们在<a href="/2017/12/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/">番外篇：卷积基础(图片边框)</a>中所说的边框填充方式。</p>
</blockquote>
<h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>方框滤波跟均值滤波很像，如下面的公式。用<code>cv2.boxFilter()</code>函数实现，事实上，当可选参数<code>normalize</code>为True的时候，方框滤波就是均值滤波，如3×3的核，a就等于1/9；<code>normalize</code>为False的时候，a=1，相当于求区域内的像素和。</p>
<p>$$<br> k = a\left[<br> \begin{matrix}<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span></div><div class="line">blur = cv2.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>前面两种滤波方式，卷积核内的每个值都一样，相当于图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同，中间像素点权重最高，越远离中心的像素权重越小。（其原理是一个2维高斯函数，可以参考：<a href="https://en.wikipedia.org/wiki/Gaussian_filter" target="_blank" rel="external">Gaussian Filter</a>）</p>
<p>高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'gaussian_noise.bmp'</span>)</div><div class="line"><span class="comment"># 均值滤波vs高斯滤波</span></div><div class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></div><div class="line">gaussian = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">1</span>)  <span class="comment"># 高斯滤波</span></div></pre></td></tr></table></figure>
<p>均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p>
<p><img src="http://pic.ex2tron.top/cv2_gaussian_vs_average.jpg" alt=""></p>
<p>GaussianBlur()中参数3是σx，值越大，模糊效果越明显，0代表默认值0.8：<a href="https://docs.opencv.org/3.3.1/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" target="_blank" rel="external">getGaussianKernel()</a></p>
<h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%80%BC" target="_blank" rel="external">中值</a>又叫中位数，是所有值排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，适用于去除椒盐噪声和斑点噪声。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p>
<p>比如下面这张斑点噪声图，用中值滤波显然更好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'salt_noise.bmp'</span>, <span class="number">0</span>)</div><div class="line"><span class="comment"># 均值滤波vs中值滤波</span></div><div class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></div><div class="line">median = cv2.medianBlur(img, <span class="number">5</span>)  <span class="comment"># 中值滤波</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_median_vs_average.jpg" alt=""></p>
<h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘edge信息是图像中很重要的一个特征，所以这才有了<a href="https://baike.baidu.com/item/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2" target="_blank" rel="external">双边滤波</a>。用<code>cv2.bilateralFilter()</code>函数实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</div><div class="line"><span class="comment"># 双边滤波vs高斯滤波</span></div><div class="line">gau = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯滤波</span></div><div class="line">blur = cv2.bilateralFilter(img, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)  <span class="comment"># 双边滤波</span></div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_bilateral_vs_gaussian.jpg" alt=""></p>
<p>可以看到，双边滤波明显保留了更多边缘信息。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code></li>
<li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code></li>
<li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code></li>
<li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）</li>
<li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/10.%20%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html" target="_blank" rel="external">Smoothing Images</a></li>
<li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html" target="_blank" rel="external">图像平滑处理</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习模糊/平滑图像，消除噪点。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="模糊" scheme="http://ex2tron.coding.me/tags/%E6%A8%A1%E7%B3%8A/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇7：卷积基础(图片边框)</title>
    <link href="http://ex2tron.coding.me/2017/12/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/"/>
    <id>http://ex2tron.coding.me/2017/12/14/Python-OpenCV教程番外篇7：卷积基础-图片边框/</id>
    <published>2017-12-14T08:27:45.000Z</published>
    <updated>2018-01-19T05:35:53.894Z</updated>
    
    <content type="html"><![CDATA[<p>了解卷积/滤波的基础知识，给图片添加边框。<a id="more"></a>如果你已了解相关理论，请直接跳到<a href="#添加边框">添加边框</a>部分。</p>
<p>卷积的概念其实很好理解，下面我就用图文给大家做个最简单的解释，绝对轻松加愉快的辣o(<em>￣▽￣</em>)o</p>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>什么是二维卷积呢？看下面一张图就一目了然：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_convolution.jpg" alt=""></p>
<p>卷积就是循环对<strong>图像跟一个核逐个元素相乘再求和得到另外一副图像的操作</strong>，比如结果图中第一个元素5是怎么算的呢？原图中3×3的区域与3×3的核逐个元素相乘再相加：<code>1×1 + 2×0 + 1×0 + 0×0 + 1×0 + 1×0 + 3×0 + 0×0 + 2×2 = 5</code>。算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_cnn.gif" alt=""></p>
<h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫padding</strong>。</p>
<blockquote>
<p>事实上，原图为n×n，卷积核为f×f，最终结果图大小为(n-f+1) × (n-f+1)</p>
</blockquote>
<p><img src="http://pic.ex2tron.top/cv2_understand_padding.jpg" alt=""></p>
<p>那么扩展的这一层应该填充什么值呢？OpenCV中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现，一起来看看。</p>
<h2 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h2><p><code>cv2.copyMakeBorder()</code>用来给图片添加边框，它有下面几个参数：</p>
<ul>
<li>src：要处理的原图</li>
<li>top, bottom, left, right：上下左右要扩展的像素数</li>
<li><strong>borderType</strong>：边框类型，这个就是需要关注的填充方式，详情请参考：<a href="https://docs.opencv.org/3.3.1/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5" target="_blank" rel="external">BorderTypes</a></li>
</ul>
<p>其中默认方式和固定值方式最常用，我们详细说明一下：</p>
<h3 id="固定值填充"><a href="#固定值填充" class="headerlink" title="固定值填充"></a>固定值填充</h3><p>顾名思义，<code>cv2.BORDER_CONSTANT</code>这种方式就是边框都填充成一个固定的值，比如下面的程序都填充0：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'6_by_6.bmp'</span>, <span class="number">0</span>)</div><div class="line">print(img)</div><div class="line"></div><div class="line"><span class="comment"># 固定值边框，统一都填充0也称为zero padding</span></div><div class="line">cons = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_CONSTANT, value=<span class="number">0</span>)</div><div class="line">print(cons)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_zero_padding_output.jpg" alt=""></p>
<h3 id="默认边框类型"><a href="#默认边框类型" class="headerlink" title="默认边框类型"></a>默认边框类型</h3><p>默认边框<code>cv2.BORDER_DEFAULT</code>其实是取镜像对称的像素填充，比较拗口，一步步解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">default = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_DEFAULT)</div><div class="line">print(default)</div></pre></td></tr></table></figure>
<p>首先进行上下填充，填充成与原图像边界对称的值，如下图：</p>
<p><img src="http://pic.ex2tron.top/cv2_up_down_padding_first.jpg" alt=""></p>
<p>同理再进行左右两边的填充，最后把四个顶点补充上就好了：</p>
<p><img src="http://pic.ex2tron.top/cv2_right_left_padding_second2.jpg" alt=""></p>
<blockquote>
<p>一般情况下默认方式更加合理，因为边界的像素值更加接近，当然应视场合而定</p>
</blockquote>
<h2 id="OpenCV进行卷积"><a href="#OpenCV进行卷积" class="headerlink" title="OpenCV进行卷积"></a>OpenCV进行卷积</h2><p>OpenCV中用<code>cv2.filter2D()</code>实现卷积操作，比如我们的核是下面这样（3×3区域像素的和除以10）：</p>
<p>$$<br> M = \frac{1}{10}\left[<br> \begin{matrix}<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1<br>  \end{matrix}<br>  \right] \tag{3}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</div><div class="line"><span class="comment"># 定义卷积核</span></div><div class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.float32) / <span class="number">10</span></div><div class="line"><span class="comment"># 卷积操作，-1表示通道数与原图相同</span></div><div class="line">dst = cv2.filter2D(img, <span class="number">-1</span>, kernel)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_convolution_kernel_3_3.jpg" alt=""></p>
<p>可以看到这个核对图像进行了模糊处理，这是卷积的众多功能之一。当然卷积还有很多知识没有学到，后面我们再继续深入。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>尝试给”lena.jpg”添加几种不同的边框类型，对比下效果</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇7.%20卷积基础(图片边框" target="_blank" rel="external">本节源码</a>)</li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html" target="_blank" rel="external">Basic Operations on Images</a></li>
<li><a href="http://blog.csdn.net/zouxy09/article/details/49080029" target="_blank" rel="external">图像卷积与滤波的一些知识点</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解卷积/滤波的基础知识，给图片添加边框。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="卷积" scheme="http://ex2tron.coding.me/tags/%E5%8D%B7%E7%A7%AF/"/>
    
      <category term="边框" scheme="http://ex2tron.coding.me/tags/%E8%BE%B9%E6%A1%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程</title>
    <link href="http://ex2tron.coding.me/2017/12/12/Python-OpenCV%E6%95%99%E7%A8%8B/"/>
    <id>http://ex2tron.coding.me/2017/12/12/Python-OpenCV教程/</id>
    <published>2017-12-12T15:04:43.021Z</published>
    <updated>2018-03-15T07:06:32.666Z</updated>
    
    <content type="html"><![CDATA[<p>图文版 | <a href="/2017/10/10/Python-OpenCV%E6%95%99%E7%A8%8B%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89/">简洁版</a><a id="more"></a></p>
<h3 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h3><table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/">1. 简介与安装</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_introduction2.jpg" align="left"></td>
<td style="text-align:right">了解并安装OpenCV-Python<br><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">番外篇1：代码性能优化</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/">2. 基本元素-图片</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_basic_picture2.jpg" align="left"></td>
<td style="text-align:right">载入图片，显示并保存<br><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9AMatplotlib%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/">番外篇2：Matplotlib显示图像</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/">3. 打开摄像头</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_open_camera2.jpg" align="left"></td>
<td style="text-align:right">打开摄像头捕获图片，播放本地视频，保存视频<br><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/">番外篇3：滑动条</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">4. 图像基本操作</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_basic_operations2.jpg" align="left"></td>
<td style="text-align:right">访问像素点，ROI感兴趣区域，多通道分离和合并</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/">5. 颜色空间转换</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_color_spaces2.jpg" align="left"></td>
<td style="text-align:right">颜色空间转换，追踪视频中特定颜色的物体</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/">6. 阈值分割</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_threshold2.jpg" align="left"></td>
<td style="text-align:right">阈值分割，二值化图像<br><a href="/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/">番外篇4：Otsu阈值法</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/">7. 图像几何变换</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_geometrics2.jpg" align="left"></td>
<td style="text-align:right">旋转，平移，缩放图像，仿射变换和透视变换</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/09/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/">8. 绘图功能</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_drawing_functions2.jpg" align="left"></td>
<td style="text-align:right">画直线，画圆/椭圆，画矩形和添加文字<br><a href="/2017/12/09/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE/">番外篇5：鼠标绘图</a></td>
</tr>
</tbody>
</table>
<h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/10/Python-OpenCV%E6%95%99%E7%A8%8B9%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/">9. 图像混合</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_image_blending2.jpg" align="left"></td>
<td style="text-align:right">图像的算数运算、按位运算，图像混合<br><a href="/2017/12/10/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%876%EF%BC%9A%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6/">番外篇6：亮度与对比度</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/15/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/">10. 平滑图像</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_blur_image2.jpg" align="left"></td>
<td style="text-align:right">卷积基础，滤波和图像模糊降噪<br><a href="/2017/12/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/">番外篇7：卷积基础(图片边框)</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/18/Python-OpenCV%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/">11. 边缘检测</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_edge_detection2.jpg" align="left"></td>
<td style="text-align:right">Canny边缘检测，Sobel算子<br><a href="/2017/12/18/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/">番外篇8：图像梯度</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/19/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/">12. 腐蚀与膨胀</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_erosion_dilation2.jpg" align="left"></td>
<td style="text-align:right">形态学操作：腐蚀和膨胀，开运算和闭运算，顶帽和黑帽</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B13%EF%BC%9A%E8%BD%AE%E5%BB%93/">13. 轮廓</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_find_contours2.jpg" align="left"></td>
<td style="text-align:right">寻找并绘制物体轮廓<br>      <a href="/2017/12/20/Python-OpenCV教程番外篇9：轮廓层级/">番外篇9：轮廓层级</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B14%EF%BC%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/">14. 轮廓特征</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_contours_features2.jpg" align="left"></td>
<td style="text-align:right">轮廓特征：面积，周长，最小外接矩和最小外接圆，几何形状匹配<br>      <a href="/2017/12/20/Python-OpenCV教程番外篇10：凸包及更多轮廓特征/">番外篇10：凸包及更多轮廓特征</a></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/23/Python-OpenCV%E6%95%99%E7%A8%8B15%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE/">15. 直方图</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_histogram.jpg" align="left"></td>
<td style="text-align:right">了解，计算并绘制直方图，（自适应）直方图均衡化</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/27/Python-OpenCV%E6%95%99%E7%A8%8B16%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/">16. 模板匹配</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_template_matching2.jpg" align="left"></td>
<td style="text-align:right">使用模板匹配在大图中找到小图</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left"><a href="/2017/12/28/Python-OpenCV%E6%95%99%E7%A8%8B17%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/">17. 霍夫变换</a></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="http://pic.ex2tron.top/cv2_thumbnail_hough_transform2.jpg" align="left"></td>
<td style="text-align:right">提取图像中的直线和圆</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图文版 | &lt;a href=&quot;/2017/10/10/Python-OpenCV%E6%95%99%E7%A8%8B%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89/&quot;&gt;简洁版&lt;/a&gt;
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程9：图像混合</title>
    <link href="http://ex2tron.coding.me/2017/12/10/Python-OpenCV%E6%95%99%E7%A8%8B9%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/"/>
    <id>http://ex2tron.coding.me/2017/12/10/Python-OpenCV教程9：图像混合/</id>
    <published>2017-12-10T06:13:10.000Z</published>
    <updated>2018-01-05T04:39:02.734Z</updated>
    
    <content type="html"><![CDATA[<p>学习图片间的数学运算，图像混合。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>图片间的数学运算，如相加、按位运算等</li>
<li>OpenCV函数：cv2.add(), cv2.addWeighted(), cv2.bitwise_and()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>首先，恭喜你已经完成了入门篇的学习噢，接下来我们学习一些OpenCV的基础内容，加油(ง •_•)ง</p>
<h3 id="图片相加"><a href="#图片相加" class="headerlink" title="图片相加"></a>图片相加</h3><p>要叠加两张图片，可以用<code>cv2.add()</code>函数，相加两幅图片的形状（高度/宽度/通道数）必须相同。numpy中可以直接用<code>res = img + img1</code>相加，但这两者的结果并不相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = np.uint8([<span class="number">250</span>])</div><div class="line">y = np.uint8([<span class="number">10</span>])</div><div class="line">print(cv2.add(x, y))  <span class="comment"># 250+10 = 260 =&gt; 255</span></div><div class="line">print(x + y)  <span class="comment"># 250+10 = 260 % 256 = 4</span></div></pre></td></tr></table></figure>
<p>如果是二值化图片（只有0和255），两者结果是一样的（用numpy的方式更简便一些）。</p>
<h3 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h3><p>图像混合<code>cv2.addWeighted()</code>也是一种图片相加的操作，只不过两幅图片的权重不一样，γ相当于一个修正值：</p>
<p><code>dst = α*img1 + β*img2 + γ</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">img1 = cv2.imread(<span class="string">'lena_small.jpg'</span>)</div><div class="line">img2 = cv2.imread(<span class="string">'opencv-logo-white.png'</span>)</div><div class="line">res = cv2.addWeighted(img1, <span class="number">0.6</span>, img2, <span class="number">0.4</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_image_blending_6_4.jpg" alt="图像混合"></p>
<blockquote>
<p>经验之谈：α和β都等于1时，就相当于图片相加</p>
</blockquote>
<h3 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h3><p>按位操作包括按位与/或/非/异或操作，有什么用途呢？比如说我们要实现下图的效果：</p>
<p><img src="http://pic.ex2tron.top/cv2_bitwise_operations_demo.jpg" alt=""></p>
<p>如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作。首先来了解一下<a href="https://baike.baidu.com/item/%E6%8E%A9%E8%86%9C/8544392?fr=aladdin" target="_blank" rel="external">掩膜</a>（mask）的概念：掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡，看下图就一目了然了：</p>
<p><img src="http://pic.ex2tron.top/cv2_understand_mask.jpg" alt="掩膜概念"></p>
<p>所以我们的思路就是把原图中要放logo的区域抠出来，再把logo放进去就行了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">img1 = cv2.imread(<span class="string">'lena.jpg'</span>)</div><div class="line">img2 = cv2.imread(<span class="string">'opencv-logo-white.png'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 把logo放在左上角，所以我们只关心这一块区域</span></div><div class="line">rows, cols = img2.shape[:<span class="number">2</span>]</div><div class="line">roi = img1[:rows, :cols]</div><div class="line"></div><div class="line"><span class="comment"># 创建掩膜</span></div><div class="line">img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</div><div class="line">ret, mask = cv2.threshold(img2gray, <span class="number">10</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</div><div class="line">mask_inv = cv2.bitwise_not(mask)</div><div class="line"></div><div class="line"><span class="comment"># 保留除logo外的背景</span></div><div class="line">img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)</div><div class="line">dst = cv2.add(img1_bg, img2)  <span class="comment"># 进行融合</span></div><div class="line">img1[:rows, :cols] = dst  <span class="comment"># 融合后放在原图上</span></div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>cv2.add()用来叠加两幅图片，cv2.addWeighted()也是叠加两幅图片，但两幅图片的权重不一样</li>
<li>cv2.bitwise_and(), cv2.bitwise_not(), cv2.bitwise_or(), cv2.bitwise_xor()分别执行按位与/或/非/异或运算。掩膜就是用来对图片进行全局或局部的遮挡</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/9.%20%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88" target="_blank" rel="external">本节源码</a></li>
<li><a href="https://baike.baidu.com/item/%E6%8E%A9%E8%86%9C/8544392?fr=aladdin" target="_blank" rel="external">掩膜</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html" target="_blank" rel="external">Arithmetic Operations on Images</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习图片间的数学运算，图像混合。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="图像混合" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇6：亮度与对比度</title>
    <link href="http://ex2tron.coding.me/2017/12/10/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%876%EF%BC%9A%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6/"/>
    <id>http://ex2tron.coding.me/2017/12/10/Python-OpenCV教程番外篇6：亮度与对比度/</id>
    <published>2017-12-10T06:05:10.000Z</published>
    <updated>2018-01-19T05:35:33.827Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何调整图片的亮度和对比度。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="亮度与对比度"><a href="#亮度与对比度" class="headerlink" title="亮度与对比度"></a>亮度与对比度</h2><p>亮度调整是将图像像素的强度整体变大/变小，对比度调整指的是图像暗处的像素强度变低，亮出的变高，从而拓宽某个区域内的显示精度。</p>
<p>OpenCV中亮度和对比度应用这个公式来计算：<code>g(x) = αf(x) + β</code>，其中：α(&gt;0)、β常称为增益与偏置值，分别控制图片的对比度和亮度。</p>
<blockquote>
<p>经验之谈：此处对α/β控制对比度和亮度有争议，具体请参考：<a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="external">OpenCV关于对比度和亮度的误解</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</div><div class="line"><span class="comment"># 此处需注意，请参考后面的解释</span></div><div class="line">res = np.uint8(np.clip((<span class="number">1.5</span> * img + <span class="number">10</span>), <span class="number">0</span>, <span class="number">255</span>))</div><div class="line">tmp = np.hstack((img, res))  <span class="comment"># 两张图片横向合并（便于对比显示）</span></div><div class="line"></div><div class="line">cv2.imshow(<span class="string">'image'</span>, tmp)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>还记得图像混合那一节中numpy对数据溢出的取模处理吗？<code>250+10 = 260 =&gt; 260%256=4</code>，它并不适用于我们的图像处理，所以用<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="external">np.clip()</a>函数将数据限定：<code>a&lt;0 =&gt; a=0, a&gt;255 =&gt; a=255</code></p>
<p><img src="http://pic.ex2tron.top/cv2_contrast_brightness.jpg" alt="亮度与对比度调整"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>创建两个滑动条分别调整对比度和亮度（对比度范围：0~0.3，亮度：0~100）。提示：因为滑动条没有小数，所以可以设置为0~300，然后乘以0.01</p>
</li>
<li><p>亮度/对比度用C++实现也很有趣，推荐阅读：<a href="http://blog.csdn.net/u013139259/article/details/52145377" target="_blank" rel="external">OpenCV改变图像亮度和对比度以及优化</a></p>
</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇6.%20亮度与对比度" target="_blank" rel="external">本节源码</a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="external">numpy.clip()</a></li>
<li><a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="external">OpenCV关于对比度和亮度的误解</a></li>
<li><a href="http://blog.csdn.net/u013139259/article/details/52145377" target="_blank" rel="external">OpenCV改变图像亮度和对比度以及优化</a></li>
<li><a href="https://docs.opencv.org/3.1.0/d3/d63/classcv_1_1Mat.html#a3f356665bb0ca452e7d7723ccac9a810" target="_blank" rel="external">Mat::convertTo</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何调整图片的亮度和对比度。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="亮度" scheme="http://ex2tron.coding.me/tags/%E4%BA%AE%E5%BA%A6/"/>
    
      <category term="对比度" scheme="http://ex2tron.coding.me/tags/%E5%AF%B9%E6%AF%94%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇5：鼠标绘图</title>
    <link href="http://ex2tron.coding.me/2017/12/09/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE/"/>
    <id>http://ex2tron.coding.me/2017/12/09/Python-OpenCV教程番外篇5：鼠标绘图/</id>
    <published>2017-12-09T09:28:34.000Z</published>
    <updated>2018-01-19T05:35:16.056Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何用鼠标实时绘图。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>捕获鼠标事件</li>
<li>OpenCV函数：cv2.setMouseCallback()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="知道鼠标在哪儿"><a href="#知道鼠标在哪儿" class="headerlink" title="知道鼠标在哪儿"></a>知道鼠标在哪儿</h3><p>OpenCV中，我们需要创建一个鼠标的回调函数来知道鼠标当前的位置，当前的事件如左键按下、左键释放或是右键单击等等，然后执行相应的功能。</p>
<p>使用<code>cv2.setMouseCallback()</code>来创建鼠标的回调函数，比如我们在左键单击的时候，打印出当前鼠标的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 鼠标的回调函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mouse_event</span><span class="params">(event, x, y, flags, param)</span>:</span></div><div class="line">    <span class="comment"># 通过event判断具体是什么事件，这里是左键按下</span></div><div class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</div><div class="line">        print((x, y))</div><div class="line"></div><div class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</div><div class="line">cv2.namedWindow(<span class="string">'image'</span>)</div><div class="line"><span class="comment"># 定义鼠标的回调函数</span></div><div class="line">cv2.setMouseCallback(<span class="string">'image'</span>, mouse_event)</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</div><div class="line">    cv2.imshow(<span class="string">'image'</span>, img)</div><div class="line">    <span class="comment"># 按下ESC键退出</span></div><div class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">20</span>) == <span class="number">27</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>上面的代码先定义鼠标的回调函数<code>mouse_event()</code>，然后在回调函数中判断是否是左键单击事件<code>EVENT_LBUTTONDOWN</code>，是的话就打印出坐标。需要注意的是，回调函数的参数格式是固定的，不要随意更改。</p>
<p>那除了左键单击之外，还有哪些事件呢？可以用下面的代码打印出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取所有的事件</span></div><div class="line">events = [i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> <span class="string">'EVENT'</span> <span class="keyword">in</span> i]</div><div class="line">print(events)</div></pre></td></tr></table></figure>
<h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><p>现在我们来实现一个综合的例子，这个实例会帮助你理解图像交互的一些思想：</p>
<p>在图像上用鼠标画图，可以画圆或矩形，按m键在两种模式下切换。左键按下时开始画图，移动到哪儿画到哪儿，左键释放时结束画图。听上去很复杂，是吗？一步步分析下：</p>
<ul>
<li>用鼠标画图：需要定义鼠标的回调函数mouse_event</li>
<li>画圆或矩形：需要定义一个画图的模式mode</li>
<li>左键单击、移动、释放：需要捕获三个不同的事件</li>
<li>开始画图，结束画图：需要定义一个画图的标记位drawing</li>
</ul>
<p>好，开始coding吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">drawing = <span class="keyword">False</span>  <span class="comment"># 是否开始画图</span></div><div class="line">mode = <span class="keyword">True</span>  <span class="comment"># True：画矩形，False：画圆</span></div><div class="line">start = (<span class="number">-1</span>, <span class="number">-1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mouse_event</span><span class="params">(event, x, y, flags, param)</span>:</span></div><div class="line">    <span class="keyword">global</span> start, drawing, mode</div><div class="line"></div><div class="line">    <span class="comment"># 左键按下：开始画图</span></div><div class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</div><div class="line">        drawing = <span class="keyword">True</span></div><div class="line">        start = (x, y)</div><div class="line">    <span class="comment"># 鼠标移动，画图</span></div><div class="line">    <span class="keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:</div><div class="line">        <span class="keyword">if</span> drawing:</div><div class="line">            <span class="keyword">if</span> mode:</div><div class="line">                cv2.rectangle(img, start, (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>)</div><div class="line">    <span class="comment"># 左键释放：结束画图</span></div><div class="line">    <span class="keyword">elif</span> event == cv2.EVENT_LBUTTONUP:</div><div class="line">        drawing = <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> mode:</div><div class="line">            cv2.rectangle(img, start, (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>)</div><div class="line"></div><div class="line"></div><div class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</div><div class="line">cv2.namedWindow(<span class="string">'image'</span>)</div><div class="line">cv2.setMouseCallback(<span class="string">'image'</span>, mouse_event)</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</div><div class="line">    cv2.imshow(<span class="string">'image'</span>, img)</div><div class="line">    <span class="comment"># 按下m切换模式</span></div><div class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'m'</span>):</div><div class="line">        mode = <span class="keyword">not</span> mode</div><div class="line">    <span class="keyword">elif</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>效果应该如下图所示：</p>
<p><img src="http://pic.ex2tron.top/cv2_mouse_drawing_rectangle_circle.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>要用鼠标绘图，需要用cv2.setMouseCallback()定义回调函数，然后在回调函数中根据不同的event事件，执行不同的功能</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>（选做）实现用鼠标画矩形，跟实例差不多，但只实时画一个，类似下面动图：</li>
</ol>
<p><img src="http://pic.ex2tron.top/cv2_live_draw_rectangle.gif" alt="实时画一个矩形"></p>
<ol>
<li>（选做）做一个在白色面板上绘图的简单程序，可用滑动条调整颜色和笔刷大小。</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇5.%20鼠标绘图" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_mouse_handling/py_mouse_handling.html" target="_blank" rel="external">Mouse as a Paint-Brush</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何用鼠标实时绘图。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="绘图" scheme="http://ex2tron.coding.me/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程8：绘图功能</title>
    <link href="http://ex2tron.coding.me/2017/12/09/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/"/>
    <id>http://ex2tron.coding.me/2017/12/09/Python-OpenCV教程8：绘图功能/</id>
    <published>2017-12-09T03:29:48.000Z</published>
    <updated>2018-01-22T08:19:33.291Z</updated>
    
    <content type="html"><![CDATA[<p>学习画线、圆和矩形等多种几何形状，给图片添加文字。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>绘制各种几何形状、添加文字</li>
<li>OpenCV函数：cv2.line(), cv2.circle(), cv2.rectangle(), cv2.ellipse(), cv2.putText()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>绘制形状的函数有一些共同的参数，提前在此说明一下：</p>
<ul>
<li>img：要绘制形状的图片</li>
<li>color：绘制的颜色，绘制彩色就传入BGR的一组值，如(255,0,0)；灰度图，传入一个灰度值就行</li>
<li>thickness：线宽，默认为1；对于矩形/圆之类的封闭形状而言，传入-1表示填充形状</li>
</ul>
<blockquote>
<p>模块导入和显示图片的通用代码，相信你已经很熟悉了，为节约篇幅，后面我会省略掉噢：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">cv2.imshow(<span class="string">'img'</span>, img)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_drawing_functions.jpg" alt="绘制各种几何形状"></p>
<p>上图就是本教程绘制的最终效果，下面一步步来看：</p>
<h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>画线只需知道起点和终点的坐标就行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一副黑色的图片</span></div><div class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</div><div class="line"><span class="comment"># 画一条线宽为5的蓝色直线，参数2：起点，参数3：终点</span></div><div class="line">cv2.line(img, (<span class="number">0</span>, <span class="number">0</span>), (<span class="number">512</span>, <span class="number">512</span>), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：所有绘图函数均会直接影响原图片，这点要注意</p>
</blockquote>
<h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>画矩形需要知道左上角和右下角的坐标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 画一个绿色边框的矩形，参数2：左上角坐标，参数3：右下角坐标</span></div><div class="line">cv2.rectangle(img, (<span class="number">384</span>, <span class="number">0</span>), (<span class="number">510</span>, <span class="number">128</span>), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</div></pre></td></tr></table></figure>
<h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p>画圆需要指定圆心和半径，注意下面的例子中线宽=-1代表填充：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 画一个填充红色的圆，参数2：圆心坐标，参数3：半径</span></div><div class="line">cv2.circle(img, (<span class="number">447</span>, <span class="number">63</span>), <span class="number">63</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>画椭圆需要的参数比较多，请对照后面的代码理解这几个参数：</p>
<ul>
<li>参数2：椭圆中心(x,y)</li>
<li>参数3：x/y轴的长度</li>
<li>参数4：angle–椭圆的旋转角度</li>
<li>参数5：startAngle–椭圆的起始角度</li>
<li>参数6：endAngle–椭圆的结束角度</li>
</ul>
<blockquote>
<p>经验之谈：这里的角度是以顺时针方向计算的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在图中心画一个填充的半圆</span></div><div class="line">cv2.ellipse(img, (<span class="number">256</span>, <span class="number">256</span>), (<span class="number">100</span>, <span class="number">50</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h3 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h3><p>画多边形需要指定一系列多边形的顶点坐标，相当于从第一个点到第二个点画直线，再从第二个点到第三个点画直线….</p>
<p>OpenCV中需要先将多边形的顶点坐标需要变成<code>顶点数×1×2</code>维的矩阵，再来绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义四个顶点坐标</span></div><div class="line">pts = np.array([[<span class="number">10</span>, <span class="number">5</span>],  [<span class="number">50</span>, <span class="number">10</span>], [<span class="number">70</span>, <span class="number">20</span>], [<span class="number">20</span>, <span class="number">30</span>]], np.int32)</div><div class="line"><span class="comment"># 顶点个数：4，矩阵变成4*1*2维</span></div><div class="line">pts = pts.reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</div><div class="line">cv2.polylines(img, [pts], <span class="keyword">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</div></pre></td></tr></table></figure>
<p><code>cv2.polylines()</code>的参数3如果是False的话，多边形就不闭合。</p>
<blockquote>
<p>经验之谈：如果需要绘制多条直线，使用cv2.polylines()要比cv2.line()高效很多，例如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用cv2.polylines()画多条直线</span></div><div class="line">line1 = np.array([[<span class="number">100</span>, <span class="number">20</span>],  [<span class="number">300</span>, <span class="number">20</span>]], np.int32).reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</div><div class="line">line2 = np.array([[<span class="number">100</span>, <span class="number">60</span>],  [<span class="number">300</span>, <span class="number">60</span>]], np.int32).reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</div><div class="line">line3 = np.array([[<span class="number">100</span>, <span class="number">100</span>],  [<span class="number">300</span>, <span class="number">100</span>]], np.int32).reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</div><div class="line">cv2.polylines(img, [line1, line2, line3], <span class="keyword">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</div></pre></td></tr></table></figure>
<h3 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h3><p>使用<code>cv2.putText()</code>添加文字，它的参数也比较多，同样请对照后面的代码理解这几个参数：</p>
<ul>
<li>参数2：要添加的文本</li>
<li>参数3：文字的起始坐标（左下角为起点）</li>
<li>参数4：字体</li>
<li>参数5：文字大小（缩放比例）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加文字</span></div><div class="line">font = cv2.FONT_HERSHEY_SIMPLEX</div><div class="line">cv2.putText(img, <span class="string">'ex2tron'</span>, (<span class="number">10</span>, <span class="number">500</span>), font,</div><div class="line">            <span class="number">4</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>, lineType=cv2.LINE_AA)</div></pre></td></tr></table></figure>
<p>这里有个线型lineType参数，LINE_AA表示抗锯齿线型，具体可见<a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="external">LineTypes</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>cv2.line()画直线，cv2.circle()画圆，cv2.rectangle()画矩形，cv2.ellipse()画椭圆，cv2.polylines()画多边形，cv2.putText()添加文字</li>
<li>画多条直线时，cv2.polylines()要比cv2.line()高效很多</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>你能用已学的绘图功能画出OpenCV的logo吗？(提示：椭圆和圆)</li>
</ol>
<p><img src="http://pic.ex2tron.top/cv2_draw_opencv_logo.jpg" alt="OpenCV logo"></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/8.%20%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD" target="_blank" rel="external">本节源码</a></li>
<li><a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="external">LineTypes</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_drawing_functions/py_drawing_functions.html" target="_blank" rel="external">Drawing Functions in OpenCV</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习画线、圆和矩形等多种几何形状，给图片添加文字。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="绘图" scheme="http://ex2tron.coding.me/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程7：图像几何变换</title>
    <link href="http://ex2tron.coding.me/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
    <id>http://ex2tron.coding.me/2017/12/08/Python-OpenCV教程7：图像几何变换/</id>
    <published>2017-12-08T06:36:53.000Z</published>
    <updated>2018-01-29T05:19:37.033Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何旋转、平移和缩放图片，了解仿射/透视变换。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>实现旋转、平移和缩放图片</li>
<li>了解仿射变换和透视变换</li>
<li>OpenCV函数：cv2.resize(), cv2.warpAffine(), cv2.warpPerspective()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h3><p>缩放就是调整图片的大小，使用<code>cv2.resize()</code>函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'drawing.jpg'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 按照指定的宽度、高度缩放图片</span></div><div class="line">res = cv2.resize(img, (<span class="number">132</span>, <span class="number">150</span>))</div><div class="line"><span class="comment"># 按照比例缩放，如x,y轴均放大一倍</span></div><div class="line">res2 = cv2.resize(img, <span class="keyword">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_LINEAR)</div><div class="line"></div><div class="line">cv2.imshow(<span class="string">'shrink'</span>, res), cv2.imshow(<span class="string">'zoom'</span>, res2)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>我们也可以指定缩放方法<code>interpolation</code>，更专业点叫插值方法，默认是<code>INTER_LINEAR</code>，全部可以参考：<a href="https://docs.opencv.org/3.3.1/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121" target="_blank" rel="external">InterpolationFlags</a></p>
<h3 id="平移图片"><a href="#平移图片" class="headerlink" title="平移图片"></a>平移图片</h3><p>这里涉及到<a href="https://baike.baidu.com/item/仿射变换" target="_blank" rel="external">仿射变换</a>的概念，大家不用知道它的意思，只需要了解下面三点：</p>
<ul>
<li>仿射变换后，原图中平行的线依然平行</li>
<li>用<code>cv2.warpAffine()</code>实现仿射变换</li>
<li>仿射变换需要定义一个2*3维的变换矩阵</li>
</ul>
<p>要平移图片，我们需要定义下面这样一个矩阵，tx,ty是向x和y方向平移的距离：</p>
<p>$$<br> M = \left[<br> \begin{matrix}<br>   1 &amp; 0 &amp; tx \newline<br>   0 &amp; 1 &amp; ty<br>  \end{matrix}<br>  \right] \tag{3}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 平移图片</span></div><div class="line">rows, cols = img.shape[:<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="comment"># 定义平移矩阵，需要是numpy的float32类型</span></div><div class="line"><span class="comment"># x轴平移100，y轴平移50</span></div><div class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>]])</div><div class="line"><span class="comment"># 用仿射变换实现平移</span></div><div class="line">dst = cv2.warpAffine(img, M, (cols, rows))</div><div class="line"></div><div class="line">cv2.imshow(<span class="string">'shift'</span>, dst)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>再次强调一下：图片的高度（y方向）是rows，宽度（x方向）是cols，请勿混淆</p>
</blockquote>
<p><img src="http://pic.ex2tron.top/cv2_translation_100_50.jpg" alt="平移图片"></p>
<h3 id="旋转图片"><a href="#旋转图片" class="headerlink" title="旋转图片"></a>旋转图片</h3><p>旋转同平移一样，也需要定义一个变换矩阵。OpenCV直接提供了<code>cv2.getRotationMatrix2D()</code>函数用来生成这个矩阵，对这个矩阵的形式感兴趣的童鞋可以去<a href="#引用">引用</a>查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 45°旋转图片并缩小一半</span></div><div class="line">M = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), <span class="number">45</span>, <span class="number">0.5</span>)</div><div class="line">dst = cv2.warpAffine(img, M, (cols, rows))</div><div class="line"></div><div class="line">cv2.imshow(<span class="string">'rotation'</span>, dst)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><code>cv2.getRotationMatrix2D()</code>函数有三个参数：</p>
<ul>
<li>参数1：图片的旋转中心</li>
<li>参数2：旋转角度</li>
<li>参数3：缩放比例，该例中0.5表示我们缩小一半</li>
</ul>
<p><img src="http://pic.ex2tron.top/cv2_rotation_45_degree.jpg" alt="旋转45°并缩放"></p>
<h3 id="翻转图片"><a href="#翻转图片" class="headerlink" title="翻转图片"></a>翻转图片</h3><p>如果我们镜像翻转图片，可以用<code>cv2.flip()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dst = cv2.flip(img, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>其中参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</p>
<h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p>除了平移和旋转，如何实现任意的图像变换呢？同样的道理，我们需要一个变换矩阵。</p>
<p>要生成这个变换矩阵，需要定义变换前后的三个点，比如说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 变换前的三个点</span></div><div class="line">pts1 = np.float32([[<span class="number">50</span>, <span class="number">65</span>], [<span class="number">150</span>, <span class="number">65</span>], [<span class="number">210</span>, <span class="number">210</span>]])</div><div class="line"><span class="comment"># 变换后的三个点</span></div><div class="line">pts2 = np.float32([[<span class="number">50</span>, <span class="number">100</span>], [<span class="number">150</span>, <span class="number">65</span>], [<span class="number">100</span>, <span class="number">250</span>]])</div><div class="line"></div><div class="line"><span class="comment"># 生成变换矩阵</span></div><div class="line">M = cv2.getAffineTransform(pts1, pts2)</div><div class="line">dst = cv2.warpAffine(img, M, (cols, rows))</div><div class="line"></div><div class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img), plt.title(<span class="string">'input'</span>)</div><div class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst), plt.title(<span class="string">'output'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>变换前后的三个点我已经标记出来了。用<code>cv2.getAffineTransform()</code>生成变换矩阵，接下来再用<code>cv2.warpAffine()</code>实现变换。大家可以修改下变换后的三个点坐标看看效果：</p>
<p><img src="http://pic.ex2tron.top/cv2_affine_transformation_drawing.jpg" alt="仿射变换前后对比图"></p>
<h3 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h3><p><a href="https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2" target="_blank" rel="external">透视变换</a>绝对是一项很酷的功能。我们经常会用手机去拍身份证和文件，无论你怎么拍，貌似都拍不正或者有边框。如果你使用过手机上面一些扫描类软件，比如”<a href="https://baike.baidu.com/item/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B" target="_blank" rel="external">扫描全能王</a>“，”<a href="https://baike.baidu.com/item/Office%20Lens" target="_blank" rel="external">Office Lens</a>“，它们能很好地矫正图片。这些软件就是应用透视变换实现的，跟仿射变换一样，我们不用知道它的具体原理。</p>
<p>透视变换后，原图中的直线依旧是直线。如下图，我们实现这个功能：</p>
<p><img src="http://pic.ex2tron.top/cv2_perspective_transformations_inm.jpg" alt="矫正一鸣的卡片"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'card.jpg'</span>)</div><div class="line">rows, cols = img.shape[:<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="comment"># 原图中卡片的四个角点</span></div><div class="line">pts1 = np.float32([[<span class="number">148</span>, <span class="number">80</span>], [<span class="number">437</span>, <span class="number">114</span>], [<span class="number">94</span>, <span class="number">247</span>], [<span class="number">423</span>, <span class="number">288</span>]])</div><div class="line"><span class="comment"># 变换后分别在左上、右上、左下、右下四个点</span></div><div class="line">pts2 = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">320</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">178</span>], [<span class="number">320</span>, <span class="number">178</span>]])</div><div class="line"></div><div class="line"><span class="comment"># 生成透视变换矩阵</span></div><div class="line">M = cv2.getPerspectiveTransform(pts1, pts2)</div><div class="line"><span class="comment"># 进行透视变换</span></div><div class="line">dst = cv2.warpPerspective(img, M, (<span class="number">320</span>, <span class="number">178</span>))</div><div class="line"></div><div class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img[:, :, ::<span class="number">-1</span>]), plt.title(<span class="string">'input'</span>)</div><div class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst[:, :, ::<span class="number">-1</span>]), plt.title(<span class="string">'output'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>透视变换需要前后四个点来生成3*3的变换矩阵，用<code>cv2.getPerspectiveTransform()</code>实现。然后再用<code>cv2.warpPerspective()</code>进行变换。代码中有个<code>img[:, :, ::-1]</code>还记得吗？忘记的话，请看<a href="#练习">练习</a>。</p>
<p>是不是很简单？当然，我们后面学习了特征提取之后，就可以自动识别角点了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>cv2.resize()缩放图片，可以按指定大小缩放，亦可以按比例缩放</li>
<li>平移和旋转是靠cv2.warpAffine()仿射变换实现的，也可以自己定义变换前后的点，实现任意变换</li>
<li>透视变换常用于矫正图片，是一个很酷的功能</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>透视变换代码中有个<code>img[:, :, ::-1]</code>，还记得吗？请复习：<a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9AMatplotlib%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/">Matplotlib显示图像</a> </li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/7.%20%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_geometric_transformations/py_geometric_transformations.html" target="_blank" rel="external">Geometric Transformations of Images</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何旋转、平移和缩放图片，了解仿射/透视变换。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="几何变换" scheme="http://ex2tron.coding.me/tags/%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇4：Otsu阈值法</title>
    <link href="http://ex2tron.coding.me/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/"/>
    <id>http://ex2tron.coding.me/2017/12/08/Python-OpenCV教程番外篇4：Otsu阈值法/</id>
    <published>2017-12-08T04:48:05.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p>大部分图像处理任务都需要先二值化操作，所以阈值的选取很关键，Otsu阈值法会自动计算阈值。<a id="more"></a></p>
<p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="external">Otsu阈值法</a>（日本人提出的，也可以叫大津算法）会自动计算阈值，它适用于双峰图片，啥意思呢？</p>
<h2 id="什么是双峰图片？"><a href="#什么是双峰图片？" class="headerlink" title="什么是双峰图片？"></a>什么是双峰图片？</h2><p>双峰图片就是指图片的灰度直方图上有两个峰值，直方图就是每个值（0~255）的像素点个数统计，如黑色点0有多少个等等，后面会详细介绍。</p>
<p><img src="http://pic.ex2tron.top/cv2_bimodal_image_two_peaks.jpg" alt=""></p>
<p>Otsu算法假设这副图片由前景色和背景色组成，通过统计学方法（最大类间方差）选取一个阈值，将前景和背景尽可能分开，算法详解：<a href="https://en.wikipedia.org/wiki/Otsu%27s_method" target="_blank" rel="external">Otsu’s Method(wikipedia)</a></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面这段代码对比了使用固定阈值和Otsu阈值后的不同结果：</p>
<p>另外，对含噪点的图像，先进行滤波操作效果会更好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'noisy.jpg'</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 固定阈值法</span></div><div class="line">ret1, th1 = cv2.threshold(img, <span class="number">100</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</div><div class="line"></div><div class="line"><span class="comment"># Otsu阈值法</span></div><div class="line">ret2, th2 = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</div><div class="line"></div><div class="line"><span class="comment"># 先进行高斯滤波，再使用Otsu阈值法</span></div><div class="line">blur = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</div><div class="line">ret3, th3 = cv2.threshold(blur, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</div></pre></td></tr></table></figure>
<p>下面我们用Matplotlib把原图、直方图和阈值图都显示出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">images = [img, <span class="number">0</span>, th1, img, <span class="number">0</span>, th2, blur, <span class="number">0</span>, th3]</div><div class="line">titles = [<span class="string">'Original'</span>, <span class="string">'Histogram'</span>, <span class="string">'Global(v=100)'</span>,</div><div class="line">          <span class="string">'Original'</span>, <span class="string">'Histogram'</span>, <span class="string">"Otsu's"</span>,</div><div class="line">          <span class="string">'Gaussian filtered Image'</span>, <span class="string">'Histogram'</span>, <span class="string">"Otsu's"</span>]</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">    <span class="comment"># 绘制原图</span></div><div class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">1</span>)</div><div class="line">    plt.imshow(images[i * <span class="number">3</span>], <span class="string">'gray'</span>)</div><div class="line">    plt.title(titles[i * <span class="number">3</span>], fontsize=<span class="number">8</span>)</div><div class="line">    plt.xticks([]), plt.yticks([])</div><div class="line"></div><div class="line">    <span class="comment"># 绘制直方图plt.hist，ravel函数将数组降成一维</span></div><div class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">2</span>)</div><div class="line">    plt.hist(images[i * <span class="number">3</span>].ravel(), <span class="number">256</span>)</div><div class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">1</span>], fontsize=<span class="number">8</span>)</div><div class="line">    plt.xticks([]), plt.yticks([])</div><div class="line"></div><div class="line">    <span class="comment"># 绘制阈值图</span></div><div class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">3</span>)</div><div class="line">    plt.imshow(images[i * <span class="number">3</span> + <span class="number">2</span>], <span class="string">'gray'</span>)</div><div class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">2</span>], fontsize=<span class="number">8</span>)</div><div class="line">    plt.xticks([]), plt.yticks([])</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_otsu_vs_simple_thresholding.jpg" alt="固定阈值 vs Otsu阈值"></p>
<p>可以看到，Otsu阈值明显由于固定阈值，省去了不断尝试阈值判断效果好坏的过程。其中，绘制直方图时，使用了numpy中的<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="external">ravel()</a>函数，它会将原矩阵压缩成一维数组，便于画直方图。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇4.%20Otsu阈值法" target="_blank" rel="external">本节源码</a></li>
<li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="external">numpy.ravel</a></li>
<li><a href="https://en.wikipedia.org/wiki/Otsu%27s_method" target="_blank" rel="external">Otsu’s Method</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="external">Image Thresholding</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分图像处理任务都需要先二值化操作，所以阈值的选取很关键，Otsu阈值法会自动计算阈值。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="阈值" scheme="http://ex2tron.coding.me/tags/%E9%98%88%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程6：阈值分割</title>
    <link href="http://ex2tron.coding.me/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
    <id>http://ex2tron.coding.me/2017/12/07/Python-OpenCV教程6：阈值分割/</id>
    <published>2017-12-07T13:14:44.000Z</published>
    <updated>2018-01-05T04:34:30.800Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用不同的阈值方法”二值化”图像。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>使用固定阈值、自适应阈值和Otsu阈值法”二值化”图像</li>
<li>OpenCV函数：cv2.threshold(), cv2.adaptiveThreshold()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h3><p>固定阈值分割很直接，一句话说就是像素点值大于阈值一个值，小于阈值是另外一个值。</p>
<p><img src="http://pic.ex2tron.top/cv2_threshold_binary_demo.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 灰度图读入</span></div><div class="line">img = cv2.imread(<span class="string">'gradient.jpg'</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 阈值分割</span></div><div class="line">ret, th = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</div><div class="line">cv2.imshow(<span class="string">'thresh'</span>, th)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p>
<ul>
<li>参数1：要处理的原图，<strong>一般是灰度图</strong></li>
<li>参数2：设定的阈值</li>
<li>参数3：最大阈值，一般为255</li>
<li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/3.3.1/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="external">ThresholdTypes</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 应用5种不同的阈值方法</span></div><div class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</div><div class="line">ret, th2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</div><div class="line">ret, th3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC)</div><div class="line">ret, th4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO)</div><div class="line">ret, th5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)</div><div class="line"></div><div class="line">titles = [<span class="string">'Original'</span>, <span class="string">'BINARY'</span>, <span class="string">'BINARY_INV'</span>, <span class="string">'TRUNC'</span>, <span class="string">'TOZERO'</span>, <span class="string">'TOZERO_INV'</span>]</div><div class="line">images = [img, th1, th2, th3, th4, th5]</div><div class="line"></div><div class="line"><span class="comment"># 使用Matplotlib显示</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</div><div class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</div><div class="line">    plt.imshow(images[i], <span class="string">'gray'</span>)</div><div class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</div><div class="line">    plt.xticks([]), plt.yticks([])  <span class="comment"># 隐藏坐标轴</span></div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_different_threshold_demo.jpg" alt="5种不同的阈值方式结果"></p>
<p>结合下表，就很容易理解这5种方式了：</p>
<blockquote>
<p>经验之谈：很多人误以为阈值分割就是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%80%BC%E5%8C%96" target="_blank" rel="external">二值化</a>。从上图中可以发现，两者并不等同，阈值分割结果是两种值，而不是两个值，所以教程开头我把二值化加了引号</p>
</blockquote>
<p><img src="http://pic.ex2tron.top/cv2_different_thresholds_theory.jpg" alt=""></p>
<h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<em>它并不适用于明暗分布不均的图片</em>。<code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。它有5个参数，其实很好理解，先看下效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 自适应阈值对比固定阈值</span></div><div class="line">img = cv2.imread(<span class="string">'sudoku.jpg'</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 固定阈值</span></div><div class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</div><div class="line"><span class="comment"># 自适应阈值</span></div><div class="line">th2 = cv2.adaptiveThreshold(</div><div class="line">    img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">4</span>)</div><div class="line">th3 = cv2.adaptiveThreshold(</div><div class="line">    img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">17</span>, <span class="number">6</span>)</div><div class="line"></div><div class="line">titles = [<span class="string">'Original'</span>, <span class="string">'Global(v = 127)'</span>, <span class="string">'Adaptive Mean'</span>, <span class="string">'Adaptive Gaussian'</span>]</div><div class="line">images = [img, th1, th2, th3]</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">'gray'</span>)</div><div class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</div><div class="line">    plt.xticks([]), plt.yticks([])</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_adaptive_vs_global_thresholding.jpg" alt="自适应阈值对比固定阈值"></p>
<ul>
<li>参数1：要处理的原图</li>
<li>参数2：最大阈值，一般为255</li>
<li>参数3：小区域阈值的计算方式<ul>
<li>ADAPTIVE_THRESH_MEAN_C：小区域内取均值</li>
<li>ADAPTIVE_THRESH_GAUSSIAN_C：小区域内加权求和，权重是个高斯核</li>
</ul>
</li>
<li>参数4：阈值方式（跟前面讲的那5种相同）</li>
<li>参数5：小区域的面积，如11就是11*11的小块</li>
<li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li>
</ul>
<p>如果你没看懂上面的参数也不要紧，暂时会用就行，当然我建议你调整下参数看看不同的结果。</p>
<h3 id="Otsu阈值"><a href="#Otsu阈值" class="headerlink" title="Otsu阈值"></a>Otsu阈值</h3><p>在前面固定阈值中，我们是随便选了一个阈值如127，那如何知道我们选的这个阈值效果好不好呢？答案是：不断尝试，所以这种方法在很多文献中都被称为经验阈值。<a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="external">Otsu阈值法</a>就提供了一种自动高效的二值化方法，不过我们直方图还没学，这里暂时略过。</p>
<p>好吧，我知道我激起了你的兴趣，~ o(<em>￣▽￣</em>)o，有能力的童鞋可以看下<a href="#练习">练习题</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>cv2.threshold()用来进行固定阈值分割。固定阈值不适用于光线不均匀的图片，所以用cv2.adaptiveThreshold()进行自适应阈值分割</li>
<li>二值化跟阈值分割并不等同。针对不同的图片，可以采用不同的阈值方法</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>Otsu阈值是一种高效的二值化算法，请尝试阅读<a href="/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/">番外篇：Otsu阈值法</a></li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/6.%20%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="external">Image Thresholding</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用不同的阈值方法”二值化”图像。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="阈值" scheme="http://ex2tron.coding.me/tags/%E9%98%88%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程5：颜色空间转换</title>
    <link href="http://ex2tron.coding.me/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
    <id>http://ex2tron.coding.me/2017/12/07/Python-OpenCV教程5：颜色空间转换/</id>
    <published>2017-12-07T07:21:19.000Z</published>
    <updated>2017-12-22T03:53:57.741Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何进行图片的颜色空间转换，视频中追踪特定颜色物体。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>颜色空间转换，如BGR↔Gray，BGR↔HSV等</li>
<li>追踪视频中特定颜色的物体</li>
<li>OpenCV函数：cv2.cvtColor(),cv2.inRange()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</div><div class="line"><span class="comment"># 转换为灰度图</span></div><div class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</div><div class="line">cv2.imshow(<span class="string">'img'</span>, img)</div><div class="line">cv2.imshow(<span class="string">'gray'</span>, img_gray), cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><code>cv2.cvtColor()</code>用来进行颜色模型转换，参数1是要转换的图片，参数2是转换模式，<code>COLOR_BGR2GRAY</code>表示BGR→Gray，可用下面的代码显示所有的转换模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> i.startswith(<span class="string">'COLOR_'</span>)]</div><div class="line">print(flags)</div></pre></td></tr></table></figure>
<h3 id="视频中特定颜色物体追踪"><a href="#视频中特定颜色物体追踪" class="headerlink" title="视频中特定颜色物体追踪"></a>视频中特定颜色物体追踪</h3><p><a href="https://baike.baidu.com/item/HSV/547122" target="_blank" rel="external">HSV</a>是一个常用于颜色识别的模型，相比BGR更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p>
<blockquote>
<p>经验之谈：OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p>
</blockquote>
<p>现在，我们实现一个使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p>
<ol>
<li>捕获视频中的一帧</li>
<li>从BGR转换到HSV</li>
<li>提取蓝色范围的物体</li>
<li>只显示蓝色物体</li>
</ol>
<p><img src="http://pic.ex2tron.top/cv2_blue_object_tracking.jpg" alt="跟踪视频中的蓝色物体"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 蓝色的范围，不同光照条件下不一样，可灵活调整</span></div><div class="line">lower_blue = np.array([<span class="number">100</span>, <span class="number">110</span>, <span class="number">110</span>])</div><div class="line">upper_blue = np.array([<span class="number">130</span>, <span class="number">255</span>, <span class="number">255</span>])</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</div><div class="line">    <span class="comment"># 1.捕获视频中的一帧</span></div><div class="line">    ret, frame = capture.read()</div><div class="line"></div><div class="line">    <span class="comment"># 2.从BGR转换到HSV</span></div><div class="line">    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</div><div class="line"></div><div class="line">    <span class="comment"># 3.inRange()：介于lower/upper之间的为白色，其余黑色</span></div><div class="line">    mask = cv2.inRange(hsv, lower_blue, upper_blue)</div><div class="line"></div><div class="line">    <span class="comment"># 4.只保留原图中的蓝色部分</span></div><div class="line">    res = cv2.bitwise_and(frame, frame, mask=mask)</div><div class="line"></div><div class="line">    cv2.imshow(<span class="string">'frame'</span>, frame)</div><div class="line">    cv2.imshow(<span class="string">'mask'</span>, mask)</div><div class="line">    cv2.imshow(<span class="string">'res'</span>, res)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p>其中，bitwise_and()函数暂时不用管，后面会讲到。那蓝色的HSV值的lower和upper范围是怎么得到的呢？其实很简单，我们先把标准蓝色的值用cvtColor()转换下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">blue = np.uint8([[[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]]])</div><div class="line">hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV)</div><div class="line">print(hsv_blue)  <span class="comment"># [[[120 255 255]]]</span></div></pre></td></tr></table></figure>
<p>结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。</p>
<blockquote>
<p>经验之谈：<a href="https://baike.baidu.com/item/Lab/1514615" target="_blank" rel="external">Lab</a>颜色空间也经常用来做颜色识别，有兴趣的同学可以了解下。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>cv2.cvtColor()函数用来进行颜色空间转换，常用BGR↔Gray，BGR↔HSV</li>
<li>HSV/Lab颜色模型常用于颜色识别。要想知道某种颜色在HSV下的值，可以将它的BGR值用cvtColor()转换得到</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>尝试在视频中同时提取红色、蓝色、绿色的物体。（效果如下）</li>
</ol>
<p><img src="http://pic.ex2tron.top/cv2_exercise_tracking_three_colors.jpg" alt="同时追踪3种颜色"></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/5.%20%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html" target="_blank" rel="external">Changing Colorspaces</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何进行图片的颜色空间转换，视频中追踪特定颜色物体。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="HSV" scheme="http://ex2tron.coding.me/tags/HSV/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程4：图像基本操作</title>
    <link href="http://ex2tron.coding.me/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://ex2tron.coding.me/2017/12/07/Python-OpenCV教程4：图像基本操作/</id>
    <published>2017-12-07T04:13:15.000Z</published>
    <updated>2017-12-29T02:59:29.838Z</updated>
    
    <content type="html"><![CDATA[<p>学习获取和修改像素点的值，ROI感兴趣区域，通道分离合并等基本操作。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>访问和修改图片像素点的值</li>
<li>获取图片的宽、高、通道数等属性</li>
<li>了解感兴趣区域ROI</li>
<li>分离和合并图像通道</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h3><p>我们先读入一张图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</div></pre></td></tr></table></figure>
<p>通过行列的坐标来获取某像素点的值，对于彩色图，这个值是B,G,R三个值的列表，对于灰度图，只有一个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">px = img[<span class="number">100</span>, <span class="number">100</span>]</div><div class="line">print(px)  <span class="comment"># [119 108 201]</span></div><div class="line"></div><div class="line"><span class="comment"># 只获取蓝色blue通道的值</span></div><div class="line">px_blue = img[<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>]</div><div class="line">print(px_blue)  <span class="comment"># 119</span></div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：还记得吗？行对应的是y，列对应的是x，所以其实是<code>img[y, x]</code>，需要注意噢(●ˇ∀ˇ●)</p>
</blockquote>
<p>修改像素的值也是同样的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">img[<span class="number">100</span>, <span class="number">100</span>] = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]</div><div class="line">print(img[<span class="number">100</span>, <span class="number">100</span>])  <span class="comment"># [255 255 255]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：还有一种性能更好的方式，获取：<code>img.item(100,100,0)</code>，修改：<code>img.itemset((100,100,0),255)</code>，但这种方式只能B,G,R逐一进行</p>
</blockquote>
<h3 id="图片属性"><a href="#图片属性" class="headerlink" title="图片属性"></a>图片属性</h3><p><code>img.shape</code>获取图像的形状，图片是彩色的话，返回一个包含高度、宽度和通道数的元组，灰度图只返回高度和宽度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(img.shape)  <span class="comment"># (263, 263, 3)</span></div><div class="line"><span class="comment"># 形状中包括高度、宽度和通道数</span></div><div class="line">height, width, channels = img.shape</div><div class="line"><span class="comment"># img是灰度图的话：height, width = img.shape</span></div></pre></td></tr></table></figure>
<p><code>img.dtype</code>获取图像数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(img.dtype)  <span class="comment"># uint8</span></div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：很多错误都是因为数据类型不对导致的，所以健壮的代码需要对这个属性加以判断</p>
</blockquote>
<p><code>img.size</code>获取图像总像素数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(img.size)  <span class="comment"># 263*263*3=207507</span></div></pre></td></tr></table></figure>
<h3 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h3><p><a href="https://baike.baidu.com/item/ROI/1125333#viewPageContent" target="_blank" rel="external">ROI</a>：region of interest，感兴趣区域。什么意思呢？比如我们要检测眼睛，因为眼睛肯定在脸上，所以我们感兴趣的只有脸这部分，其他不需要关注，这样就可以大大节省计算量，提高运行速度。</p>
<p><img src="http://pic.ex2tron.top/cv2_lena_face_roi_crop.jpg" alt="只关注脸( ╯□╰ )"></p>
<p>截取ROI非常简单，指定图片的范围即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 截取脸部ROI</span></div><div class="line">face = img[<span class="number">100</span>:<span class="number">200</span>, <span class="number">115</span>:<span class="number">188</span>]</div><div class="line">cv2.imshow(<span class="string">'face'</span>, face)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h3 id="通道分割与合并"><a href="#通道分割与合并" class="headerlink" title="通道分割与合并"></a>通道分割与合并</h3><p>彩色图的BGR三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用<code>cv2.split()</code>和<code>cv2.merge()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b, g, r = cv2.split(img)</div><div class="line">img = cv2.merge((b, g, r))</div></pre></td></tr></table></figure>
<p>split()函数比较耗时，<strong>更高效的方式是用numpy的索引</strong>，如提取B通道：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">b = img[:, :, <span class="number">0</span>]</div><div class="line">cv2.imshow(<span class="string">'blue'</span>, b)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>img[y,x]获取/设置像素点值，img.shape：图片的形状（高度、宽度、通道数）,img.dtype：图像的数据类型</li>
<li>img[y1:y2,x1:x2]进行ROI截取，cv2.split()/cv2.merge()通道分割/合并。更推荐的获取单通道方式：b = img[:, :, 0]</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>打开lena.jpg，将帽子部分（高：25~120，宽：50~220）的红色通道截取出来并显示。</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/4.%20图像基本操作" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html#basic-ops" target="_blank" rel="external">Basic Operations on Images</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习获取和修改像素点的值，ROI感兴趣区域，通道分离合并等基本操作。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="ROI" scheme="http://ex2tron.coding.me/tags/ROI/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇3：滑动条</title>
    <link href="http://ex2tron.coding.me/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/"/>
    <id>http://ex2tron.coding.me/2017/12/06/Python-OpenCV教程番外篇3：滑动条/</id>
    <published>2017-12-06T14:23:11.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用滑动条动态调整参数。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>创建和使用滑动条</li>
<li>OpenCV函数：cv2.createTrackbar(), cv2.getTrackbarPos()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="滑动条的使用"><a href="#滑动条的使用" class="headerlink" title="滑动条的使用"></a>滑动条的使用</h3><p>首先我们需要创建一个滑动条，如<code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code>，其中</p>
<ul>
<li>参数1：滑动条的名称</li>
<li>参数2：所在窗口的名称</li>
<li>参数3：当前的值</li>
<li>参数4：最大值</li>
<li>参数5：回调函数名称，回调函数默认有一个表示当前值的参数</li>
</ul>
<p>创建好之后，可以在回调函数中获取滑动条的值，也可以用：<code>cv2.getTrackbarPos()</code>得到，其中，参数1是滑动条的名称，参数2是窗口的名称。下面我们实现一个RGB的调色板，理解下函数的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 回调函数，x表示滑块的位置，本例暂不使用</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">img = np.zeros((<span class="number">300</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</div><div class="line">cv2.namedWindow(<span class="string">'image'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建RGB三个滑动条</span></div><div class="line">cv2.createTrackbar(<span class="string">'R'</span>, <span class="string">'image'</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</div><div class="line">cv2.createTrackbar(<span class="string">'G'</span>, <span class="string">'image'</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</div><div class="line">cv2.createTrackbar(<span class="string">'B'</span>, <span class="string">'image'</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</div><div class="line">    cv2.imshow(<span class="string">'image'</span>, img)</div><div class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line"></div><div class="line">    <span class="comment"># 获取滑块的值</span></div><div class="line">    r = cv2.getTrackbarPos(<span class="string">'R'</span>, <span class="string">'image'</span>)</div><div class="line">    g = cv2.getTrackbarPos(<span class="string">'G'</span>, <span class="string">'image'</span>)</div><div class="line">    b = cv2.getTrackbarPos(<span class="string">'B'</span>, <span class="string">'image'</span>)</div><div class="line">    <span class="comment"># 设定img的颜色</span></div><div class="line">    img[:] = [b, g, r]</div></pre></td></tr></table></figure>
<p><img src="http://pic.ex2tron.top/cv2_track_bar_rgb.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>cv2.createTrackbar()用来创建滑动条，可以在回调函数中得到滑块的位置，也可以用cv2.getTrackbarPos()</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇3.%20滑动条" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_trackbar/py_trackbar.html" target="_blank" rel="external">Trackbar as the Color Palette</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用滑动条动态调整参数。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="滑动条" scheme="http://ex2tron.coding.me/tags/%E6%BB%91%E5%8A%A8%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程3：打开摄像头</title>
    <link href="http://ex2tron.coding.me/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    <id>http://ex2tron.coding.me/2017/12/06/Python-OpenCV教程3：打开摄像头/</id>
    <published>2017-12-06T08:38:02.000Z</published>
    <updated>2018-02-01T13:02:22.625Z</updated>
    
    <content type="html"><![CDATA[<p>学习打开摄像头捕获照片、播放本地视频、录制视频等。<a id="more"></a>视频等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>打开摄像头并捕获照片</li>
<li>播放本地视频，录制视频</li>
<li>OpenCV函数：cv2.VideoCapture(), cv2.VideoWriter()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h3><p>要使用摄像头，需要使用<code>cv2.VideoCapture(0)</code>创建VideoCapture对象，参数：0指的是摄像头的编号。如果你电脑上有两个摄像头的话，访问第2个摄像头就可以传入1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 打开摄像头并灰度化显示</span></div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">True</span>):</div><div class="line">    <span class="comment"># 获取一帧</span></div><div class="line">    ret, frame = capture.read()</div><div class="line">    <span class="comment"># 将这帧转换为灰度图</span></div><div class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</div><div class="line"></div><div class="line">    cv2.imshow(<span class="string">'frame'</span>, gray)</div><div class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<p><code>capture.read()</code>函数返回的第1个参数ret(return value缩写)是一个布尔值，表示当前这一帧是否获取正确。<code>cv2.cvtColor()</code>用来转换颜色，这里将彩色图转成灰度图。</p>
<p>另外，通过<code>cap.get(propId)</code>可以获取摄像头的一些属性，比如捕获的分辨率，亮度和对比度等。propId是从0~18的数字，代表不同的属性，完整的属性列表可以参考：<a href="https://docs.opencv.org/3.3.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d" target="_blank" rel="external">VideoCaptureProperties</a>。也可以使用<code>cap.set(propId,value)</code>来修改属性值。比如说，我们在while之前添加下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取捕获的分辨率</span></div><div class="line"><span class="comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span></div><div class="line">width, height = capture.get(<span class="number">3</span>), capture.get(<span class="number">4</span>)</div><div class="line">print(width, height)</div><div class="line"></div><div class="line"><span class="comment"># 以原分辨率的一倍来捕获</span></div><div class="line">capture.set(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="number">2</span>)</div><div class="line">capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="number">2</span>)</div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到</p>
</blockquote>
<h3 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a>播放本地视频</h3><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>cv2.waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为25或30。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 播放本地视频</span></div><div class="line">capture = cv2.VideoCapture(<span class="string">'demo_video.mp4'</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span>(capture.isOpened()):</div><div class="line">    ret, frame = capture.read()</div><div class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</div><div class="line"></div><div class="line">    cv2.imshow(<span class="string">'frame'</span>, gray)</div><div class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) == ord(<span class="string">'q'</span>):</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<h3 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h3><p>之前我们保存图片用的是<code>cv2.imwrite()</code>，要保存视频，我们需要创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：</p>
<ul>
<li>输出的文件名，如’output.avi’</li>
<li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin" target="_blank" rel="external">FourCC</a>码</li>
<li>帧率<a href="https://baike.baidu.com/item/FPS/3227416" target="_blank" rel="external">FPS</a></li>
<li>要保存的分辨率大小</li>
</ul>
<p>FourCC是用来指定视频编码方式的四字节码，所有的编码可参考<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="external">Video Codecs</a>。如MJPG编码可以这样写：<code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义编码方式并创建VideoWriter对象</span></div><div class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'MJPG'</span>)</div><div class="line">outfile = cv2.VideoWriter(<span class="string">'output.avi'</span>, fourcc, <span class="number">25.</span>, (<span class="number">640</span>, <span class="number">480</span>))</div><div class="line"></div><div class="line"><span class="keyword">while</span>(capture.isOpened()):</div><div class="line">    ret, frame = capture.read()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ret:</div><div class="line">        outfile.write(frame)  <span class="comment"># 写入文件</span></div><div class="line">        cv2.imshow(<span class="string">'frame'</span>, frame)</div><div class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>使用cv2.VideoCapture()创建视频对象，然后在循环中一帧帧显示图像。参数传入数字时，代表打开摄像头，传入本地视频路径时，表示播放本地视频</li>
<li>cap.get(propId)获取视频属性，cap.set(propId,value)设置视频属性</li>
<li>cv2.VideoWriter()创建视频写入对象，用来录制/保存视频</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li>请尝试先阅读<a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/">番外篇：滑动条</a>，然后实现一个可以拖动滑块播放视频的功能。（提示：需要用到<code>cv2.CAP_PROP_FRAME_COUNT</code>和<code>cv2.CAP_PROP_POS_FRAMES</code>两个属性）</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/3.%20%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://www.fourcc.org/codecs.php" target="_blank" rel="external">Video Codecs by FOURCC</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html" target="_blank" rel="external">Getting Started with Videos</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习打开摄像头捕获照片、播放本地视频、录制视频等。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇2：Matplotlib显示图像</title>
    <link href="http://ex2tron.coding.me/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9AMatplotlib%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/"/>
    <id>http://ex2tron.coding.me/2017/12/06/Python-OpenCV教程番外篇2：Matplotlib显示图像/</id>
    <published>2017-12-06T07:55:15.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何使用Matplotlib显示OpenCV图像。<a id="more"></a></p>
<p>Matplotlib是Python的一个非常重要的绘图库，更多内容可以去<a href="www.matplotlib.org/">官网</a>学习。</p>
<h2 id="显示灰度图"><a href="#显示灰度图" class="headerlink" title="显示灰度图"></a>显示灰度图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>, <span class="number">0</span>)</div><div class="line"><span class="comment"># 灰度图显示，cmap(color map)设置为gray</span></div><div class="line">plt.imshow(img, cmap=<span class="string">'gray'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="http://pic.ex2tron.top/cv2_matplotlib_show_gray_image.jpg" alt=""></p>
<h2 id="显示彩色图"><a href="#显示彩色图" class="headerlink" title="显示彩色图"></a>显示彩色图</h2><p><strong>OpenCV中的图像是以BGR的通道顺序存储的</strong>，但Matplotlib是以RGB模式显示的，所以直接在Matplotlib中显示OpenCV图像会出现问题，因此需要转换一下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</div><div class="line">img2 = img[:, :, ::<span class="number">-1</span>]</div><div class="line"><span class="comment"># 或使用</span></div><div class="line"><span class="comment"># img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span></div><div class="line"></div><div class="line"><span class="comment"># 显示不正确的图</span></div><div class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img) </div><div class="line"><span class="comment"># 显示正确的图</span></div><div class="line">plt.subplot(<span class="number">122</span>)</div><div class="line">plt.xticks([]), plt.yticks([]) <span class="comment"># 隐藏x和y轴</span></div><div class="line">plt.imshow(img2)</div><div class="line"></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<blockquote>
<p>注解：<code>img[:,:,0]</code>表示图片的蓝色通道，熟悉Python的同学应该知道，对一个字符串s进行翻转用的是<code>s[::-1]</code>，同样<code>img[:,:,::-1]</code>就表示BGR通道翻转，变成RGB</p>
</blockquote>
<p>结果如下：</p>
<p><img src="http://pic.ex2tron.top/cv2_matplotlib_show_color_image.jpg" alt=""></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇2.%20Matplotlib显示图像" target="_blank" rel="external">本节源码</a></li>
<li><a href="www.matplotlib.org/">Matplotlib</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何使用Matplotlib显示OpenCV图像。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matplotlib" scheme="http://ex2tron.coding.me/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程2：基本元素-图片</title>
    <link href="http://ex2tron.coding.me/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/"/>
    <id>http://ex2tron.coding.me/2017/12/06/Python-OpenCV教程2：基本元素-图片/</id>
    <published>2017-12-06T07:52:06.000Z</published>
    <updated>2017-12-29T02:59:29.862Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何加载图片，显示并保存图片。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p>
<hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>加载图片，显示图片，保存图片</li>
<li>OpenCV函数：cv2.imread(), cv2.imshow(), cv2.imwrite()</li>
</ul>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><blockquote>
<p> 注：本教程不再赘述图像处理的基本理论，只把需要注意的做简单提及噢(⊙o⊙)</p>
</blockquote>
<p>OpenCV中彩色图是以B-G-R通道存储的，灰度图只有一个通道，图像坐标的起始点是在左上角：</p>
<p><img src="http://pic.ex2tron.top/cv2_image_coordinate_channels.jpg" alt=""></p>
<h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>使用<code>cv2.imread()</code>来读入一张图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line"><span class="comment"># 灰度图加载</span></div><div class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<ul>
<li><p>参数1：图片的文件名</p>
<ul>
<li>如果图片放在当前文件夹下，直接写文件名就行了，如’lena.jpg’</li>
<li>否则，需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</li>
</ul>
</li>
<li><p>参数2：读入方式，省略即采用默认值</p>
<ul>
<li>cv2.IMREAD_COLOR：彩色图，默认值(1)</li>
<li>cv2.IMREAD_GRAYSCALE：灰度图(0)</li>
<li>cv2.IMREAD_UNCHANGED：包含透明通道的彩色图(-1)</li>
</ul>
</li>
</ul>
<blockquote>
<p>经验之谈：路径中不能有中文噢，并且没有加载成功的话是不会报错的，而是None，后面处理才会报错，算是个小坑</p>
</blockquote>
<h3 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h3><p>使用<code>cv2.imshow()</code>显示图片，窗口会自适应图片的大小：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cv2.imshow(<span class="string">'lena'</span>, img)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>结果应该如下：</p>
<p><img src="http://pic.ex2tron.top/cv2_show_lena_gray.jpg" alt="lena灰度图显示"></p>
<p>参数1是窗口的名字，参数2是要显示的图片。</p>
<p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间（毫秒ms）。时间一到，会继续执行接下来的程序，传入0的话表示一直等待。等待期间也可以获取用户的按键输入：<code>k = cv2.waitKey(0)</code>（<a href="#练习">练习1</a>）。</p>
<p>我们也可以先用<code>cv2.namedWindow()</code>创建一个窗口，之后再显示图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先定义窗口，后显示图片</span></div><div class="line">cv2.namedWindow(<span class="string">'lena2'</span>, cv2.WINDOW_NORMAL)</div><div class="line">cv2.imshow(<span class="string">'lena2'</span>, img)</div><div class="line">cv2.waitKey(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>参数1依旧是窗口的名字，参数2默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口大小自适应图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。</p>
<h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>使用<code>cv2.imwrite()</code>保存图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imwrite(<span class="string">'lena_gray.jpg'</span>, img)</div></pre></td></tr></table></figure>
<p>Nice，是不是很简单呐，再接再厉噢(●’◡’●)</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>cv2.imread()读入图片、cv2.imshow()显示图片、cv2.imwrite()保存图片</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>打开lena.jpg并显示，如果按下’s’，就保存图片为’lena_save.bmp’，否则就结束程序</p>
</li>
<li><p>Matplotlib是Python中很重要的绘图库，请学习<a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9AMatplotlib%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/">番外篇：Matplotlib显示图像</a> </p>
</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/2.%20%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" target="_blank" rel="external">Getting Started with Images</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何加载图片，显示并保存图片。
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇1：代码性能优化</title>
    <link href="http://ex2tron.coding.me/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://ex2tron.coding.me/2017/12/06/Python-OpenCV教程番外篇1：代码性能优化/</id>
    <published>2017-12-06T07:51:52.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何评估和优化代码性能。（本节还没更新完…………）<a id="more"></a></p>
<p>完成一项任务很重要，高效地完成更重要。图像处理是对矩阵的操作，数据量巨大。如果代码写的不好，性能差距将很大，所以这节我们来了解下如何评估和提升代码性能。</p>
<h2 id="评估代码运行时间"><a href="#评估代码运行时间" class="headerlink" title="评估代码运行时间"></a>评估代码运行时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line">start = cv2.getTickCount()</div><div class="line"><span class="comment"># 这里写测试代码...</span></div><div class="line">end = cv2.getTickCount()</div><div class="line">print((end - start) / cv2.getTickFrequency())</div></pre></td></tr></table></figure>
<p>这段代码就是用来测量程序运行时间的（单位：s），其中<code>cv2.getTickCount()</code>函数得到电脑启动以来的时钟周期数，<code>cv2.getTickFrequency()</code>返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用Python中的time模块计时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">start = time.clock()</div><div class="line"><span class="comment"># 这里写测试代码...</span></div><div class="line">end = time.clock()</div><div class="line">print(end - start)</div></pre></td></tr></table></figure>
<blockquote>
<p>经验之谈：如果你使用的是<a href="https://baike.baidu.com/item/ipython" target="_blank" rel="external">IPython</a>或<a href="https://baike.baidu.com/item/Jupyter" target="_blank" rel="external">Jupyter Notebook</a>开发环境，性能分析将会非常方便，详情请参考：<a href="http://pynash.org/2013/03/06/timing-and-profiling/" target="_blank" rel="external">Timing and Profiling in IPython</a></p>
</blockquote>
<h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><ul>
<li>数据元素少时用Python语法，数据元素多时用Numpy：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">10</span></div><div class="line">z = np.uint8([<span class="number">10</span>])</div><div class="line"></div><div class="line"><span class="comment"># 尝试比较下面三句话各自的运行时间</span></div><div class="line">y = x * x * x   <span class="comment"># (1.6410249677846285e-06)</span></div><div class="line">y = x**<span class="number">3</span>        <span class="comment"># (2.461537451676943e-06)</span></div><div class="line">y = z * z * z   <span class="comment"># 最慢 (3.1179474387907945e-05)</span></div></pre></td></tr></table></figure>
<p>所以Numpy的运行速度并不一定比Python本身语法快，元素数量较少时，请用Python本身格式。</p>
<ul>
<li>尽量避免使用循环，尤其嵌套循环，因为极其慢！！！</li>
<li>优先使用OpenCV/Numpy中封装好的函数</li>
<li><p>尽量将数据向量化，变成Numpy的数据格式</p>
</li>
<li><p>尽量避免数组的复制操作</p>
</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/番外篇1.%20代码性能优化" target="_blank" rel="external">本节源码</a></li>
<li><a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" target="_blank" rel="external">Python Optimization Techniques</a></li>
<li><a href="http://pynash.org/2013/03/06/timing-and-profiling/" target="_blank" rel="external">Timing and Profiling in IPython</a></li>
<li><a href="http://www.scipy-lectures.org/advanced/advanced_numpy/index.html#advanced-numpy" target="_blank" rel="external">Advanced Numpy</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何评估和优化代码性能。（本节还没更新完…………）
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程1：简介与安装</title>
    <link href="http://ex2tron.coding.me/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://ex2tron.coding.me/2017/12/06/Python-OpenCV教程1：简介与安装/</id>
    <published>2017-12-06T07:50:59.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本教程绝对浅显易懂，非常easy的辣，大家尽可放心食用！</strong><a id="more"></a></p>
<p><strong>我相信大部分人对Python进行图像处理的首要疑问是：它快吗？( ╯□╰ )</strong>，其次是它的应用平台和拓展性，下面我来为你解答这两个疑惑。</p>
<blockquote>
<p>本教程翻译自OpenCV<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/index.html" target="_blank" rel="external">官方英文教程</a>，我按照使用度和难易度翻译和重新编写，将不常用和较难的部分写成番外篇。每小节的源码、图片和练习题答案均可在<a href="#引用">引用</a>处找到。虽然简单，但本教程依然需要你具备Python和图像处理的简单基础噢(⊙o⊙)</p>
</blockquote>
<hr>
<h2 id="Python照样快！"><a href="#Python照样快！" class="headerlink" title="Python照样快！"></a>Python照样快！</h2><p>众所周知，虽然Python语法简洁，编写高效，但相比C/C++运行慢很多。然而Python还有个重要特性：它是一门胶水语言！Python可以很容易地扩展C/C++。OpenCV-Python就是用Python包装了C++的实现，背后实际就是C++的代码在跑，所以代码的运行速度跟原生C/C++速度一样快，而且更加容易编写。</p>
<p>我举两个简单的例子就一目了然了：一个是读入图片，另一个是调整图片的对比度和亮度：</p>
<p><img src="http://pic.ex2tron.top/cv2_python_vs_cplus_time.jpg" alt="Python vs C++"></p>
<p><strong>可以看到某些情况下Python的运行速度甚至好于C++，代码行数也直接少一半多！</strong></p>
<h2 id="人生苦短，我用Python"><a href="#人生苦短，我用Python" class="headerlink" title="人生苦短，我用Python"></a>人生苦短，我用Python</h2><ul>
<li>如果你搞科研用，果断放弃C++（Matlab？出门左拐）</li>
<li>如果你是快速原型开发，验证方案，果断放弃C++</li>
<li>如果你懒的配置OpenCV环境，果断放弃C++</li>
<li>如果你的程序是在支持Python的较高硬件环境下运行，果断放弃C++</li>
<li>如果你担心Python写不了界面，那是你的问题o_o ….</li>
<li>除非你的程序是MFC或已经用C++编写其他模块或是嵌入式设备，那就用C++吧，不过我仍然建议你进行模块式开发，如上层用其他语言，图像处理仍然用Python外部调用。</li>
</ul>
<p>另外，图像是矩阵数据，OpenCV-Python原生支持<a href="https://baike.baidu.com/item/numpy" target="_blank" rel="external">Numpy</a>，相当于Python的Matlab，为矩阵运算、科学计算提供了极大的便利性。<strong>“人生苦短，我用Python”，扔掉C/C++，开始OpenCV-Python吧！！！</strong></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本教程编写时使用的软件版本是：OpenCV 3.x，Python 3.x。</p>
<p>如果你还没安装Python，强烈推荐安装<a href="https://www.anaconda.com/download/" target="_blank" rel="external">Anaconda</a>，它包含了大量的科学计算包，不用后期一个个安装。即使你已经装了Python也没有影响，Anaconda相当于虚拟环境，互不干扰。安装好之后，可以在cmd中输入<code>python --version</code>来查看Python的版本信息。</p>
<blockquote>
<p>经验之谈：Windows版的Anaconda安装时，记得勾选<code>Add Anaconda to my PATH environment variable</code>，添加到环境变量中</p>
</blockquote>
<p><img src="http://pic.ex2tron.top/cv2_install_opencv-python.jpg" alt=""></p>
<p>要安装OpenCV，只需cmd下的一条指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install opencv-python</div></pre></td></tr></table></figure>
<p>要测试是否安装正确，打开Python的开发环境，输入<code>import cv2</code>，运行没有报错说明一切正常。要查看OpenCV的版本，可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(cv2.__version__)  <span class="comment"># '3.3.0'</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Python开发环境我用的是<a href="http://code.visualstudio.com/" target="_blank" rel="external">Visual Studio Code</a>，也可以用<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm</a>/Jupyter Notebook(Anaconda自带)等，自己习惯就行</p>
</blockquote>
<p>常见安装问题：</p>
<ol>
<li>pip识别不了，说明环境变量中没有pip的目录。找到pip目录，添加到用户（或系统）变量的path中</li>
<li>如果下载速度很慢，可以<a href="https://pypi.python.org/pypi?%3Aaction=search&amp;term=opencv-python&amp;submit=search" target="_blank" rel="external">点击此处</a>下载离线版。下载完成后，cmd切换到下载的目录，输入<code>pip install 文件名</code>安装</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://github.com/ex2tron/BlogCode/tree/master/Python%2BOpenCV/1.%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85" target="_blank" rel="external">本节源码</a></li>
<li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html" target="_blank" rel="external">OpenCV-Python Tutorials</a></li>
<li><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="external">Numpy Quickstart Tutorial</a></li>
<li><a href="https://docs.opencv.org/" target="_blank" rel="external">OpenCV Docs</a></li>
<li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html" target="_blank" rel="external">OpenCV 中文教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本教程绝对浅显易懂，非常easy的辣，大家尽可放心食用！&lt;/strong&gt;
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【片单】漫威宇宙电影合集</title>
    <link href="http://ex2tron.coding.me/2017/12/05/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91%E6%BC%AB%E5%A8%81%E5%AE%87%E5%AE%99%E7%94%B5%E5%BD%B1%E5%90%88%E9%9B%86/"/>
    <id>http://ex2tron.coding.me/2017/12/05/【片单】漫威宇宙电影合集/</id>
    <published>2017-12-05T14:44:35.000Z</published>
    <updated>2018-03-15T07:43:52.335Z</updated>
    
    <content type="html"><![CDATA[<p>十年，17部电影，超过130亿美元的总票房，漫威宇宙电影合集下载！！！<a id="more"></a></p>
<blockquote>
<p><em>Excelsior!</em>  ——<a href="https://baike.baidu.com/item/%E6%96%AF%E5%9D%A6%C2%B7%E6%9D%8E?fromtitle=%E6%96%AF%E5%9D%A6%E6%9D%8E" target="_blank" rel="external">斯坦·李</a></p>
</blockquote>
<p>漫威电影宇宙MCU的成绩有目共睹，在十周年《复仇者联盟3》上映之前，来补一波吧！</p>
<blockquote>
<p>大部分片源来自人人影视字幕组，点击片名即可下载</p>
</blockquote>
<p>MCU观影指南：</p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ul>
<li><p>2008<a href="ed2k://|file|Iron.Man.%E9%92%A2%E9%93%81%E4%BE%A0.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2361675752|A57750EDD6B523F23E23DF9D123FA998|h=3PEOFILFEMS624ZBPUHMPBMDQEQ6FR4L|/" target="_blank" rel="external">《钢铁侠1》</a>、</p>
</li>
<li><p>2008<a href="ed2k://|file|The.Incredible.Hulk.2008.无敌浩克.HR-HDTV.AC3.1024X576.x264-人人影视制作.mkv|2057353900|d922864d91ddc2d951e0b7a0e8ce92d5|h=sjk76hnh4i7jcr4iawdgxgt5qrplkgwq|/" target="_blank" rel="external">《无敌浩克》</a></p>
</li>
<li><p>2010<a href="ed2k://|file|Iron.Man.2.2010.钢铁侠2.双语字幕.HR-HDTV.AC3.1024X576.X264-人人影视制作-V2.mkv|2399217093|B2EDD162F3F87A44BB3F22B6A56139C9|h=S567W4RKR7DEDYM4RWPUDUGZ3WODMNEO|/" target="_blank" rel="external">《钢铁侠2》</a></p>
</li>
<li><p>2011<a href="ed2k://|file|Thor.2011.雷神.双语字幕.HR-HDTV.AC3.1024X576.x264-人人影视制作.mkv|1880859452|66fd462065e75f7212c395830604353b|h=knfugovs45x6lb3r3u6ynsvzunih3htf|/" target="_blank" rel="external">《雷神1》</a></p>
</li>
<li><p>2011<a href="ed2k://|file|Captain.America.The.First.Avenger.2011.美国队长.双语字幕.HR-HDTV.AC3.国英双轨.1024x576.x264-人人影视制作V2.mkv|2390474328|597f0eda174822459c9148b98c89254a|h=poz6edd26vnwxsckctja2wcmze6ik3wv|/" target="_blank" rel="external">《美国队长1：复仇者先锋》</a></p>
</li>
<li><p>2012<a href="ed2k://|file|The.Avengers.2012.%E5%A4%8D%E4%BB%87%E8%80%85%E8%81%94%E7%9B%9F.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2342023084|e7aaff83360f02590456ae9a9bbbd62c|h=tgi7w7tygvfi2mw7l3yc3cxrhvxkl7re|/" target="_blank" rel="external">《复仇者联盟1》</a></p>
</li>
</ul>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul>
<li><p>2013<a href="ed2k://|file|Iron.Man.3.2013.%E9%92%A2%E9%93%81%E4%BE%A03.%E5%9B%BD%E8%8B%B1%E9%9F%B3%E8%BD%A8.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2516386988|a32e610de8f7204e3ef1648992d2e931|h=6kn524mepattpprjcj5pial632dvcusq|/" target="_blank" rel="external">《钢铁侠3》</a></p>
</li>
<li><p>2013<a href="ed2k://|file|Thor.The.Dark.World.2013.%E9%9B%B7%E7%A5%9E2.%E9%BB%91%E6%9A%97%E4%B8%96%E7%95%8C.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264.V3.mkv|1836942899|ee1b92de5932b3e256f2806fa181a3a8|h=fnv6kfu6o22x5gcthfwcmgqkhb5c2oiv|/" target="_blank" rel="external">《雷神2：黑暗世界》</a></p>
</li>
<li><p>2014<a href="ed2k://|file|Captain.America.The.Winter.Soldier.2014.%E7%BE%8E%E5%9B%BD%E9%98%9F%E9%95%BF2.%E5%AF%92%E5%86%AC%E6%88%98%E5%A3%AB.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.%E5%9B%BD%E8%8B%B1%E9%9F%B3%E8%BD%A8.HR-HDTV.AC3.1024X576.x264.mkv|2423689222|aab58a8e1597f8f2eb458bbf6a5fabee|h=dvu33u5xxr23yrz7iueicgw7v3tt7l45|/" target="_blank" rel="external">《美国队长2：冬日战士》</a></p>
</li>
<li><p>2014<a href="ed2k://|file|Guardians.of.the.Galaxy.2014.%E9%93%B6%E6%B2%B3%E6%8A%A4%E5%8D%AB%E9%98%9F.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.%E5%9B%BD%E8%8B%B1%E9%9F%B3%E8%BD%A8.HR-HDTV.AC3.1024X576.x264.mkv|2329356557|c1ad7fca434823a2fcc338f04a93454d|h=4fpq6vlgvevlw7ynubbq24qwlgdcd5db|/" target="_blank" rel="external">《银河护卫队1》</a></p>
</li>
<li><p>2015<a href="ed2k://|file|%E5%A4%8D%E4%BB%87%E8%80%85%E8%81%94%E7%9B%9F2.%E5%A5%A5%E5%88%9B%E7%BA%AA%E5%85%83.Avengers.Age.of.Ultron.2015.%E4%B8%AD%E8%8B%B1%E5%AD%97%E5%B9%95.720p.BluRay.x264.%E6%B7%B1%E5%BD%B1%E5%AD%97%E5%B9%95%E7%BB%84V2.mkv|2880214307|40624438C45C22FD97DCAA729D20CEE7|h=P2KBJUF4NMPP4SAKFZ3BEQ36XIKCLWS2|/" target="_blank" rel="external">《复仇者联盟2：奥创纪元》</a></p>
</li>
<li><p>2015<a href="ed2k://|file|%E8%9A%81%E4%BA%BA.%E5%9B%BD%E8%8B%B1%E5%8F%8C%E8%AF%AD.Ant.Man.2015.%E4%B8%AD%E8%8B%B1%E5%AD%97%E5%B9%95.720p.BluRay.x264%E6%B7%B1%E5%BD%B1%E5%AD%97%E5%B9%95%E7%BB%84%E5%8E%9F%E5%88%9B%E7%BF%BB%E8%AF%91.mkv|3270488398|23049A0021390D3C8DE2EB01475E894D|h=O5QUE3SUOMOJQJHOHMECRZQXWYSSLHY7|/" target="_blank" rel="external">《蚁人》</a></p>
</li>
</ul>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><ul>
<li><p>2016<a href="ed2k://|file|Captain.America.Civil.War.2016.%E7%BE%8E%E5%9B%BD%E9%98%9F%E9%95%BF3.%E5%86%85%E6%88%98.720p.Chi_Eng.ZMZ-BD-MP4.mp4|2211413028|21396487c8b522d35aa41e730de259f1|h=mxuhofnlvyag73wjmpnuslvydr25ekb4|/" target="_blank" rel="external">《美国队长3：内战》</a></p>
</li>
<li><p>2016<a href="ed2k://|file|Doctor.Strange.2016.%E5%A5%87%E5%BC%82%E5%8D%9A%E5%A3%AB.720p.Chi_Eng.ZMZ-BD-MP4-V2.mp4|1720039183|f459977e521c1195072e325ff265729b|h=ejbqsrl2qh4o2vx4z4ukaj3h27eg74nk|/" target="_blank" rel="external">《奇异博士》</a></p>
</li>
<li><p>2017<a href="ed2k://|file|Guardians.of.the.Galaxy.Vol.2.2017.%E9%93%B6%E6%B2%B3%E6%8A%A4%E5%8D%AB%E9%98%9F2.720p.Chi_Eng.BD-MP4-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86.mp4|2031475653|594ceb90d556b5f05cef10791f396651|h=z4ujw3gtdapunozxu52a4xn6eqjun3pd|/" target="_blank" rel="external">《银河护卫队2》</a></p>
</li>
<li><p>2017<a href="ed2k://|file|%E8%9C%98%E8%9B%9B%E4%BE%A0.%E8%8B%B1%E9%9B%84%E5%BD%92%E6%9D%A5%E4%B8%AD%E8%8B%B1%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.Spider-Man.Homecoming.2017.1080p.BluRay.x264.chs.eng-EX8.mp4|2637604541|C51B6D12CB5AC288F65639027075E7C3|h=UDYIQXIDKMCOMOAU4A6OFPNVNMZEO4QF|/" target="_blank" rel="external">《蜘蛛侠：英雄归来》</a></p>
</li>
<li><p>2017<a href="ed2k://|file|雷神3.诸神黄昏.Thor.Ragnarok.2017.中英字幕.BDrip.AAC.720p.x264-人人影视.mp4|1890495631|221602f252be2d2a2d6327b2efd86bb8|h=qi6gavxnwj65wtkzjvpdismkje4vn7qr|/" target="_blank" rel="external">《雷神3：诸神黄昏》</a></p>
</li>
<li><p>2018《复仇者联盟3：无限战争》(即将上映)</p>
</li>
</ul>
<p><img src="http://img5.mtime.cn/pi/2017/07/26/151208.45265741_1000X1000.jpg" alt="无限战争！！！"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十年，17部电影，超过130亿美元的总票房，漫威宇宙电影合集下载！！！
    
    </summary>
    
      <category term="谈电影" scheme="http://ex2tron.coding.me/categories/%E8%B0%88%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="漫威" scheme="http://ex2tron.coding.me/tags/%E6%BC%AB%E5%A8%81/"/>
    
      <category term="Marvel" scheme="http://ex2tron.coding.me/tags/Marvel/"/>
    
      <category term="复仇者联盟" scheme="http://ex2tron.coding.me/tags/%E5%A4%8D%E4%BB%87%E8%80%85%E8%81%94%E7%9B%9F/"/>
    
  </entry>
  
  <entry>
    <title>【片单】007电影合集</title>
    <link href="http://ex2tron.coding.me/2017/12/05/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91007%E7%94%B5%E5%BD%B1%E5%90%88%E9%9B%86/"/>
    <id>http://ex2tron.coding.me/2017/12/05/【片单】007电影合集/</id>
    <published>2017-12-05T13:53:37.000Z</published>
    <updated>2018-04-07T09:40:49.080Z</updated>
    
    <content type="html"><![CDATA[<p>作为风靡全球的一系列谍战电影，007怎能不看呢？007电影合集下载！<a id="more"></a></p>
<blockquote>
<p><em>“My name is Bond, James Bond.”</em> ——<a href="https://baike.baidu.com/item/%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E9%82%A6%E5%BE%B7" target="_blank" rel="external">詹姆斯·邦德</a></p>
</blockquote>
<p>目前为止，<a href="https://baike.baidu.com/item/007/33915" target="_blank" rel="external">007</a>系列电影已经有24部辣，六任邦德。</p>
<blockquote>
<p>大部分片源来自人人影视字幕组，点击片名即可下载</p>
</blockquote>
<h3 id="肖恩·康纳利"><a href="#肖恩·康纳利" class="headerlink" title="肖恩·康纳利"></a><a href="https://baike.baidu.com/item/%E8%82%96%E6%81%A9%C2%B7%E5%BA%B7%E7%BA%B3%E5%88%A9/1296145?fr=aladdin" target="_blank" rel="external">肖恩·康纳利</a></h3><ul>
<li><p><a href="ed2k://|file|007.Dr.No.007%E4%B8%80%E4%B9%8B%E8%AF%BA%E5%8D%9A%E5%A3%AB.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|1913696596|C6FE723B4B78F21C3E55DC18D46C7111|h=7DXVWWD3DJSOXFHCTQKTA4F3WFDZEVIV|/" target="_blank" rel="external">1. 诺博士 (1962)</a></p>
</li>
<li><p><a href="ed2k://|file|007.From.Russia.With.Love.007%E4%B9%8B%E6%9D%A5%E8%87%AA%E4%BF%84%E7%BD%97%E6%96%AF%E7%9A%84%E7%88%B1%E6%83%85.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2146366494|A5272581B54C03D5FFE146BB5138E65C|h=7ZGFPIXHB5NHLO2SJRABGS44L6RNWK6Y|/" target="_blank" rel="external">2. 来自俄罗斯的爱情 (1963)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Goldfinger.007%E4%B8%89%E4%B9%8B%E9%87%91%E6%89%8B%E6%8C%87.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|1916784496|E402B4F3B51A507989623ECFBFD10C03|h=QAX4CPZFHQ74A5UJL5P7D3BZDPC65N5N|/" target="_blank" rel="external">3. 金手指 (1964)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Thunderball.007%E5%9B%9B%E4%B9%8B%E9%9C%B9%E9%9B%B3%E5%BC%B9.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2076483141|57CF7BC6E559112294768D5E917178F4|h=CT4WTGA5BQPNIO7HQBABGSCKH7SMSA7Z|/" target="_blank" rel="external">4. 霹雳弹 (1965)</a></p>
</li>
<li><p><a href="ed2k://|file|007.You.Only.Live.Twice.1967.007%E4%B9%8B%E4%BA%94.%E9%9B%B7%E9%9C%86%E8%B0%B7.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|1914625767|17AE9681AE5ECB4D595A1727078784D0|h=4FJWBQFXO4BG3RHKNYJI2S2Y44BBFTGQ|/" target="_blank" rel="external">5. 雷霆谷 (1967)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Diamonds.Are.Forever.1971.007%E4%B9%8B%E4%B8%83.%E9%87%91%E5%88%9A%E9%92%BB.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|1966585687|12B2C63CBC9B7A429C010249D46714D7|h=RSA5RHKCJYLSW47OPAVVRD7EMJ2HIYWH|/" target="_blank" rel="external">7. 金刚钻 (1971)</a></p>
</li>
</ul>
<h3 id="乔治·拉赞贝"><a href="#乔治·拉赞贝" class="headerlink" title="乔治·拉赞贝"></a><a href="https://baike.baidu.com/item/%E4%B9%94%E6%B2%BB%C2%B7%E6%8B%89%E8%B5%9E%E8%B4%9D" target="_blank" rel="external">乔治·拉赞贝</a></h3><ul>
<li><a href="ed2k://|file|007.On.Her.Majesty&#39;s.Secret.Service.1969.007%E4%B9%8B%E5%85%AD.%E5%A5%B3%E7%8E%8B%E5%AF%86%E4%BD%BF.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2331057895|1E4087A7801D7D197B6A3814D506DA8F|h=XG46LWWQHOHALH5DET6HP62ST7P6KPOZ|/" target="_blank" rel="external">6. 女王密使 (1969)</a></li>
</ul>
<h3 id="罗杰·摩尔"><a href="#罗杰·摩尔" class="headerlink" title="罗杰·摩尔"></a><a href="https://baike.baidu.com/item/%E7%BD%97%E6%9D%B0%C2%B7%E6%91%A9%E5%B0%94" target="_blank" rel="external">罗杰·摩尔</a></h3><ul>
<li><p><a href="ed2k://|file|007.Live.And.Let.Die.007%E5%85%AB%E4%B9%8B%E7%94%9F%E6%AD%BB%E5%85%B3%E5%A4%B4.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|1936810728|B7AFD058658CEF5824BEE123268751A3|h=GD7T3TIURDYSSMAAESQKTIRSGGALMI4I|/" target="_blank" rel="external">8. 生死关头 (1973)</a></p>
</li>
<li><p><a href="ed2k://|file|007.The.Man.With.The.Golden.Gun.007%E4%B9%9D%E4%B9%8B%E9%87%91%E6%9E%AA%E5%AE%A2.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2146838874|1217ADBB7379B9A02BD7896C1B54D756|h=SDWXB64QL2OV5XVZIYKRLHUKR36SZFUP|/" target="_blank" rel="external">9. 金枪人 (1974)</a></p>
</li>
<li><p><a href="ed2k://|file|007.The.Spy.Who.Loved.Me.1977.007%E4%B9%8B%E5%8D%81.%E6%B5%B7%E5%BA%95%E5%9F%8E.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2059121613|40c2eed3d4a47ded3661c12c975b740b|h=d322j2ewh3nvvmtzcymr2l3lnampwtuh|/" target="_blank" rel="external">10. 海底城 (1977)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Moonraker.007%E5%8D%81%E4%B8%80%E4%B9%8B%E5%A4%AA%E7%A9%BA%E5%9F%8E.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2013910320|EC2F45C0D7F7B3FA20D519C803FDBB6C|h=BIXOZG7PXNV4XIN5XHBKNWF3U2N6Q5NZ|/" target="_blank" rel="external">11. 太空城 (1979)</a></p>
</li>
<li><p><a href="ed2k://|file|007.For.Your.Eyes.Only.007%E5%8D%81%E4%BA%8C%E4%B9%8B%E6%9C%80%E9%AB%98%E6%9C%BA%E5%AF%86.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2037867746|6AE8D6AF054AB0F0CCA4D76EAD4E2D01|h=V7CPFNEUFZLV2U432NRJ4BNTTY2SS2DN|/" target="_blank" rel="external">12. 最高机密 (1981)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Octopussy.1983.007%E4%B9%8B%E5%8D%81%E4%B8%89.%E5%85%AB%E7%88%AA%E5%A5%B3.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2141435743|331067E8AFA7FDFFFBAB78603D3E7633|h=ZTYVOAEYHC2TJ3LXKNKCYLUAG37F64TN|/" target="_blank" rel="external">13. 八爪女 (1983)</a></p>
</li>
<li><p><a href="ed2k://|file|007.A.View.to.a.Kill.1985.007%E4%B9%8B%E5%8D%81%E5%9B%9B.%E9%9B%B7%E9%9C%86%E6%9D%80%E6%9C%BA.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2149910751|973D4CC219A862DD41387DC4E643B76E|h=WOEAC22AXSW73Y3E6ZRVQ7EGLNTHYAZ7|/" target="_blank" rel="external">14. 雷霆杀机 (1985)</a></p>
</li>
</ul>
<h3 id="提摩西·达顿"><a href="#提摩西·达顿" class="headerlink" title="提摩西·达顿"></a><a href="https://baike.baidu.com/item/%E8%92%82%E8%8E%AB%E8%A5%BF%C2%B7%E9%81%93%E5%B0%94%E9%A1%BF?fromtitle=%E6%8F%90%E6%91%A9%E8%A5%BF%C2%B7%E8%BE%BE%E9%A1%BF&amp;fromid=5896399" target="_blank" rel="external">提摩西·达顿</a></h3><ul>
<li><p><a href="ed2k://|file|007.The.Living.Daylights.1987.007%E4%B9%8B%E5%8D%81%E4%BA%94.%E9%BB%8E%E6%98%8E%E7%94%9F%E6%9C%BA.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2142980673|760337424d92b0a8ff8a3f9d41a45f9c|h=jsr32adn2bpt5bg6hmu5rinode3ki5oe|/" target="_blank" rel="external">15. 黎明生机 (1987)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Licence.to.Kill.007%E5%8D%81%E5%85%AD%E4%B9%8B%E6%9D%80%E4%BA%BA%E6%89%A7%E7%85%A7.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2123365557|73D53B3223EA4CC043E3B7D28E4FB3AA|h=YVVUJNYWPLNBIYLGCHMED6LLYD3ATY2C|/" target="_blank" rel="external">16. 杀人执照 (1989)</a></p>
</li>
</ul>
<h3 id="皮尔斯·布鲁斯南"><a href="#皮尔斯·布鲁斯南" class="headerlink" title="皮尔斯·布鲁斯南"></a><a href="https://baike.baidu.com/item/%E7%9A%AE%E5%B0%94%E6%96%AF%C2%B7%E5%B8%83%E9%B2%81%E6%96%AF%E5%8D%97" target="_blank" rel="external">皮尔斯·布鲁斯南</a></h3><ul>
<li><p><a href="ed2k://|file|007.Golden.Eye.1995.007%E4%B9%8B%E5%8D%81%E4%B8%83.%E9%BB%84%E9%87%91%E7%9C%BC.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2128040102|41580421121A4EC08F10D2C98AD81C61|h=5SJE7VER3FXYRMTOBKGV67YD7SBYLHRN|/" target="_blank" rel="external">17. 黄金眼 (1995)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Tomorrow.Never.Dies.1997.007%E4%B9%8B%E5%8D%81%E5%85%AB.%E6%98%8E%E6%97%A5%E5%B8%9D%E5%9B%BD.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.X264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2127814715|ab4b6173fd9b8967589b1e643167306e|h=mwtrwgi4e6hh3og2fv4r6njnf7ylm4tm|/" target="_blank" rel="external">18. 明日帝国 (1997)</a></p>
</li>
<li><p><a href="ed2k://|file|007.The.World.Is.Not.Enough.007%E5%8D%81%E4%B9%9D%E4%B9%8B%E7%BA%B5%E6%A8%AA%E5%A4%A9%E4%B8%8B.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2043466416|0D02C441F5DFF06708F227C6E38B0C32|h=D3AEW75IACQRMLZUNUCRIQM3BRCRUKTJ|/" target="_blank" rel="external">19. 黑日危机 (1999)</a></p>
</li>
<li><p><a href="ed2k://|file|007.Die.Another.Day.007%E4%BA%8C%E5%8D%81%E4%B9%8B%E6%8B%A9%E6%97%A5%E5%86%8D%E6%AD%BB.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2110814556|FDB14FDEB070490E7C3EE7C751F7362F|h=OKDDVV2J2JLJLHSIUKOL3BFG6POWNLEN|/" target="_blank" rel="external">20. 择日而亡 (2002)</a></p>
</li>
</ul>
<h3 id="丹尼尔·克雷格"><a href="#丹尼尔·克雷格" class="headerlink" title="丹尼尔·克雷格"></a><a href="https://baike.baidu.com/item/%E4%B8%B9%E5%B0%BC%E5%B0%94%C2%B7%E5%85%8B%E9%9B%B7%E6%A0%BC" target="_blank" rel="external">丹尼尔·克雷格</a></h3><ul>
<li><p><a href="ed2k://|file|Casino.Royale.2006.皇家赌场#40未分级版#41.双语字幕.HR-HDTV.AC3.1024X576.X264-人人影视制作.mkv|2370236165|55BE0965D3C9C5CCC73336F43D3AE54A|h=CQKYVSGFMDZUCO5YFBXQX54LK63GKLSD|/" target="_blank" rel="external">21. 皇家赌场 (2006)</a></p>
</li>
<li><p><a href="ed2k://|file|Quantum.of.Solace.%E9%87%8F%E5%AD%90%E5%8D%B1%E6%9C%BA.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024x576.x264-YYeTs%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86.mkv|2146586429|845496F04A86E289C12BEF7DD54A7712|h=2UMQQCSA3456CMBOH7QM4AC3XKOKY6OX|/" target="_blank" rel="external">22. 量子危机 (2008)</a></p>
</li>
<li><p><a href="ed2k://|file|Skyfall.2012.%E5%A4%A9%E5%B9%95%E5%8D%B1%E6%9C%BA.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2346323536|34b7cb01ee650684b1503049a7bd2f00|h=2fuebpnbkpv3gycz34p3s2xzje5gjao4|/" target="_blank" rel="external">23. 天幕杀机 (2012)</a></p>
</li>
<li><p><a href="ed2k://|file|Spectre.2015.007%EF%BC%9A%E5%B9%BD%E7%81%B5%E5%85%9A.720p.Chi_Eng.ZMZ-BD-MP4.mp4|2215389133|466424a3435fbcb4e15f4f8a61062c5e|h=rwj5asfdefs3xoh5c56c7pchcm42aoww|/" target="_blank" rel="external">24. 幽灵党 (2015)</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为风靡全球的一系列谍战电影，007怎能不看呢？007电影合集下载！
    
    </summary>
    
      <category term="谈电影" scheme="http://ex2tron.coding.me/categories/%E8%B0%88%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="007" scheme="http://ex2tron.coding.me/tags/007/"/>
    
      <category term="邦德" scheme="http://ex2tron.coding.me/tags/%E9%82%A6%E5%BE%B7/"/>
    
  </entry>
  
  <entry>
    <title>【片单】历届奥斯卡最佳动画长片集</title>
    <link href="http://ex2tron.coding.me/2017/12/05/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91%E5%8E%86%E5%B1%8A%E5%A5%A5%E6%96%AF%E5%8D%A1%E6%9C%80%E4%BD%B3%E5%8A%A8%E7%94%BB%E9%95%BF%E7%89%87%E9%9B%86/"/>
    <id>http://ex2tron.coding.me/2017/12/05/【片单】历届奥斯卡最佳动画长片集/</id>
    <published>2017-12-05T06:55:09.000Z</published>
    <updated>2018-01-04T14:00:27.944Z</updated>
    
    <content type="html"><![CDATA[<p>历届奥斯卡最佳动画长片合集下载！！！<a id="more"></a></p>
<blockquote>
<p><em>Take her to the moon for me, okay?</em>  ——<a href="https://movie.douban.com/subject/10533913/" target="_blank" rel="external">头脑特工队(Inside Out)</a></p>
</blockquote>
<p>奥斯卡最佳动画长片奖设立于2002年，由当时的奥斯卡最佳动画奖细分出来。</p>
<p>天马行空的创意、顶级技术效果、发现生活的美好……都是我喜欢动画的原因。我一直很喜欢国内早期的动画片，三个和尚、小蝌蚪找妈妈和大闹天宫…然而国漫之后一直没啥起色。每次看到喜羊羊，熊出没，我就…同时好莱坞三大动画工作室，迪士尼（皮克斯）、梦工厂、蓝天工作室每年都在制作着世界顶级动画作品。而奥斯卡最佳动画长片更是代表了每年作品中的佼佼者。</p>
<blockquote>
<p>大部分片源来自人人影视字幕组，点击片名即可下载</p>
</blockquote>
<ul>
<li><p>第89届奥斯卡最佳动画长片（2017）：<a href="ed2k://|file|Zootopia.2016.%E7%96%AF%E7%8B%82%E5%8A%A8%E7%89%A9%E5%9F%8E.720p.Chi_Eng.ZMZ-BD-MP4.mp4|1624450533|b2bd5f3bbccb67d70e1b6b2309e986c9|h=bluqdoehhs6nwianhaqbebr54732rubc|/" target="_blank" rel="external">疯狂动物城</a></p>
</li>
<li><p>第88届奥斯卡最佳动画长片（2016）：<a href="ed2k://|file|%E5%A4%B4%E8%84%91%E7%89%B9%E5%B7%A5%E9%98%9F.Inside.Out.2015.%E4%B8%AD%E8%8B%B1%E5%AD%97%E5%B9%95.720p.BluRay.x264.%E6%B7%B1%E5%BD%B1%E5%AD%97%E5%B9%95%E7%BB%84.mkv|2344293745|74B8904467BC963BD950C988A6FDEC18|h=YJEWNF4JLIOYQR5F2E5V2KFU7DYRWNL7|/" target="_blank" rel="external">头脑特工队</a></p>
</li>
<li><p>第87届奥斯卡最佳动画长片（2015）：<a href="ed2k://|file|%E8%B6%85%E8%83%BD%E9%99%86%E6%88%98%E9%98%9F.Big.Hero.6.2014.%E4%B8%AD%E8%8B%B1%E5%AD%97%E5%B9%95.BDrip.720p.x264.%E6%B7%B1%E5%BD%B1%E8%AE%BA%E5%9D%9B%E7%BF%BB%E8%AF%91%E5%88%B6%E4%BD%9CV3.mkv|2343923616|5D6DB02D89D32CF3557D6D76AC16CDC9|h=UBUWZG7RMFUR6PYY6VLXI3QXCJOLPWRF|/" target="_blank" rel="external">超能陆战队</a></p>
</li>
<li><p>第86届奥斯卡最佳动画长片（2014）：<a href="ed2k://|file|Frozen.2013.%E5%86%B0%E9%9B%AA%E5%A5%87%E7%BC%98.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.%E8%8B%B1%E5%8F%B0%E7%B2%A4%E9%9F%B3%E8%BD%A8.HR-HDTV.AC3.1024X576.x264.V2.mkv|2264858962|f571467d174f0114530ac1bc6c190704|h=lsmudzlfsfxqu3722q6qkwq7jgusxcz7|/" target="_blank" rel="external">冰雪奇缘</a></p>
</li>
<li><p>第85届奥斯卡最佳动画长片（2013）：<a href="ed2k://|file|Brave.2012.%E5%8B%87%E6%95%A2%E4%BC%A0%E8%AF%B4.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|1534863000|2c388a9be43845a24266a4192369d0d3|h=uwcjzvg3guwhs6kejbd664h5bvhxodag|/" target="_blank" rel="external">勇敢传说</a></p>
</li>
<li><p>第84届奥斯卡最佳动画长片（2012）：<a href="ed2k://|file|Rango.2011.兰戈.双语字幕.HR-HDTV.AC3.1024X576.x264-人人影视制作.mkv|2338210117|fbfac876f4a05a0d5f8ea31936076f36|h=65uxzqomklc657ixx7bt6wvyfsnlkmqo|/" target="_blank" rel="external">兰戈</a></p>
</li>
<li><p>第83届奥斯卡最佳动画长片（2011）：<a href="ed2k://|file|Toy.Story.3.2010.玩具总动员3.国粤英四音轨.双语字幕.HR-HDTV.AC3.1024x576.X264-人人影视制作.mkv|2562839788|2728791516D400440ABE73C30844F00B|h=2TTNRGE7AAMPC4UPOMBSA4STOEXZLLH3|/" target="_blank" rel="external">玩具总动员3</a></p>
</li>
<li><p>第82届奥斯卡最佳动画长片（2010）：<a href="ed2k://|file|Up.2009.%E9%A3%9E%E5%B1%8B%E7%8E%AF%E6%B8%B8%E8%AE%B0.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|1649439684|B1085779D40C6FC46481EB2403D9AD75|h=TKRZ4AQURPGCFW4HIIPMZLHWSLYO3V6N|/" target="_blank" rel="external">飞屋环游记</a></p>
</li>
<li><p>第81届奥斯卡最佳动画长片（2009）：<a href="ed2k://|file|WALL.E.2008.%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%BB%E5%8A%A8%E5%91%98.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.%E5%9B%BD%E8%8B%B1%E7%B2%A4%E9%9F%B3%E8%BD%A8.HR-HDTV.AC3.1024x576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2187264769|b2e470cc0fa2ffb7e02c60f8d462776a|h=n47eq7i5ogxuozbu2pi3k7udsx3hdtmc|/" target="_blank" rel="external">机器人总动员</a></p>
</li>
<li><p>第80届奥斯卡最佳动画长片（2008）：<a href="ed2k://|file|Ratatouille.2007.料理鼠王.双语字幕.HR-HDTV.AAC.1024X576.x264-人人影视制作.mkv|1657757497|923296BE4AC33A8CEEB74A1EFE9FD66F|h=RSE3N54Y6XPJYW4I5KCG7SDGM72CXVVY|/" target="_blank" rel="external">料理鼠王</a></p>
</li>
<li><p>第79届奥斯卡最佳动画长片（2007）：<a href="ed2k://|file|Happy.Feet.2006.快乐的大脚.双语字幕.HR-HDTV.AC3.1024X576.x265-人人影视制作.mkv|1820193043|465E969D87F3B285706A9F6CE0D219EA|h=IG2GHKLNHQXG6CTBGK22BGOCDWHONGOH|/" target="_blank" rel="external">快乐的大脚</a></p>
</li>
<li><p>第78届奥斯卡最佳动画长片（2006）：<a href="ed2k://|file|Wallace.And.Gromit.In.The.Curse.Of.The.Were.Rabbit.2005.超级无敌掌门狗-人兔的诅咒.双语字幕.HR-HDTV.AC3.1024x576.x264-人人影视制作.mkv|1328004580|B7BC8BD27B1AD8A5A1D43E47EFD3B28C|h=KBUCKHKJQPNWZSWMAVU2BDLRSM4H7IBP|/" target="_blank" rel="external">超级无敌掌门狗-人兔的诅咒</a></p>
</li>
<li><p>第77届奥斯卡最佳动画长片（2005）：<a href="ed2k://|file|The.Incredibles.2004.超人总动员.双语字幕.HR-HDTV.AC3.1024X576.x264-人人影视制作.V2.mkv|1848359019|F669872941DE396E5C4B543D00093998|h=54ZKL3GGEADMYHU3QBWWVDSIIKVBHS2R|/" target="_blank" rel="external">超人总动员</a></p>
</li>
<li><p>第76届奥斯卡最佳动画长片（2004）：<a href="ed2k://|file|Finding.Nemo.2003.海底总动员.双语字幕.国英音轨.HR-HDTV.AC3.1024X576.x264-人人影视制作.mkv|1823609402|58d66fdfd69a3b8b6ad16ef752b722ad|h=457m2rl73pet7st7t4pjqmwonqpxzwas|/" target="_blank" rel="external">海底总动员</a></p>
</li>
<li><p>第75届奥斯卡最佳动画长片（2003）：<a href="ed2k://|file|Spirited.Away.2001.千与千寻.国粤日音轨.双语字幕.HR-HDTV.AC3.1024X550.x264-人人影视制作.mkv|2339461922|f169fab09a5f8a1f54cf066e1068d31a|h=zz2i6uhgdezy7f3tfrag4lppg4zqsc4u|/" target="_blank" rel="external">千与千寻</a></p>
</li>
<li><p>第74届奥斯卡最佳动画长片（2002）：<a href="ed2k://|file|Shrek.2001.怪物史莱克.双语字幕.HR-HDTV.AAC.1024X576.x264-YYeTs人人影视.mkv|1393402562|CA0EEB980750D5EFFB6E8F0CB727AD8C|h=INABIQQFAGANNSVI24O65OOMO5H7BMYB|/" target="_blank" rel="external">怪物史瑞克</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;历届奥斯卡最佳动画长片合集下载！！！
    
    </summary>
    
      <category term="谈电影" scheme="http://ex2tron.coding.me/categories/%E8%B0%88%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="奥斯卡" scheme="http://ex2tron.coding.me/tags/%E5%A5%A5%E6%96%AF%E5%8D%A1/"/>
    
      <category term="动画" scheme="http://ex2tron.coding.me/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Brand7 2.0更名&quot;品牌漆&quot;正式上架咯！</title>
    <link href="http://ex2tron.coding.me/2017/11/26/Brand7-2-0%E6%9B%B4%E5%90%8D%E5%93%81%E7%89%8C%E6%BC%86%E6%AD%A3%E5%BC%8F%E4%B8%8A%E6%9E%B6%E5%92%AF%EF%BC%81/"/>
    <id>http://ex2tron.coding.me/2017/11/26/Brand7-2-0更名品牌漆正式上架咯！/</id>
    <published>2017-11-26T11:04:32.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>隔了一年更新，良心都有点痛了( ╯□╰ )<a id="more"></a></p>
<blockquote>
<p><em>示威的人做的不对的话，引起示威的人呢？</em>  ——<a href="https://movie.douban.com/subject/21937445/" target="_blank" rel="external">《辩护人》</a></p>
</blockquote>
<p>当初Brand7写完的时候，一直想写一个关于电影的APP，甚至做出了雏形：MovieBackdrops，可惜，时间不多，事情却很多。前段时间闭关，摸着自己的良心，终于把Brand7更新了一把，来看看更新内容吧：</p>
<p><strong><a href="https://www.microsoft.com/store/productId/9NBLGGH546QC" target="_blank" rel="external">品牌漆</a>（Brand7）是一款Win10 UWP猜品牌的小游戏，里面涵盖了汽车、娱乐、时尚、生活、餐饮、科技、旅游七个类别的550个品牌。Ver2.0.1更新日志如下：</strong></p>
<ol>
<li><p>更名“品牌漆”</p>
</li>
<li><p>全新Logo</p>
</li>
<li><p>全新启动界面</p>
</li>
<li><p>新增50个品牌，现共550个品牌</p>
</li>
<li><p>全面中文版（英文被很多人吐槽看不懂( ╯□╰ )）</p>
</li>
<li><p>界面UI调整</p>
</li>
</ol>
<p><img src="http://pic.ex2tron.top/brand7_v2_comparation.jpg" alt="新旧版对比：中文版"></p>
<p><img src="http://pic.ex2tron.top/brand7_v2_ui.jpg" alt="完成界面"></p>
<p><img src="http://pic.ex2tron.top/brand7_v2_startui.jpg" alt="新的启动界面"></p>
<p><img src="http://pic.ex2tron.top/brand7_v2_share.jpg" alt="分享界面"></p>
<p>可以在Win10应用商店中搜索“品牌漆”进行下载，或<a href="https://www.microsoft.com/store/productId/9NBLGGH546QC" target="_blank" rel="external">点击此处</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;隔了一年更新，良心都有点痛了( ╯□╰ )
    
    </summary>
    
      <category term="Build篇" scheme="http://ex2tron.coding.me/categories/Build%E7%AF%87/"/>
    
    
      <category term="Brand7" scheme="http://ex2tron.coding.me/tags/Brand7/"/>
    
      <category term="品牌漆" scheme="http://ex2tron.coding.me/tags/%E5%93%81%E7%89%8C%E6%BC%86/"/>
    
  </entry>
  
  <entry>
    <title>软件+影视汁源贴(updating...)</title>
    <link href="http://ex2tron.coding.me/2017/11/15/%E8%BD%AF%E4%BB%B6-%E5%BD%B1%E8%A7%86%E6%B1%81%E6%BA%90%E8%B4%B4-updating/"/>
    <id>http://ex2tron.coding.me/2017/11/15/软件-影视汁源贴-updating/</id>
    <published>2017-11-15T11:53:46.000Z</published>
    <updated>2018-03-19T13:59:22.184Z</updated>
    
    <content type="html"><![CDATA[<p>经常有人跟我要一些软件和电影的资源，毕竟我是老司机( ╯□╰ )特此整理，有时间会不断更新。<a id="more"></a></p>
<blockquote>
<p><em>I’ve always believed with hard work and a little bit of luck, it’s only a matter of time before I’m discovered!</em><br><em>我总是相信勤奋与努力外加一点点幸运就能换来成功，我的天分被发现只是时间的问题。</em><br>——<a href="https://movie.douban.com/subject/1793491/" target="_blank" rel="external">《Ratatouille》(《料理鼠王》)</a></p>
</blockquote>
<hr>
<h2 id="软件汁源"><a href="#软件汁源" class="headerlink" title="软件汁源"></a><strong>软件汁源</strong></h2><p>首先列出一些常用网站，后面我只列出常用的软件和官网，<strong>请大家优先选择官网进行下载</strong>，因为官网版本一般都是最新的，也比较安全。官网进不去，可以<strong>点击</strong>我给出的版本下载：</p>
<h3 id="常用资源站"><a href="#常用资源站" class="headerlink" title="常用资源站"></a>常用资源站</h3><ul>
<li><a href="http://mirrors.163.com/" target="_blank" rel="external">网易开源镜像站</a>、<a href="http://npm.taobao.org/" target="_blank" rel="external">淘宝 NPM 镜像站</a></li>
<li><a href="https://www.ithome.com/bibei/" target="_blank" rel="external">Windows装机必备</a>、<a href="https://www.portablesoft.org/" target="_blank" rel="external">精品绿色便携软件</a></li>
<li><a href="http://www.anxz.com/" target="_blank" rel="external">俺下载</a>、<a href="http://www.verycd.gdajie.com/" target="_blank" rel="external">逛电驴</a>、<a href="http://www.ed2000.com/" target="_blank" rel="external">ED2000资源共享</a>、<a href="https://xbeta.info/" target="_blank" rel="external">善用佳软</a></li>
</ul>
<h3 id="微软官方系统"><a href="#微软官方系统" class="headerlink" title="微软官方系统"></a>微软官方系统</h3><ul>
<li>Windows 7 SP1：<a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/" target="_blank" rel="external">32位</a></li>
<li>Windows 10创意者更新秋季版：<a href="ed2k://|file|cn_windows_10_multi-edition_version_1709_updated_sept_2017_x64_dvd_100090804.iso|4740610048|37051C54894776826823DAEBDD03F1DC|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|cn_windows_10_multi-edition_version_1709_updated_sept_2017_x86_dvd_100090805.iso|3551899648|6C24A796B66CDA6D909508A16C74B406|/" target="_blank" rel="external">32位</a></li>
<li>激活工具：<a href="https://pan.baidu.com/s/1i45IaSt" target="_blank" rel="external">优先OEM10 密码：c6wz</a></li>
</ul>
<h3 id="Office办公套件"><a href="#Office办公套件" class="headerlink" title="Office办公套件"></a>Office办公套件</h3><ul>
<li>2016：<a href="ed2k://|file|SW_DVD5_Office_Professional_Plus_2016_64Bit_ChnSimp_MLF_X20-42426.ISO|1123452928|31087A00FF67D4F5B4CBF4AA07C3433B|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|SW_DVD5_Office_Professional_Plus_2016_W32_ChnSimp_MLF_X20-41351.ISO|986441728|2DE74581C10096137481873B3AD57D43|/" target="_blank" rel="external">32位</a> Visio：<a href="ed2k://|file|SW_DVD5_Visio_Pro_2016_64Bit_ChnSimp_MLF_X20-42759.ISO|714913792|FC930AB97B366B3595FC2F28ABAC2A6F|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|SW_DVD5_Visio_Pro_2016_W32_ChnSimp_MLF_X20-41580.ISO|609447936|91EB248558F236AA66D234EA03FAD9A9|/" target="_blank" rel="external">32位</a></li>
<li>2013：<a href="ed2k://|file|cn_office_professional_plus_2013_with_sp1_x64_dvd_3921920.iso|980258816|E18C9CF896D65B2778AA1A44C922C377|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|cn_office_professional_plus_2013_with_sp1_x86_dvd_3921919.iso|858245120|EA50FF2DE78488DF2646D66FA791164A|/" target="_blank" rel="external">32位</a> Visio：<a href="ed2k://|file|cn_visio_professional_2013_with_sp1_x64_3910821.exe|566078120|238DBAB9F597E05EB93C06229AF3A57B|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|cn_visio_professional_2013_with_sp1_x86_3910886.exe|475819680|4B6A240FCB9C31D4C86EF408D235779E|/" target="_blank" rel="external">32位</a> </li>
<li>2010：<a href="ed2k://|file|SW_DVD5_Office_Professional_Plus_2010w_SP1_64Bit_ChnSimp_CORE_MLF_X17-76742.iso|1612515328|032320121E0EE36D8F0C32EC89CA0AB9|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|SW_DVD5_Office_Professional_Plus_2010w_SP1_W32_ChnSimp_CORE_MLF_X17-76734.iso|1412091904|79B75EE3F629A1BD925E6C0AEFDECA10|/" target="_blank" rel="external">32位</a> Visio：<a href="ed2k://|file|SW_DVD5_Visio_Premium_2010w_SP1_64Bit_ChnSimp_Std_Pro_Prem_MLF_X17-75849.iso|770732032|B0BFCB2BA515B4A55936332FBD362844|/" target="_blank" rel="external">64位</a>、<a href="ed2k://|file|SW_DVD5_Visio_Premium_2010w_SP1_W32_ChnSimp_Std_Pro_Prem_MLF_X17-75847.iso|674627584|9945A8591D1B2D185656B5B3DC2CA24B|/" target="_blank" rel="external">32位</a></li>
<li>2016即点即用版：<a href="ed2k://|file|cn_office_professional_plus_2016_x86_x64_dvd_6969182.iso|2588266496|27EEA4FE4BB13CD0ECCDFC24167F9E01|/" target="_blank" rel="external">Office</a>、<a href="ed2k://|file|cn_visio_professional_2016_x86_x64_dvd_6970929.iso|2588262400|52A997F3AF4E40B896C8E4677CF10E90|/" target="_blank" rel="external">Visio</a></li>
<li>激活工具：<a href="https://pan.baidu.com/s/1i45IaSt" target="_blank" rel="external">优先OEM10 密码：c6wz</a></li>
</ul>
<h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><ul>
<li>树莓派系统：<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="external">官网</a>、<a href="http://vx2-downloads.raspberrypi.org/raspbian/images/raspbian-2017-12-01/2017-11-29-raspbian-stretch.zip" target="_blank" rel="external">Rasbian 2017 Desktop</a></li>
<li>Ubuntu：<a href="https://www.ubuntu.com/download" target="_blank" rel="external">官网</a>、桌面版：<a href="http://mirrors.nju.edu.cn/ubuntu-releases/16.04.3/ubuntu-16.04.3-desktop-amd64.iso" target="_blank" rel="external">16.04 64位</a>、<a href="http://mirrors.nju.edu.cn/ubuntu-releases/17.10/ubuntu-17.10-desktop-amd64.iso" target="_blank" rel="external">17.10 64位</a></li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul>
<li>Qt：<a href="http://download.qt.io/archive/qt/" target="_blank" rel="external">官网</a>、<a href="http://download.qt.io/archive/qt/5.8/5.8.0/qt-opensource-windows-x86-mingw530-5.8.0.exe" target="_blank" rel="external">5.8.0 mingw</a></li>
<li>Android Studio：<a href="http://www.android-studio.org/" target="_blank" rel="external">中文社区</a>、<a href="https://dl.google.com/dl/android/studio/install/3.0.0.18/android-studio-ide-171.4408382-windows.exe" target="_blank" rel="external">3.0</a>、<a href="https://dl.google.com/dl/android/studio/install/2.3.3.0/android-studio-bundle-162.4069837-windows.exe" target="_blank" rel="external">2.3.3</a></li>
<li>Visual Studio 2017：<a href="https://www.visualstudio.com/" target="_blank" rel="external">官网</a>、<a href="https://download.visualstudio.microsoft.com/download/pr/100266676/045b56eb413191d03850ecc425172a7d/vs_Community.exe" target="_blank" rel="external">社区版15.4</a></li>
<li>Matlab R2017a：<a href="ed2k://|file|[矩阵实验室].R2017a_win64_dvd1.iso|7829774336|b0ed2efeac2af78ce1f797152d8b430a|h=xbq3qn6r6uztxdawcdzgimpzqmcxy3nh|/" target="_blank" rel="external">x64 dvd1</a>、<a href="ed2k://|file|[矩阵实验室].R2017a_win64_dvd2.iso|2707779584|ce396df6ebc36a94118a736338d7e05e|h=34xjg5hg77ldbsgf6j64evexssys2hm3|/" target="_blank" rel="external">x64 dvd2</a>、<a href="ed2k://|file|[矩阵实验室].Crack.rar|957381|725c8700b78027809055ecb5e6986b59|h=rf5lftd7ffdm4dhk3qn5m5ke2zxugztk|/" target="_blank" rel="external">破解工具</a></li>
<li>Octave：<a href="www.gnu.org/software/octave/">官网</a>、<a href="https://ftp.gnu.org/gnu/octave/windows/octave-4.2.2-w64-installer.exe" target="_blank" rel="external">4.2.2_x64</a>、<a href="https://ftp.gnu.org/gnu/octave/windows/octave-4.2.2-w32-installer.exe" target="_blank" rel="external">4.2.2_x86</a></li>
<li>Python：<a href="https://www.python.org/downloads/" target="_blank" rel="external">官网</a>、<a href="https://www.python.org/ftp/python/3.6.4/python-3.6.4-amd64.exe" target="_blank" rel="external">3.6.4 x64</a>、<a href="https://www.python.org/ftp/python/2.7.14/python-2.7.14.amd64.msi" target="_blank" rel="external">2.7.14 x64</a></li>
<li>Python包源（如Tensorflow）：<a href="https://pypi.python.org/pypi" target="_blank" rel="external">源1</a>、<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">源2</a></li>
<li>Anaconda：<a href="https://www.anaconda.com/download/" target="_blank" rel="external">官网</a>、<a href="https://repo.continuum.io/archive/Anaconda3-5.1.0-Windows-x86_64.exe" target="_blank" rel="external">5.1.0_cp36_x64</a>、<a href="https://repo.continuum.io/archive/Anaconda3-5.1.0-Windows-x86.exe" target="_blank" rel="external">5.1.0_cp36_x86</a></li>
<li>OpenCV：<a href="https://opencv.org/releases.html" target="_blank" rel="external">官网</a>、<a href="https://ncu.dl.sourceforge.net/project/opencvlibrary/opencv-win/3.3.1/opencv-3.3.1-vc14.exe" target="_blank" rel="external">3.3.1</a>、<a href="https://sourceforge.net/settings/mirror_choices?projectname=opencvlibrary&amp;filename=opencv-win/2.4.13/opencv-2.4.13.4-vc14.exe" target="_blank" rel="external">2.4.13</a> | <a href="https://pypi.python.org/pypi/opencv-python/" target="_blank" rel="external">OpenCV-Python</a></li>
<li>MySQL：<a href="https://www.mysql.com/" target="_blank" rel="external">官网</a>、<a href="https://cdn.mysql.com//Downloads/MySQLInstaller/mysql-installer-community-5.7.20.0.msi" target="_blank" rel="external">MySQL Installer 5.7.20</a></li>
<li>Navicat11 for MySQL：<a href="https://pan.baidu.com/s/1o8dyBxS" target="_blank" rel="external">11.2 密码：ls2c</a></li>
<li>WampServer：<a href="http://www.wampserver.com/en/" target="_blank" rel="external">官网</a>、<a href="https://jaist.dl.sourceforge.net/project/wampserver/WampServer%203/WampServer%203.0.0/wampserver3.1.0_x64.exe" target="_blank" rel="external">3.1.0 x64</a>、<a href="https://jaist.dl.sourceforge.net/project/wampserver/WampServer%203/WampServer%203.0.0/wampserver3.1.0_x86.exe" target="_blank" rel="external">3.1.0 x86</a></li>
<li>代码编辑器： </li>
<li><a href="https://code.visualstudio.com/Download" target="_blank" rel="external">VS Code</a>：<a href="https://vscode.cdn.azure.cn/stable/9a199d77c82fcb82f39c68bb33c614af01c111ba/VSCodeSetup-x64-1.21.0.exe" target="_blank" rel="external">1.21_x64</a>、<a href="https://vscode.cdn.azure.cn/stable/9a199d77c82fcb82f39c68bb33c614af01c111ba/VSCodeSetup-ia32-1.21.0.exe" target="_blank" rel="external">1.21_x86</a> | <a href="https://notepad-plus-plus.org/download/" target="_blank" rel="external">Notepad++</a>：<a href="https://notepad-plus-plus.org/repository/7.x/7.5.3/npp.7.5.3.Installer.exe" target="_blank" rel="external">7.5.3</a> | <a href="https://www.sublimetext.com/3" target="_blank" rel="external">Sublime</a></li>
<li>Typora(Markdown编写)：<a href="https://www.typora.io/" target="_blank" rel="external">官网(需翻墙)</a>、<a href="https://www.typora.io/windows/typora-setup-x64.exe?" target="_blank" rel="external">64位</a>、<a href="https://www.typora.io/windows/typora-setup-ia32.exe?" target="_blank" rel="external">32位</a></li>
<li>开发组件：<a href="http://www.sudt.com/cn/ap/download.htm" target="_blank" rel="external">串口抓包AccessPort</a>：<a href="http://www.sudt.com/download/AccessPort137.zip" target="_blank" rel="external">1.37</a> | <a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">protobuf</a> | <a href="http://ffmpeg.org/download.html" target="_blank" rel="external">ffmpeg</a></li>
<li>爬虫驱动：</li>
<li><a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="external">Firefox Geckodriver</a> | <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/" target="_blank" rel="external">MicrosoftWebDriver</a> | <a href="https://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="external">ChromeDriver</a>、<a href="http://blog.csdn.net/cz9025/article/details/70160273" target="_blank" rel="external">各版本对照表</a></li>
</ul>
<h3 id="微软库"><a href="#微软库" class="headerlink" title="微软库"></a>微软库</h3><ul>
<li>Microsoft Visual C++：<ul>
<li>2005：<a href="http://download.microsoft.com/download/5/2/1/5212066c-5f48-4b16-a059-ed84b505a65d/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/5/2/1/5212066c-5f48-4b16-a059-ed84b505a65d/vcredist_x86.exe" target="_blank" rel="external">x64</a> 2005 SP1：<a href="http://download.microsoft.com/download/7/9/8/798325b7-8993-4ef9-9148-8db9ff4187fc/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/7/5/2/7521765a-7b4f-4656-a439-dd0de12b35ea/vcredist_x64.exe" target="_blank" rel="external">x64</a></li>
<li>2008：<a href="http://download.microsoft.com/download/7/5/0/7502f4e9-1f90-4895-9259-1bde67b8b9a1/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/2/b/e/2bec4780-6f99-4347-ad31-48d4b46ab1d3/vcredist_x64.exe" target="_blank" rel="external">x64</a> 2008 SP1：<a href="http://download.microsoft.com/download/5/9/e/59e74271-2b59-49a1-b955-96b69cc34f38/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/b/d/e/bde0381b-20e2-4631-a5f4-aa72111a23d8/vcredist_x64.exe" target="_blank" rel="external">x64</a></li>
<li>2010：<a href="http://download.microsoft.com/download/5/B/C/5BC5DBB3-652D-4DCE-B14A-475AB85EEF6E/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/3/2/2/3224B87F-CFA0-4E70-BDA3-3DE650EFEBA5/vcredist_x64.exe" target="_blank" rel="external">x64</a> 2010 SP1：<a href="http://download.microsoft.com/download/C/6/D/C6D0FD4E-9E53-4897-9B91-836EBA2AACD3/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/A/8/0/A80747C3-41BD-45DF-B505-E9710D2744E0/vcredist_x64.exe" target="_blank" rel="external">x64</a></li>
<li>2012 Update1：<a href="http://download.microsoft.com/download/9/C/D/9CD480DC-0301-41B0-AAAB-FE9AC1F60237/VSU1/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/9/C/D/9CD480DC-0301-41B0-AAAB-FE9AC1F60237/VSU1/vcredist_x64.exe" target="_blank" rel="external">x64</a> 2013：<a href="http://download.microsoft.com/download/F/3/5/F3500770-8A08-488E-94B6-17A1E1DD526F/vcredist_x86.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/F/3/5/F3500770-8A08-488E-94B6-17A1E1DD526F/vcredist_x64.exe" target="_blank" rel="external">x64</a></li>
<li>2015：<a href="https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x86.exe" target="_blank" rel="external">x86</a>、<a href="https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe" target="_blank" rel="external">x64</a></li>
</ul>
</li>
<li>Microsoft .NET Framework：<ul>
<li>2.0：<a href="http://download.microsoft.com/download/5/6/7/567758a3-759e-473e-bf8f-52154438565a/dotnetfx.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/a/3/f/a3f1bf98-18f3-4036-9b68-8e6de530ce0a/NetFx64.exe" target="_blank" rel="external">x64</a> 3.5：<a href="http://download.microsoft.com/download/7/0/3/703455ee-a747-4cc8-bd3e-98a615c3aedb/dotNetFx35setup.exe" target="_blank" rel="external">x86</a> 3.5 SP1：<a href="http://download.microsoft.com/download/0/6/1/061F001C-8752-4600-A198-53214C69B51F/dotnetfx35setup.exe" target="_blank" rel="external">x86</a>、<a href="http://download.microsoft.com/download/2/0/E/20E90413-712F-438C-988E-FDAA79A8AC3D/dotnetfx35.exe" target="_blank" rel="external">完整版</a></li>
<li>4：<a href="http://download.microsoft.com/download/9/5/A/95A9616B-7A37-4AF6-BC36-D6EA96C8DAAE/dotNetFx40_Full_x86_x64.exe" target="_blank" rel="external">x86/x64</a>、<a href="http://www.microsoft.com/zh-cn/download/confirmation.aspx?id=17718" target="_blank" rel="external">完整版</a> 4.5：<a href="http://download.microsoft.com/download/B/A/4/BA4A7E71-2906-4B2D-A0E1-80CF16844F5F/dotNetFx45_Full_setup.exe" target="_blank" rel="external">x86/x64</a>、<a href="http://download.microsoft.com/download/b/a/4/ba4a7e71-2906-4b2d-a0e1-80cf16844f5f/dotnetfx45_full_x86_x64.exe" target="_blank" rel="external">完整版</a> 4.5.1：<a href="http://download.microsoft.com/download/7/4/0/74078A56-A3A1-492D-BBA9-865684B83C1B/NDP451-KB2859818-Web.exe" target="_blank" rel="external">x86/x64</a>、<a href="http://download.microsoft.com/download/1/6/7/167F0D79-9317-48AE-AEDB-17120579F8E2/NDP451-KB2858728-x86-x64-AllOS-ENU.exe" target="_blank" rel="external">完整版</a></li>
</ul>
</li>
</ul>
<h3 id="媒体设计"><a href="#媒体设计" class="headerlink" title="媒体设计"></a>媒体设计</h3><ul>
<li>Adobe CC 2017(Photoshop/Audition/Premiere)：<a href="http://pan.baidu.com/s/1eRNym9W" target="_blank" rel="external">精简版 密码：f7yt</a></li>
</ul>
<h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><ul>
<li>Lantern蓝灯翻墙：<a href="https://raw.githubusercontent.com/getlantern/lantern-binaries/master/lantern-installer.exe" target="_blank" rel="external">最新版</a>、<a href="https://github.com/getlantern/mirror" target="_blank" rel="external">官网</a></li>
<li>我平常整理的一些实用工具：<a href="https://pan.baidu.com/s/1pLwsEUZ" target="_blank" rel="external">密码：806j</a></li>
</ul>
<h2 id="影视汁源"><a href="#影视汁源" class="headerlink" title="影视汁源"></a><strong>影视汁源</strong></h2><h3 id="资源站"><a href="#资源站" class="headerlink" title="资源站"></a>资源站</h3><ul>
<li><a href="http://6vhao.com/" target="_blank" rel="external">6v电影网</a>、<a href="http://www.dytt8.net/" target="_blank" rel="external">电影天堂</a>、<a href="http://www.80s.tw/" target="_blank" rel="external">80s电影网</a></li>
<li><a href="http://www.zimuzu.tv/" target="_blank" rel="external">字幕组（原人人影视）</a>、<a href="http://www.ed2000.com/" target="_blank" rel="external">ED2000资源共享</a>、<a href="http://www.piaohua.com/" target="_blank" rel="external">飘花电影网</a></li>
</ul>
<h3 id="电影榜单"><a href="#电影榜单" class="headerlink" title="电影榜单"></a>电影榜单</h3><ul>
<li>IMDB电影排行榜：<a href="http://www.imdb.com/chart/top" target="_blank" rel="external">TOP250</a>、豆瓣电影排行榜：<a href="https://movie.douban.com/top250" target="_blank" rel="external">TOP250</a></li>
<li>全球电影票房排行榜：<a href="https://www.douban.com/doulist/1641439/" target="_blank" rel="external">中文版</a>、<a href="http://www.boxofficemojo.com/alltime/world/" target="_blank" rel="external">英文版</a></li>
</ul>
<h3 id="电影合集"><a href="#电影合集" class="headerlink" title="电影合集"></a>电影合集</h3><ul>
<li><a href="/2017/12/05/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91%E6%BC%AB%E5%A8%81%E5%AE%87%E5%AE%99%E7%94%B5%E5%BD%B1%E5%90%88%E9%9B%86/">漫威电影合集</a>、<a href="/2017/12/05/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91007%E7%94%B5%E5%BD%B1%E5%90%88%E9%9B%86/">007电影合集</a></li>
<li><a href="/2017/09/24/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91%E8%AF%BA%E5%85%B0%E7%A5%9E%E4%BD%9C%E9%9B%86/">诺兰电影合集</a>、<a href="/2017/12/05/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91%E5%8E%86%E5%B1%8A%E5%A5%A5%E6%96%AF%E5%8D%A1%E6%9C%80%E4%BD%B3%E5%8A%A8%E7%94%BB%E9%95%BF%E7%89%87%E9%9B%86/">历届奥斯卡最佳动画长片合集</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常有人跟我要一些软件和电影的资源，毕竟我是老司机( ╯□╰ )特此整理，有时间会不断更新。
    
    </summary>
    
      <category term="谈电影" scheme="http://ex2tron.coding.me/categories/%E8%B0%88%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="软件" scheme="http://ex2tron.coding.me/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="影视" scheme="http://ex2tron.coding.me/tags/%E5%BD%B1%E8%A7%86/"/>
    
  </entry>
  
  <entry>
    <title>计量史：时间之旅</title>
    <link href="http://ex2tron.coding.me/2017/11/08/%E8%AE%A1%E9%87%8F%E5%8F%B2%EF%BC%9A%E6%97%B6%E9%97%B4%E4%B9%8B%E6%97%85/"/>
    <id>http://ex2tron.coding.me/2017/11/08/计量史：时间之旅/</id>
    <published>2017-11-08T13:35:51.000Z</published>
    <updated>2017-12-20T09:20:00.129Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章也是我一年前研一《计量史》课上的小论文，感觉不错，也放在博客上，哈哈。<a id="more"></a></p>
<blockquote>
<p><em>Whoever find a friend, find a treasure.</em>  ——<a href="https://movie.douban.com/subject/3036478/" target="_blank" rel="external">《Cars2》</a><br><br><em>一个朋友，一个宝。</em>——<a href="https://movie.douban.com/subject/3036478/" target="_blank" rel="external">《汽车总动员2》</a></p>
</blockquote>
<p>宇宙大爆炸的那一刻就注定了这个世界充满着平凡与不平凡，宇宙的变迁、星云的诞生，看似杂乱无章但又井然有序，一切都注入了时间的长河中。而随着一个奇迹：生命的诞生，人类意识、情感的快速升华，人类开始认识到了“时间”，并随着时间的流逝，逐渐认识这个世界。通过自然界的周期现象——日出日落，季节的轮换，潮汐的涨落，来有意识地进行活动。于是，当我们尝试去考量时间的时候，就促使了时间计量产生。作为《时间之谜》的阅读报告，我摘录了一部分原书材料来表述时间计量的科学演变，最后结合自己的经历和见识表达了自己对科学研究和时间计量意义的一些想法。</p>
<p>时间，从来就不是一个很好形容或定义的概念。每当我们想去探讨它时，总会陷入困境，就像有人让你解释你是怎么走路的一样。《时间之谜》 从实用和客观的角度探讨了时间计量的科学演变。通过人们尝试对时间进行测定的手段、时间的使用以及时间对于数学、物理学、天文学的影响等各种客观事实材料，来启发我们对于时间的思考。</p>
<hr>
<h2 id="I-“时间”的科学演变"><a href="#I-“时间”的科学演变" class="headerlink" title="I. “时间”的科学演变"></a>I. “时间”的科学演变</h2><p>如今，科学一词早已被大众所认知，并赋予崇高的含义。我想大多数人孩童时候的梦想就是成为一名科学家。而Science一词最早出现在19世纪，像牛顿当时被称为自然哲学家，而非科学家。可以看出，科学溯源于大自然规律的必然性。那么“时间”从哪儿来的呢？</p>
<p>远古人民往往利用自然界的周期现象——日出日落，季节轮换，甚至潮汐的涨落来进行着人类的日常生活。我小时候在家乡的时候，就是鸡鸣时刻起床，黄昏时刻结束农耕作业。不同于现在城市的生活，那时的我们并不会过分关注具体的“钟表时间”。这种主导人们规律作息生活的自然之力，无疑引起了远古人们对它的神秘、畏惧和崇拜之感。于是，人们内心的欲望和探索心理驱动着我们去开始去关心天文和自然。</p>
<p>然而时间不同于长度、质量或温度，<em>“我们能辨别距离，感受到重量和温度，但人体的任何感官都不能感知时间，我们见不到它，听不到它，嗅不到它，也尝不到它，而只能通过意识，或者通过观测它的效应来理解它。”</em>（《时间之谜》）观测，这就是最开始单纯的“自然界的钟”的产生，也就是通过有意识地观测太阳、月亮和星星的这种大的、显式的运动，来确立时间的原型。之后人们认识到了运动的规律，产生了能否利用以恒定速率运转物体的时间间隔来对时间单位进行计数的问题，于是便有了“钟”。中国古代出现的利用水的推动力造的水钟、十四世纪出现的利用重锤驱动的机械钟以及惠更斯研制的摆钟等等都是探索过程中朝着精密性、易用性的改进。随着人们对自然界的深入了解，特别是对电、磁和物质的原子结构的了解，诸如石英钟、原子钟等一些新的方案得以发展和实现。</p>
<p>现在再去回顾历史，很容易就可以看出时间计量对工业、科学研究和当今世界诸多事务的影响。约翰•哈里逊时钟克服了海洋的颠簸、温度变化和咸水的溅射，大大改善了船只导航。对晶体谐振频率的研究有了如今改变世界的半导体。从“定性上的为什么”到“定量上的多准确”的科学演变，促使了精密测量的需求，进而影响到了数学、物理学、天文学……那么如今的我们需要再去思考“时间”吗？</p>
<h2 id="II-阿尔法到欧米伽（始与终）"><a href="#II-阿尔法到欧米伽（始与终）" class="headerlink" title="II. 阿尔法到欧米伽（始与终）"></a>II. 阿尔法到欧米伽（始与终）</h2><p>太过普世、默会的科学往往会被我们所忽略掉。拿起杯子喝口水，对于人来说，无疑再简单不过，但如果要造一个可以端起杯子喝水的机器人呢？显然，这是一个相对有难度并且复杂的任务，其中所涉及到的运动学、控制学、人体工程学等等科学知识都不是随便说说那么简单。因此，回溯历史能够使我们对那些在日常生活中扮演着最基本角色的事物产生认知，并进一步引领我们去思考。时间，它就扮演着使得人类的一切活动有秩序、有组织地进行着的角色。我想试图去了解时间，可以帮助我们更好的规划工作和生活。</p>
<p>虽然当今社会的物质财富已经相对丰富，但大多数人却丧失了求真求知，我们经常被当下的现实琐碎问题所困。这种局限使得人们疲于现实，而缺少创造和求知的勇气。假设我们可以做一次时间的旅行，<em>“水母、鳄鱼胚胎、星云、犹他州的峡谷和木卫三；第一缕生命的信号、细菌、细胞起源、初恋感觉、意识诞生、人类进化、生与死。”</em>（纪录片《<a href="https://baike.baidu.com/item/时间之旅/4524703" target="_blank" rel="external">时间之旅</a>》）从宇宙大爆炸的那一刻开始到人类高级智慧的诞生，就注定了人类在漫漫时间长河中探索和认识这个世界的过程。在这个漫长的过程中，时间见证了无数人的探索求真精神，有始有终，从阿尔法到欧米伽，驱动着人类的进步。</p>
<p>我想时间就是一个很好的例子，来溯源支配当今社会行为准则的起源与内涵。正如同天平这种衡器的诞生以及后人对它的不断改进与完善，就是人们对公平与公正追求的一种体现。这种以此来扩充我们见识的过程，有助于锻炼我们的思维，突破一些困扰我们的现实问题，尝试新思路，并最终试图解决我们一直在思考的问题：自我存在。起码这种思维方法对我自己很有帮助：我是工作后考的研究生。考研期间，我没有用智能手机，由于一个人很难坚持下来，于是尝试每天早上7：15到7：45期间用静坐的方式来保持心态的平和。这种方法却意外之外了我的一笔人生财富，因为静坐的时候，我会尝试去想一些平静的事，慢慢地就会回忆起那些很久之前早就遗忘的事情。我想那个时候我就在进行着一趟回溯自己的时间之旅。每件事，好的，坏的都有始有终，总会过去，自己的心态也就变得好起来。静坐之后，洗漱完，8点准时出发，开始一天的学习生活……到现在读研期间，我依旧保持了考研时的一些习惯。</p>
<h2 id="III-结束语"><a href="#III-结束语" class="headerlink" title="III. 结束语"></a>III. 结束语</h2><p>正如同泰伦斯•马力克执导的纪录片《<a href="https://baike.baidu.com/item/时间之旅/4524703" target="_blank" rel="external">时间之旅</a>》所传达的哲学信息：“<strong>如果你在寻找上帝，仔细观察时间的一切就够了。</strong>”我想这就是时间对我们个体的意义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章也是我一年前研一《计量史》课上的小论文，感觉不错，也放在博客上，哈哈。
    
    </summary>
    
      <category term="五味杂粮" scheme="http://ex2tron.coding.me/categories/%E4%BA%94%E5%91%B3%E6%9D%82%E7%B2%AE/"/>
    
    
      <category term="计量" scheme="http://ex2tron.coding.me/tags/%E8%AE%A1%E9%87%8F/"/>
    
      <category term="时间之旅" scheme="http://ex2tron.coding.me/tags/%E6%97%B6%E9%97%B4%E4%B9%8B%E6%97%85/"/>
    
  </entry>
  
  <entry>
    <title>摄影之魅：瞬间是一面&quot;镜子&quot;</title>
    <link href="http://ex2tron.coding.me/2017/11/08/%E6%91%84%E5%BD%B1%E4%B9%8B%E9%AD%85%EF%BC%9A%E7%9E%AC%E9%97%B4%E6%98%AF%E4%B8%80%E9%9D%A2%E9%95%9C%E5%AD%90/"/>
    <id>http://ex2tron.coding.me/2017/11/08/摄影之魅：瞬间是一面镜子/</id>
    <published>2017-11-08T12:56:32.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章其实是我一年前研一《摄影艺术》课上的小论文，感觉写的还行，放在博客上。<a id="more"></a></p>
<blockquote>
<p><em>Not everyone can become a great artist, but a great artist can come from anywhere.</em>  ——<a href="https://movie.douban.com/subject/1793491/" target="_blank" rel="external">《Ratatouille》</a><br><br><em>并非是谁都能成为伟大的艺术家，不过伟大的艺术家却可能来自任何角落。</em>——<a href="https://movie.douban.com/subject/1793491/" target="_blank" rel="external">《料理鼠王》</a></p>
</blockquote>
<p>19世纪30年代末期，<a href="https://baike.baidu.com/item/达盖尔" target="_blank" rel="external">达盖尔</a>发明银版照相法，<a href="https://baike.baidu.com/item/尼埃普斯" target="_blank" rel="external">尼埃普斯</a>拍摄了世界上第一张照片，影像开始可以被记录下来。<a href="https://baike.baidu.com/item/卢米埃尔兄弟" target="_blank" rel="external">卢米埃尔兄弟</a>在《<a href="https://baike.baidu.com/item/火车进站/7413603" target="_blank" rel="external">火车进站</a>》中开启了24帧的艺术之旅——“电影”。如今，影像无处不在，传递着无穷无尽、千变万化的讯息。这一切都源于定格影像的瞬间——摄影术的独特魅力。</p>
<hr>
<h2 id="I-艺术源于生活、艺术高于生活"><a href="#I-艺术源于生活、艺术高于生活" class="headerlink" title="I. 艺术源于生活、艺术高于生活"></a>I. 艺术源于生活、艺术高于生活</h2><p>在选修“摄影艺术”这门课程之前，我刚刚入手了一款入门级单反：宾得PENTAX K-50。本着对摄影的爱好，在入手单反之前就经常用手机去拍一些小东西。所以，理所当然，选修这门课程就是希望自己能够拍出“好看”的照片，即追求表意上的拍摄技法。最初，刚接触摄影的我迫切想积累诸如快门、光圈、感光度、景深、构图等等各种专业术语。不可否认的是，这种“量”的层面上的堆积确实有助于提升拍摄认知和水平，但往往会也会束缚我们，缺少创造力、缺少对摄影“质”的理解。自己对摄影的认知也停留在肤浅的“这张照片拍的好，但说不出所以然来”上面。很高兴，这门课程改变了我的很多想法。</p>
<p>人是爱“美”的。如今，拍照是一件及其简单的事。一方面，得益于智能手机的发展，我们只需要按下手机上的拍照按钮，就会捕获一张照片，接近零成本。另一方面，由于拍摄的简便性，对生活中事物的记录变得极其频繁，这某种程度上降低了我们独立思考和赏析的能力。我们往往会赞美一张“好看”的照片，被照片所表现出来的第一观感所牵引，有些人虽然会对拍摄的技法做一些分析，获取经验，但却极少表达对照片的理解。并且，这些赞美和分析通常都只是建立在一张“美”的照片上。之所以强调了多次“美”的照片，是因为摄影不仅仅只是最终呈现出的照片的观感，摄影更多的含义是一个过程，这一过程的目的往往是真实地或艺术地反映出现实，并表现出拍摄者的情感寄托。当然，摄影术发明的目的就是代替画像，它源于生活，更是高于生活，因此，摄影是个庞杂的体系，前面的理解或许只是一种粗浅的认识。对于不同的摄影类别，诸如纪实摄影、风光摄影、商业时尚摄影等等，摄影都有不同的目的和表现方式，但摄影本身又是绝对的自由，它代表这一种艺术、创造力和想象力。</p>
<p>规则是用来打破的，但打破规则之前，我们必需清楚这个规则。得益于课堂之上邱老师介绍的各类摄影大师以及他们的作品，我了解了很多摄影的历史和大师级摄影师的风格。他们能够在摄影史上留下名字，通常都是某种风格的开创者，有着自己个性鲜明的摄影语言并对一个时代产生深远的影响。</p>
<h2 id="II-以小见大，“决定性瞬间”——布列松"><a href="#II-以小见大，“决定性瞬间”——布列松" class="headerlink" title="II. 以小见大，“决定性瞬间”——布列松"></a>II. 以小见大，“决定性瞬间”——布列松</h2><blockquote>
<p>“摄影这一门，你进去时是ABC，出来时是HCB（Henri Cartier-Bresson：亨利·卡蒂埃·布列松）”——《日本摄影》杂志。</p>
</blockquote>
<p><img src="http://pic.ex2tron.top/cartier_bresson_photo1.png" alt="图1 布列松本人及其作品&lt;雕塑家贾柯米蒂&gt;"></p>
<p>其实，对于一位被冠以“他的摄影定义了20世纪”、“新闻摄影之父”称号的大师级摄影师来说，无需多言。然而<a href="https://baike.baidu.com/item/布列松" target="_blank" rel="external">布列松</a>提出的“决定性瞬间”的摄影艺术确确实实让我略微滤清了以往杂乱无章的“瞬间”摄影认知。在此之前，我一直很崇尚抓拍。可能是因为最初自己并不是特别了解一些摄影技法，在拍摄一些故事性很强的场景时，拍出的照片通常描述或还原不了那一时刻的故事。很多时候，摆拍的人物表情很不自然，一般也表现不出很强的故事性。“决定性瞬间”：“在一秒钟的很小一部分中，以一种精确的形式呈现出某一事件的重要性，使它成为这一事件的最恰当的描述。”布列松的作品总是恰到好处地抓住了事件最微妙的一瞬间。这或许与他自身的经历大大相关。</p>
<p>布列松曾前往法国的非洲殖民地科特迪瓦并以打猎为主。在打猎的过程中，他形成了贯穿他一生的摄影技巧——准备，等待，等待，等待…，最后扣动扳机（按下快门）。这一过程，造就了布列松面对巨大压力之下的沉着和冷静。他的作品就仿佛一直等在主体那里拍摄这一场景一般，这均得益于布列松的耐心、完美的拍摄时刻和一种无人可以匹敌的直觉。</p>
<p><img src="http://pic.ex2tron.top/cartier_bresson_photo2.png" alt="图2 布列松作品:&lt; 布列松习作&gt;（左）、&lt;“决定性瞬间”的美学&gt;（右，前景中跳跃的男子与背后的跳跃女郎互相呼应）"></p>
<p>《<a href="https://baike.baidu.com/item/布列松习作" target="_blank" rel="external">布列松习作</a>》(上图)作为布列松的一幅名作，一方面以其娴熟的抓拍功底丰富而自然地表现出拍摄瞬间的故事性：小男孩情绪十分自然，踌躇满志的抱着两个大酒瓶回家，身后的小女孩也投来羡慕的目光…另一方面，这幅作品也很好的体现了布列松的摄影理念：“不论一幅作品技术多么到位，画面多么“好看”，如果它远离了爱，远离了对人类的理解，远离了对人类命运的认知，那么它一定不是一件成功的作品。”布列松的镜头虽然对准的是现实小场景，但他的立意高远，致力于以小见大，“最小的事物可以成为伟大的主题”。</p>
<h2 id="III-瞬间是一面“镜子”"><a href="#III-瞬间是一面“镜子”" class="headerlink" title="III. 瞬间是一面“镜子”"></a>III. 瞬间是一面“镜子”</h2><p><img src="http://pic.ex2tron.top/cartier_bresson_photo3.png" alt="图3 &lt;饥饿的苏丹&gt;(上)、&lt;时代广场的胜利之日&gt;(下)"></p>
<p>摄影大师的作品中往往呈现出非常鲜明的个性特征，赋予了其作品与众不同的表现力和故事性。摄影师在按下快门的那一刻，CCD/CMOS上接收的那些信号就变成了一张转瞬即逝一瞬间的记录。通常，摄影师抓拍的那一刻场景，很难再去复现，再加之摄影师独特的拍摄手法和艺术风格，使得每一张照片都变得独一无二，这也是瞬间反映的价值所在。因此，当我们去鉴赏这些作品、这些瞬间时，我们会被其表现出的感染力所吸引，《<a href="https://baike.baidu.com/item/饥饿的苏丹" target="_blank" rel="external">饥饿的苏丹</a>》带给我们巨大的震撼，《<a href="https://baike.baidu.com/item/时代广场之吻" target="_blank" rel="external">时代广场的胜利</a>》让我们体验到二战胜利的狂喜……。当然很多作品所表现出来的往往并不是“好看”的第一观感，它就如同一面可以窥视我们人类、社会、自然各种善恶丑美的镜子。直面这样的一面镜子，我们不免会产生强烈的情感冲击，因为这样的作品并不是单纯的、好看的、无意义的，而是承载着某些人文情怀和哲学思考。当我们深刻去理解它的时候，理所当然就会被其所揭示的内在所折服。</p>
<p>不过，摄影终归是自由的表现力、创造力的象征，这也是摄影术的魅力所在。我们需要不断学习和模仿经典作品的拍摄，但却不能有所束缚，当深刻地了解了这些规则后，就可以尝试打破这些规则，形成自己的风格！</p>
<blockquote>
<p>“Not everyone can become a great artist, but a great artist can come from anywhere.”, “Everyone Can Cook！”（《料理鼠王》电影台词）</p>
</blockquote>
<p>“摄影艺术”这门课程改变了我很多的认识和想法，或许最大的感受便是：“Everyone Can Shoot！”每个人都有对其生活环境、人生观、世界观、价值观的独特理解，每个人也都可以拿起手中的设备拍出自己独特的风格。对大师作品的品鉴和艺术赏析都有助于提升自身的艺术品位，但关键在于去拍、去学习、去发现、去创造。我想这门课程给了我信心可以站在巨人的肩膀上努力拍出自己的作品，毕竟<strong>摄影是自由的，这才是摄影术之魅力！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章其实是我一年前研一《摄影艺术》课上的小论文，感觉写的还行，放在博客上。
    
    </summary>
    
      <category term="五味杂粮" scheme="http://ex2tron.coding.me/categories/%E4%BA%94%E5%91%B3%E6%9D%82%E7%B2%AE/"/>
    
    
      <category term="摄影" scheme="http://ex2tron.coding.me/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="布列松" scheme="http://ex2tron.coding.me/tags/%E5%B8%83%E5%88%97%E6%9D%BE/"/>
    
  </entry>
  
  <entry>
    <title>小白深度学习笔记3：浅层神经网络</title>
    <link href="http://ex2tron.coding.me/2017/10/13/%E5%B0%8F%E7%99%BD%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%EF%BC%9A%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://ex2tron.coding.me/2017/10/13/小白深度学习笔记3：浅层神经网络/</id>
    <published>2017-10-13T07:15:18.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>logistic回归可以看作是只有1层1个神经元的神经网络，那么一般的神经网络是怎么样的呢？<a id="more"></a></p>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p><em>因为国民不富裕就不能受法律保护，就不能享受民主，这种说法我是无法接受的。</em>  ——<a href="https://movie.douban.com/subject/21937445/" target="_blank" rel="external">《辩护人》</a></p>
</blockquote>
<p>本文是我在观看吴恩达老师的<a href="https://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="external">《神经网络和深度学习》</a>视频课程时，相关的笔记整理，大佬勿喷！</p>
<hr>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>前面学习了logistic回归，可以把logistic看作只有1层1个神经元的神经网络，如下图：</p>
<p><img src="http://pic.ex2tron.top/logistic_regression_singal_neural_network_sample.jpg" alt="logistic_regression_singal_neural_network_sample"></p>
<p>这个神经元做两个操作：</p>
<ol>
<li>计算\(z=w^Tx+b\)</li>
<li>计算\(\hat{y}=a=\sigma(z)\)</li>
</ol>
<p>而一般的神经网路包括输入层、隐藏层和输出层。如下图所示，是一个两层神经网络。层数从隐藏层(Hidden Layer)开始算，也就是这个图中，第1层是隐藏层，第2层是输出层(Output Layer)。可以把输入层(Input Layer)称为第0层。</p>
<p><img src="http://pic.ex2tron.top/two_layers_neural_network_samples.jpg" alt="two_layers_neural_network_samples"></p>
<p>浅层神经网络是相较于深层神经网络而言的，深层神经网络中，隐藏层的个数&gt;=2，层数越多，也就越深。</p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>如果把2层的神经网络看作是logistic回归的堆叠的话，那么这个神经网络的正向传播应该是下面这样的公式：</p>
<p>$$z^{[1]}=W^{[1]}x+b^{[1]}\tag{1}$$<br>$$a^{[1]}=\sigma(z^{[1]})\tag{2}$$<br>$$z^{[2]}=W^{[2]}x+b^{[2]}\tag{3}$$<br>$$a^{[2]}=\sigma(z^{[2]})\tag{4}$$</p>
<p>其中，sigmoid函数就是激活函数(Activation Function)。激活函数不一定是sigmoid函数，有的非线性函数要比sigmoid函数更好，这里介绍两种：tanh和ReLU。</p>
<p><img src="http://pic.ex2tron.top/common_activation_functions.jpg" alt="common_activation_functions"></p>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p><a href="https://baike.baidu.com/item/tanh" target="_blank" rel="external">tanh</a>(Hyperbolic Tangent Function)双曲正切函数，\(a=tanh(z)=\frac{e^z-e^{-z}}{e^z+e^{-z}}\)。tanh往往比sigmoid表现更好，从上图中可以看出，这个激活函数的平均值更接近于0。但是输出层如果是二类分类的话，结果要么是0要么是1，那么我们预测值应该介于0~1之间，所以这种情况下，输出层的激活函数依然用sigmoid函数。</p>
<h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><p>如果仔细观察sigmoid和tanh函数曲线的话，就会发现，自变量z比较大或比较小时，这个函数的斜率就会很小，接近于0，这样会拖慢梯度下降法的速度。所以，另外一个经常使用到的激活函数是<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E6%95%B4%E6%B5%81%E5%87%BD%E6%95%B0" target="_blank" rel="external">ReLU</a>(Rectified Linear Unit)。\(a=max(0,z)\)，z为正时，导数为1，z为负时，导数为0。</p>
<p>所以，总结三种激活函数，</p>
<ul>
<li>一般不使用sigmoid做激活函数，除非是二类分类，可用在输出层</li>
<li>tanh普遍效果要比sigmoid更好</li>
<li>最常用的默认激活函数是ReLU</li>
</ul>
<h2 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h2><p>如果我们选择tanh作为激活函数的话，开头那个2层神经网络的正向传播就是：</p>
<p>$$Z^{[1]}=W^{[1]}X+b^{[1]}\tag{1}$$<br>$$A^{[1]}=tanh(Z^{[1]})\tag{2}$$<br>$$Z^{[2]}=W^{[2]}X+b^{[2]}\tag{3}$$<br>$$A^{[2]}=tanh(Z^{[2]})\tag{4}$$</p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播的推导跟logistic回归一样，只不过进行两次：</p>
<p>$$dZ^{[2]}=A^{[2]}-Y\tag{1}$$<br>$$dW^{[2]}=\frac{1}{m}dZ^{[2]}A^{[1]^T}\tag{2}$$<br>$$db^{[2]}=\frac{1}{m}np.sum(dZ^{[2]},axis=1,keepdims=True)\tag{3}$$<br>$$dZ^{[1]}=W^{[2]^T}dZ^{[2]}*tanh^{’[1]}(Z^{[1]})\tag{4}$$<br>$$dW^{[1]}=\frac{1}{m}dZ^{[1]}X^T\tag{5}$$<br>$$db^{[1]}=\frac{1}{m}np.sum(dZ^{[1]},axis=1,keepdims=True)\tag{6}$$</p>
<h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>之前在logistic回归中，我们可以将权重W初始化为0，但是对于神经网络而言，W都初始化为0的话，是无效的。</p>
<p><img src="http://pic.ex2tron.top/no_zero_initialized_sample.jpg" alt="no_zero_initialized_sample"></p>
<p>举例来说，对于上图中的神经网络，隐藏层神经元个数是2，如果W全部初始化为0的话，那么：</p>
<p>$$<br>    W^{[1]}=<br>    \begin{bmatrix}<br>    0 &amp; 0 \newline<br>    0 &amp; 0<br>    \end{bmatrix}<br>$$</p>
<p>因为\(z^{[1]}=W^{[1]}x+b\)，这样的话\(z_1^{[1]}=z_2^{[1]}\)，\(a_1^{[1]}=a_2^{[1]}\)，也就是说，两个神经元的功能完全一样，计算相同的值，这样1个神经元和n个神经元对神经网络的作用是一样的，其他n-1个是多余的。</p>
<p>所以，在神经网络的参数初始化中，权重W是不能全部初始化为0的，b的话无所谓，都可以。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;logistic回归可以看作是只有1层1个神经元的神经网络，那么一般的神经网络是怎么样的呢？
    
    </summary>
    
      <category term="深度学习" scheme="http://ex2tron.coding.me/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="http://ex2tron.coding.me/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>numpy中几种矩阵的乘法</title>
    <link href="http://ex2tron.coding.me/2017/10/11/numpy%E4%B8%AD%E5%87%A0%E7%A7%8D%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95/"/>
    <id>http://ex2tron.coding.me/2017/10/11/numpy中几种矩阵的乘法/</id>
    <published>2017-10-11T02:26:09.000Z</published>
    <updated>2017-12-20T09:20:00.129Z</updated>
    
    <content type="html"><![CDATA[<p>最近在手动实现神经网络模型的时候，老是混淆numpy中几种矩阵乘法区别，所以特此记录一下。<a id="more"></a></p>
<blockquote>
<p><em>With great power comes great responsibility</em>  ——<a href="https://movie.douban.com/subject/1306612/" target="_blank" rel="external">《Spider-Man》</a><br><br><em>能力越大，责任越大。</em>——<a href="https://movie.douban.com/subject/1306612/" target="_blank" rel="external">《蜘蛛侠》</a></p>
</blockquote>
<hr>
<p>首先，这里规定一下，我们用numpy定义矩阵时全部采用标准的形式，举例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 不推荐的方式</span></div><div class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">print(a.shape)</div><div class="line"><span class="comment"># 推荐的方式</span></div><div class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</div><div class="line">print(b.shape)</div></pre></td></tr></table></figure>
<p>上面代码a的形状是<code>(3,)</code>，b的形状<code>(1,3)</code>，即1行3列的一个矩阵。</p>
<h2 id="np-dot"><a href="#np-dot" class="headerlink" title="np.dot"></a><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html" target="_blank" rel="external">np.dot</a></h2><p><code>np.dot(A,B)</code>就是实现同线性代数里面的矩阵乘法，也就是说，A的列数要等于B的行数才可以相乘：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</div><div class="line">b = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])</div><div class="line">print(np.dot(a,b))</div></pre></td></tr></table></figure>
<p>a是<code>(2,3)</code>，b是<code>(3,1)</code>，所以输出结果是：[[14], [32]]。</p>
<h2 id="np-multiply"><a href="#np-multiply" class="headerlink" title="np.multiply"></a><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.multiply.html" target="_blank" rel="external">np.multiply</a></h2><p>np.multiply(A,B)和A*B效果一样，实现对应位置元素相乘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="comment"># 示例一</span></div><div class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</div><div class="line">b = np.array([[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</div><div class="line">print(a*b)</div><div class="line">print(np.multiply(a,b))</div><div class="line"></div><div class="line"><span class="comment"># 示例二</span></div><div class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</div><div class="line">d = np.array([[<span class="number">1</span>],[<span class="number">2</span>]])</div><div class="line">print(c*d)</div><div class="line">print(np.multiply(c,d))</div></pre></td></tr></table></figure>
<p>示例一输出结果是<code>[[4 10 18]]</code>，即<code>[[1*4 2*5 3*6]]</code>。<br>示例二输出结果是<code>[[1  2  3], [8 10 12]]</code>，这里涉及到一个numpy中<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="external">广播</a>的概念：因为c是(2,3)，而d是(2,1)，为了实现对应元素相乘，numpy会把d的列复制扩展成(2,3)，于是就有了上面的结果。</p>
<h2 id="np-inner"><a href="#np-inner" class="headerlink" title="np.inner"></a><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.inner.html#numpy.inner" target="_blank" rel="external">np.inner</a></h2><p>np.inner(A,B) 实现A,B的内积，要求A,B矩阵最后一维是相同的，如果是2维矩阵，即A,B矩阵的列数要相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</div><div class="line">b = np.array([[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</div><div class="line">print(np.inner(a,b))</div></pre></td></tr></table></figure>
<p>结果为<code>[[32]]</code>，即<code>1*4 + 2*10 + 3*6</code>。</p>
<h2 id="np-outer"><a href="#np-outer" class="headerlink" title="np.outer"></a><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.outer.html#numpy.outer" target="_blank" rel="external">np.outer</a></h2><p>np.outer(A,B)即A,B的外积：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</div><div class="line">b = np.array([[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</div><div class="line">print(np.outer(a,b))</div></pre></td></tr></table></figure>
<p>结果为<code>[[4  5  6], [8 10 12], [12 15 18]]</code>，即<code>[[1*4 1*5 1*6], [2*4 2*5 2*6], [3*4 3*5 3*6]]</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在手动实现神经网络模型的时候，老是混淆numpy中几种矩阵乘法区别，所以特此记录一下。
    
    </summary>
    
      <category term="Build篇" scheme="http://ex2tron.coding.me/categories/Build%E7%AF%87/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="numpy" scheme="http://ex2tron.coding.me/tags/numpy/"/>
    
      <category term="矩阵" scheme="http://ex2tron.coding.me/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程（目录）</title>
    <link href="http://ex2tron.coding.me/2017/10/10/Python-OpenCV%E6%95%99%E7%A8%8B%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89/"/>
    <id>http://ex2tron.coding.me/2017/10/10/Python-OpenCV教程（目录）/</id>
    <published>2017-10-10T14:22:13.000Z</published>
    <updated>2018-01-19T06:08:20.571Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2017/12/12/Python-OpenCV%E6%95%99%E7%A8%8B/">图文版</a> | 简洁版</p>
<h3 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h3><ol>
<li><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/">简介与安装</a>（了解安装OpenCV-Python） | <a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">番外篇1：代码性能优化</a></li>
<li><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/">基本元素-图片</a>（图片载入/显示/保存） | <a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9AMatplotlib%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F/">番外篇2：Matplotlib显示图像</a></li>
<li><a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/">打开摄像头</a>（打开摄像头捕获图片/播放保存视频） | <a href="/2017/12/06/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/">番外篇3：滑动条</a></li>
<li><a href="/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">图像基本操作</a>（访问像素点/ROI/通道分离合并）</li>
<li><a href="/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/">颜色空间转换</a>（颜色空间转换/追踪特定颜色物体）</li>
<li><a href="/2017/12/07/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/">阈值分割</a>（阈值分割/二值化） | <a href="/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/">番外篇4：Otsu阈值法</a></li>
<li><a href="/2017/12/08/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/">图像几何变换</a>（旋转/平移/缩放/仿射变换/透视变换）</li>
<li><a href="/2017/12/09/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/">绘图功能</a>（画线/画圆/画矩形/添加文字） | <a href="/2017/12/09/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE/">番外篇5：鼠标绘图</a></li>
</ol>
<h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><ol>
<li><a href="/2017/12/10/Python-OpenCV%E6%95%99%E7%A8%8B9%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/">图像混合</a>（算数运算/混合/按位运算） | <a href="/2017/12/10/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%876%EF%BC%9A%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6/">番外篇6：亮度与对比度</a></li>
<li><a href="/2017/12/15/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/">平滑图像</a>（卷积/滤波/模糊/降噪） | <a href="/2017/12/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/">番外篇7：卷积基础(图片边框)</a></li>
<li><a href="/2017/12/18/Python-OpenCV%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/">边缘检测</a>（Canny/Sobel） | <a href="/2017/12/18/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/">番外篇8：图像梯度</a></li>
<li><a href="/2017/12/19/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/">腐蚀与膨胀</a>（形态学操作/腐蚀/膨胀/开运算/闭运算）</li>
<li><a href="/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B13%EF%BC%9A%E8%BD%AE%E5%BB%93/">轮廓</a> （寻找/绘制轮廓）  | <a href="/2017/12/20/Python-OpenCV教程番外篇9：轮廓层级/">番外篇9：轮廓层级</a></li>
<li><a href="/2017/12/20/Python-OpenCV%E6%95%99%E7%A8%8B14%EF%BC%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/">轮廓特征</a> （面积/周长/最小外接矩(圆)/形状匹配） | <a href="/2017/12/20/Python-OpenCV教程番外篇10：凸包及更多轮廓特征/">番外篇10：凸包及更多轮廓特征</a></li>
<li><a href="/2017/12/23/Python-OpenCV%E6%95%99%E7%A8%8B15%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE/">直方图</a>（计算绘制直方图/均衡化）</li>
<li><a href="/2017/12/27/Python-OpenCV%E6%95%99%E7%A8%8B16%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/">模板匹配</a>（大图中找小图）</li>
<li><a href="/2017/12/28/Python-OpenCV%E6%95%99%E7%A8%8B17%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"> 霍夫变换</a>（提取直线/圆）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2017/12/12/Python-OpenCV%E6%95%99%E7%A8%8B/&quot;&gt;图文版&lt;/a&gt; | 简洁版&lt;/p&gt;
&lt;h3 id=&quot;入门篇&quot;&gt;&lt;a href=&quot;#入门篇&quot; class=&quot;headerlink&quot; title=&quot;入门篇&quot;&gt;&lt;/a&gt;入
    
    </summary>
    
      <category term="机器视觉" scheme="http://ex2tron.coding.me/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="Python" scheme="http://ex2tron.coding.me/tags/Python/"/>
    
      <category term="OpenCV" scheme="http://ex2tron.coding.me/tags/OpenCV/"/>
    
      <category term="图像处理" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>小白深度学习笔记2：Python实现logistic回归</title>
    <link href="http://ex2tron.coding.me/2017/10/09/%E5%B0%8F%E7%99%BD%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%9APython%E5%AE%9E%E7%8E%B0logistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://ex2tron.coding.me/2017/10/09/小白深度学习笔记2：Python实现logistic回归/</id>
    <published>2017-10-09T01:52:11.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇了解了一些logistic回归的原理，现在我们用Python实现一个用于鉴别是否是一张猫的图片的分类器！<a id="more"></a></p>
<p>本文是我在观看吴恩达老师的<a href="https://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="external">《神经网络和深度学习》</a>视频课程时，相关的笔记整理，大佬勿喷！</p>
<blockquote>
<p><em>You’re not worried？ Would it help？</em>  ——<a href="https://movie.douban.com/subject/25908051/" target="_blank" rel="external">《Bridge of Spies》</a><br><br><em>你不担心吗？有用吗？</em>——<a href="https://movie.douban.com/subject/25908051/" target="_blank" rel="external">《间谍之桥》</a></p>
</blockquote>
<hr>
<p>首先，回顾一下，logistic回归其实就相当于只有一层的最简单的神经网络，如下图，正向传播计算出预测值和成本函数，而反向传播计算出的dw和db：</p>
<p><img src="http://pic.ex2tron.top/logistic_forward_backword_propagation.png" alt="logistic_forward_backword_propagation"></p>
<p>p.s.本文其实是吴恩达老师<a href="http://pic.ex2tron.top/Logistic-Regression-with-a-Neural-Network-mindset.mhtml" target="_blank" rel="external">第二周教程的作业</a>，没答案，这里提供我写的，仅供参考！</p>
<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>首先import我们要使用的包，其中lr_utils和数据样本点<a href="http://pic.ex2tron.top/l1w2_datasets_lr_utils.rar" target="_blank" rel="external">此处</a>下载：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"><span class="keyword">import</span> scipy</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</div><div class="line"><span class="keyword">from</span> lr_utils <span class="keyword">import</span> load_dataset</div></pre></td></tr></table></figure>
<h2 id="得到样本集"><a href="#得到样本集" class="headerlink" title="得到样本集"></a>得到样本集</h2><p>我们的训练样本和测试样本都在前面下载的文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 加载样本</span></div><div class="line">train_set_x_orig,train_set_y,test_set_x_orig,test_set_y,classes = load_dataset()</div></pre></td></tr></table></figure>
<p>因为我们直接加载的样本集还需要进行处理，所以变量名上加了<code>_orig</code>。此时，train_set_x_orig中的每一个元素就是一副图片，可以用下面的方式让它显示出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 显示第11张图片</span></div><div class="line">plt.figure()</div><div class="line">plt.imshow(train_set_x_orig[<span class="number">10</span>])</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>如果打印出train_set_x_orig的形状，结果为：(209,64,64,3)。可知训练样本的个数m_train=209，图片的宽和高都是num_px=64。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(train_set_x_orig.shape)</div></pre></td></tr></table></figure>
<p>还记得上一篇中提到如果把图片量化吗？如果图片的维数是(num_px,num_px,3)，我们要变成(num_px*num_px*3,1)的形状。也就是说要把形状为(a,b,c,d)的矩阵变成形状数组为(b*c*d,a)的矩阵数组，这里可以用下面的一个小技巧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X_flatten = X.reshape(X.shape[<span class="number">0</span>], <span class="number">-1</span>).T</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</div><div class="line">test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</div></pre></td></tr></table></figure>
<p>编写神经网络的代码中经常出现的错误便是把矩阵的维数搞错，所以随时可以通过shape属性进行检查，经过上面的语句后，train_set_x_flatten的形状应该是(12288,209)，test_set_x_flatten的形状应该是(12288,50)。</p>
<p>因为像素值最大是255，为了避免数据过大，可以将数据归一化得到最终的训练/测试集样本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">train_set_x = train_set_x_flatten/<span class="number">255</span></div><div class="line">test_set_x = test_set_x_flatten/<span class="number">255</span></div></pre></td></tr></table></figure>
<h2 id="编写各个模块"><a href="#编写各个模块" class="headerlink" title="编写各个模块"></a>编写各个模块</h2><h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><p>这里注意python自带math模块中的exp函数和numpy中的exp函数的区别，math.exp是没有<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="external">广播</a>功能的，不适合此处的矩阵运算。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></div><div class="line">    s = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</div><div class="line">    <span class="keyword">return</span> s</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(sigmoid(np.array([<span class="number">0</span>,<span class="number">2</span>])))</div></pre></td></tr></table></figure></p>
<p>结果应为<code>[0.5         0.88079708]</code></p>
<h3 id="初始化w和b"><a href="#初始化w和b" class="headerlink" title="初始化w和b"></a>初始化w和b</h3><p>因为logistic回归相当于只有一个输出层的神经网络，根据上一篇的分析，w的形状是(nx,1)，b的形状是(1,1)，这里我们统一初始化为0：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_with_zeros</span><span class="params">(dim)</span>:</span></div><div class="line">    w = np.zeros([dim,<span class="number">1</span>])</div><div class="line">    b = <span class="number">0.</span></div><div class="line">    <span class="keyword">return</span> w, b</div></pre></td></tr></table></figure></p>
<h3 id="正-反向传播"><a href="#正-反向传播" class="headerlink" title="正/反向传播"></a>正/反向传播</h3><p>这里的函数就是本文开头那张图上显示的正向传播和反向传播：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, b, X, Y)</span>:</span></div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    <span class="comment"># 正向传播</span></div><div class="line">    A = sigmoid(np.dot(w.T,X)+b)</div><div class="line">    <span class="comment"># 成本函数</span></div><div class="line">    cost = -np.sum(Y*np.log(A)+(<span class="number">1</span>-Y)*np.log(<span class="number">1</span>-A),axis=<span class="number">1</span>)/m</div><div class="line">    cost = np.squeeze(cost)</div><div class="line"></div><div class="line">    <span class="comment"># 反向传播</span></div><div class="line">    dw = np.dot(X,(A-Y).T)/m</div><div class="line">    db = np.sum(A-Y,axis=<span class="number">1</span>)/m</div><div class="line"></div><div class="line">    grads = &#123;<span class="string">"dw"</span>:dw,<span class="string">"db"</span>:db&#125;</div><div class="line">    <span class="keyword">return</span> cost,grads</div></pre></td></tr></table></figure></p>
<p>测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w,b,X,Y = np.array([[<span class="number">1</span>],[<span class="number">2</span>]]),<span class="number">2</span>,np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]),np.array([[<span class="number">1</span>,<span class="number">0</span>]])</div><div class="line">cost,grads = propagate(w,b,X,Y)</div><div class="line">print(cost,grads)</div></pre></td></tr></table></figure></p>
<p>结果应为：<code>6.000064773192205 {&#39;dw&#39;: array([[0.99993216], [ 1.99980262]]), &#39;db&#39;: array([0.49993523])}</code></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>反向传播完，我们需要更新w，b的值，即应用梯度下降法进行优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span><span class="params">(w,b,X,Y,num_iterations,learning_rate,print_cost=False)</span>:</span></div><div class="line">    costs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</div><div class="line">        cost,grads = propagate(w,b,X,Y)</div><div class="line">        dw = grads[<span class="string">'dw'</span>]</div><div class="line">        db = grads[<span class="string">'db'</span>]</div><div class="line">        <span class="comment"># 更新w和b的值</span></div><div class="line">        w = w-learning_rate*dw</div><div class="line">        b = b-learning_rate*db</div><div class="line">        <span class="comment"># 每隔100次，记录下成本函数的值</span></div><div class="line">        <span class="keyword">if</span>(i%<span class="number">100</span> == <span class="number">0</span>):</div><div class="line">            costs.append(cost)</div><div class="line">            <span class="keyword">if</span>(print_cost):</div><div class="line">                print(<span class="string">"cost after iteration %i:%f"</span>%(i,cost))</div><div class="line">    </div><div class="line">    params=&#123;<span class="string">'w'</span>:w,<span class="string">'b'</span>:b&#125;</div><div class="line">    grads=&#123;<span class="string">'dw'</span>:dw,<span class="string">'db'</span>:db&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> params,grads,costs</div></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">params, grads, costs = optimize(w, b, X, Y, num_iterations= <span class="number">100</span>, learning_rate = <span class="number">0.009</span>, print_cost = <span class="keyword">False</span>)</div><div class="line">print(params,grads,costs)</div></pre></td></tr></table></figure></p>
<p>结果应为<code>{&#39;w&#39;: array([[0.1124579 ],[0.23106775]]), &#39;b&#39;: array([ 1.55930492])} {&#39;dw&#39;: array([[ 0.90158428],[1.76250842]]), &#39;db&#39;: array([ 0.43046207])} [array(6.000064773192205)]</code></p>
<h3 id="预测函数"><a href="#预测函数" class="headerlink" title="预测函数"></a>预测函数</h3><p>通过优化器得到w和b参数之后，就可以用这两个参数预测X了，如果预测值&gt;=0.5，那结果就为1，即是一张有猫的图片，反之，结果为0，是一张没有猫的图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w,b,X)</span>:</span></div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    Y_predictions = np.zeros([<span class="number">1</span>,m])</div><div class="line">    A = sigmoid(np.dot(w.T,X)+b)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</div><div class="line">        Y_predictions[<span class="number">0</span>,i] = <span class="number">1</span> <span class="keyword">if</span> A[<span class="number">0</span>,i]&gt;=<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> Y_predictions</div></pre></td></tr></table></figure>
<h3 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h3><p>这样我们就编写好了所有的模块了，最后，把它们整合在一起，就是logistic回归的二类分类模型了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X_train,Y_train,X_test,Y_test,num_iterations=<span class="number">2000</span>,learning_rate=<span class="number">0.5</span>,print_cost=False)</span>:</span></div><div class="line">    w,b = initialize_with_zeros(X_train.shape[<span class="number">0</span>])</div><div class="line">    params,grads,costs = optimize(w,b,X_train,Y_train,num_iterations,learning_rate,print_cost)</div><div class="line"></div><div class="line">    w = params[<span class="string">'w'</span>]</div><div class="line">    b = params[<span class="string">'b'</span>]</div><div class="line"></div><div class="line">    Y_prediction_test = predict(w,b,X_test)</div><div class="line">    Y_prediction_train = predict(w,b,X_train)</div><div class="line"></div><div class="line">    print(<span class="string">"train accuracy:&#123;&#125; %"</span>.format(<span class="number">100</span>-np.mean(np.abs(Y_prediction_train-Y_train))*<span class="number">100</span>))</div><div class="line">    print(<span class="string">"test accuracy:&#123;&#125; %"</span>.format(<span class="number">100</span>-np.mean(np.abs(Y_prediction_test-Y_test))*<span class="number">100</span>))</div><div class="line"></div><div class="line">    d = &#123;<span class="string">"costs"</span>: costs,</div><div class="line">        <span class="string">"Y_prediction_test"</span>: Y_prediction_test, </div><div class="line">        <span class="string">"Y_prediction_train"</span> : Y_prediction_train, </div><div class="line">        <span class="string">"w"</span> : w, </div><div class="line">        <span class="string">"b"</span> : b,</div><div class="line">        <span class="string">"learning_rate"</span> : learning_rate,</div><div class="line">        <span class="string">"num_iterations"</span>: num_iterations&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> d</div></pre></td></tr></table></figure></p>
<p>现在，可以把我们真正的样本数据传入这个模型，看它最后训练的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.005</span>, print_cost = <span class="keyword">True</span>)</div></pre></td></tr></table></figure></p>
<p>如果一切正常，会打印出最后模型在训练集和测试集上的准确率：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">train accuracy:99.04306220095694 %</div><div class="line">test accuracy:70.0 %</div></pre></td></tr></table></figure></p>
<h2 id="验证和分析结果"><a href="#验证和分析结果" class="headerlink" title="验证和分析结果"></a>验证和分析结果</h2><p>可以看到当前的训练结果其实是过拟合的，测试集上的准确率并不高，但暂时足够了。我们可以显示和打印出真实的图片结果进行对比。比如说这里我们打开测试集上的第5张图片，并将学习率曲线画出来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">index = <span class="number">4</span></div><div class="line">plt.imshow(test_set_x[:,index].reshape([num_px,num_px,<span class="number">3</span>]))</div><div class="line">print(<span class="string">"real result = "</span>+str(test_set_y[<span class="number">0</span>,index])+<span class="string">" and your predict = "</span>+str(d[<span class="string">'Y_prediction_test'</span>][<span class="number">0</span>,index]))</div><div class="line">plt.figure()</div><div class="line">plt.plot(np.squeeze(d[<span class="string">'costs'</span>]))</div><div class="line">plt.ylabel(<span class="string">'cost'</span>)</div><div class="line">plt.xlabel(<span class="string">'iterations(per hundreds)'</span>)</div><div class="line">plt.title(<span class="string">"learning rate = "</span>+str(d[<span class="string">'learning_rate'</span>]))</div><div class="line">plt.show()</div></pre></td></tr></table></figure></p>
<p>最后，源代码中包含了一段针对不同的学习率得到不同的训练结果的代码，大家可以参考下噢！~ o(<em>￣▽￣</em>)o</p>
<p>本文源代码：<a href="https://github.com/ex2tron/BlogCode/blob/master/python_implement_logistic_regression.py" target="_blank" rel="external">python_implement_logistic_regression.py</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇了解了一些logistic回归的原理，现在我们用Python实现一个用于鉴别是否是一张猫的图片的分类器！
    
    </summary>
    
      <category term="深度学习" scheme="http://ex2tron.coding.me/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="http://ex2tron.coding.me/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="logistic" scheme="http://ex2tron.coding.me/tags/logistic/"/>
    
  </entry>
  
  <entry>
    <title>【利器篇】GitKraken：顶级酷炫Git图像化客户端</title>
    <link href="http://ex2tron.coding.me/2017/10/05/%E3%80%90%E5%88%A9%E5%99%A8%E7%AF%87%E3%80%91GitKraken%EF%BC%9A%E9%A1%B6%E7%BA%A7%E9%85%B7%E7%82%ABGit%E5%9B%BE%E5%83%8F%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <id>http://ex2tron.coding.me/2017/10/05/【利器篇】GitKraken：顶级酷炫Git图像化工具/</id>
    <published>2017-10-05T09:33:20.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>不喜欢敲命令？那么这款酷炫的Git客户端让你逼格满满！<a id="more"></a></p>
<blockquote>
<p><em>真正的忘记是不需要努力的。</em>——<a href="https://movie.douban.com/subject/5045678/" target="_blank" rel="external">《大鱼海棠》</a></p>
</blockquote>
<hr>
<p>首先废话一段：以前我上班的时候，公司里的<a href="https://baike.baidu.com/item/scm/2039966" target="_blank" rel="external">SCM</a>用的是perforce，你应该、可能没听过( ╯□╰ )。总之，就是集中式版本管理系统，相比于git的分布式有很多缺陷，具体可以看廖雪峰的这篇文章：“<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000" target="_blank" rel="external">集中式vs分布式</a>”。但作为一款商业软件，perforce提供的优秀客户端体验还是相当不错的。使用git后，一直都是敲命令的，一是因为习惯，毕竟码代码逼格高嘛，二是因为git的GUI客户端要不很丑，要不功能捉急，总之不想用。之后，在微博上看到这款软件，又同类似的<a href="http://www.sourcetreeapp.com/" target="_blank" rel="external">SourceTree</a>相比体验了一下，无奈，我，还是喜欢颜值高的~ o(<em>￣▽￣</em>)o另外，以前外教老师提问说《加勒比海盗2》中的那个怪物叫啥，阅片无数的我，那天竟然没回答上，装逼失败，所以对这只“挪威海怪kraken”影响特别深刻。好了，开始正题吧，扯远了~</p>
<p>官网/下载：<a href="https://www.gitkraken.com/" target="_blank" rel="external">GitKraken</a></p>
<p>GitKraken对Windows/Linux/Mac三大主流平台都支持，其方便之处在于，它不需要安装配置，双击打开就可以了。打开之后，可以选择用Github账号登陆，需要Github授权：</p>
<p><img src="http://pic.ex2tron.top/gitkraken_sign_in_with_github.png" alt="gitkraken_sign_in_with_github"></p>
<h2 id="打开-克隆-初始化"><a href="#打开-克隆-初始化" class="headerlink" title="打开/克隆/初始化"></a>打开/克隆/初始化</h2><p>GitKranken支持打开本地仓库，从指定的URL或Github、Gitlab、Bitbucket等上面直接克隆。前面我们已经用Github直接登陆了，所以，从Github克隆时，会直接列出你当前的所有仓库项目，非常方便。当然，也可以连接到Gitlab/Bitbucket平台：</p>
<p><img src="http://pic.ex2tron.top/gitkraken_clone_from_github.png" alt="gitkraken_clone_from_github"></p>
<p>初始化/新建项目也非常方便，在<code>Init</code>选项中，可以选择初始化一个本地仓库或类似Github之类的远程仓库。GitKraken初始化时还提供了.gitignore的文件的相关模板：</p>
<p><img src="http://pic.ex2tron.top/gitkraken_init_github_repo.png" alt="gitkraken_init_github_repo"></p>
<h2 id="界面-功能"><a href="#界面-功能" class="headerlink" title="界面/功能"></a>界面/功能</h2><p>打开一个仓库后，主界面如下图，酷炫简洁，顶部提供了常用的Git功能，就不细说了。我主要提及一下，如何进行版本差分：</p>
<p><img src="http://pic.ex2tron.top/gitkraken_main_ui.png" alt="gitkraken_main_ui"></p>
<p>在提交日志的主界面，如果要比较任意两个版本之间的差分，按住Ctrl键，选择要比较的版本，右边会自动列出两个版本之间所修改的文件，点击文件就可以看到diff了：</p>
<p><img src="http://pic.ex2tron.top/gitkraken_view_commits_diff.png" alt="gitkraken_view_commits_diff"></p>
<p><img src="http://pic.ex2tron.top/gitkraken_view_file_diff.png" alt="gitkraken_view_file_diff"></p>
<p>当然，最新版本（本文使用的是3.1版本）的GitKraken提供了Merge和Diff工具的自定义（File-Preferences-General中设置），比如说我最常用的Merge工具是WinMerge，就可以在这里配置。</p>
<p>抛砖引玉，大致介绍了一下，其实熟悉Git的话，这个工具使用起来还是蛮简单的~ o(<em>￣▽￣</em>)o</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不喜欢敲命令？那么这款酷炫的Git客户端让你逼格满满！
    
    </summary>
    
      <category term="利器篇" scheme="http://ex2tron.coding.me/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="Git" scheme="http://ex2tron.coding.me/tags/Git/"/>
    
      <category term="GitKraken" scheme="http://ex2tron.coding.me/tags/GitKraken/"/>
    
  </entry>
  
  <entry>
    <title>小白深度学习笔记1：logistic回归</title>
    <link href="http://ex2tron.coding.me/2017/10/02/%E5%B0%8F%E7%99%BD%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%9Alogistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://ex2tron.coding.me/2017/10/02/小白深度学习笔记1：logistic回归/</id>
    <published>2017-10-02T13:06:32.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>开启神经网络与深度学习之坑！<a id="more"></a>本篇内容包含部分数学公式，需要用MathJax脚本渲染，所以页面需等待加载完成后，才可完整显示公式。</p>
<blockquote>
<p><em>When life ends up breathtakingly fucked, you can generally trace it back to one big, bad decision.</em>——<a href="https://movie.douban.com/subject/3718279/" target="_blank" rel="external">《DeadPool》</a><br><em>当你的生活变成一坨屎的时候，通常都是因为你当时做的傻逼决定。</em>——<a href="https://movie.douban.com/subject/3718279/" target="_blank" rel="external">《死侍》</a></p>
</blockquote>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<p>本文是我在观看吴恩达老师的<a href="https://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="external">《神经网络和深度学习》</a>视频课程时，相关的笔记整理，大佬勿喷！</p>
<hr>
<h2 id="二类分类"><a href="#二类分类" class="headerlink" title="二类分类"></a>二类分类</h2><p>比如说分析一张图片中有猫还是没猫，这就是一个二类分类（Binary Classification）问题。这里，我们用输出y=1表示有猫，y=0表示没有猫。输入是一张图片，做过图像处理的同学应该知道图片是以RGB三个矩阵存储的，把RGB三分量的值提取出来，作为X，如下图：</p>
<p><img src="http://pic.ex2tron.top/rgb_convert_input_x.png" alt="rgb_convert_input_x"></p>
<p>那么当有m个样本时，X就是一个(nx,m)，即nx行、m列的矩阵，而输出Y的形状（形状就是指矩阵的行数和列数）是(1,m)。</p>
<h2 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h2><p>logistic回归（<a href="https://baike.baidu.com/item/Logistic%E6%A8%A1%E5%9E%8B?fromtitle=Logistic+regression&amp;fromid=18080373" target="_blank" rel="external">Logistic Regression</a>）就是一个用于二类分类的学习算法：假定给出输入的特征向量\(x_1\)（如一张图片），我们希望程序给出一个预测值\(\hat{y}\)，它指出这张图片中有猫还是没猫的概率，即：<br>$$\hat{y}=P(y=1\ or\ 0\mid x)$$</p>
<p>既然\(\hat{y}\)是一个概率，那么\(\hat{y}\in[0,1]\)。如果按照线性回归，输出值应该是：\(\hat{y}=w^Tx+b\)，w形状是(nx,1)，b形状是(1,1)，但是这个值可能远比1大或者出现负数，所以，需要用一个sigmoid函数做限定，最终输出为：<br>$$\hat{y}=\sigma(w^Tx+b)$$</p>
<p>观察sigmoid函数\(\sigma(z)=\frac{1}{1+e^{-z}}\)的曲线图：</p>
<p>\(z\rightarrow\infty,\sigma(z)\rightarrow1;z\rightarrow-\infty,\sigma(z)\rightarrow0;z=0,\sigma(z)=0.5\)</p>
<p><img src="http://pic.ex2tron.top/sigmoid_function_graph.png" alt="sigmoid_function_graph"></p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>既然我们的目标就是训练得到logistic回归函数中的w和b参数，那么怎么衡量算法的运行情况呢？我们可以用损失函数（Loss Function）L表示预测值与真值的接近程度。最简单的损失函数可以定义成\(L(\hat{y},y)=\hat{y}-y\)。但是不会这样用，因为要考虑到优化算法的运算速度和效率，排除多个局部最优解。一般，损失函数定义为：<br>$$L(\hat{y},y)=-[y\log\hat{y}+(1-y)\log(1-\hat{y})]$$</p>
<p>显然，损失函数越小，结果越好。那么这个损失函数如何起作用的呢？</p>
<p>假设真值y=1，那么上式就会变成：\(L(\hat{y},1)=-\log\hat{y}\)，要让损失函数尽量小，那么\(\log\hat{y}\)尽量大，也就是说\(\hat{y}\)尽量大，由于\(\hat{y}\in[0,1]\)，所以，这个损失函数会使预测值\(\hat{y}\)尽量接近1，即真值。同样，大家可以推一下真值y=0的情况。</p>
<h2 id="成本函数"><a href="#成本函数" class="headerlink" title="成本函数"></a>成本函数</h2><p>前面所说的损失函数是针对单个训练样本定义的，我们可以用成本函数（Cost Function）来定义全体训练样本上的算法运行情况，定义如下：<br>$$J(w,b)=\frac{1}{m}\sum_{i=1}^mL(\hat{y^i},y^i)$$</p>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>好，到这里，先总结一下：</p>
<ul>
<li>logistic回归模型是用于二类分类的一种学习算法</li>
<li>损失函数衡量参数w和b在单个训练样本的效果</li>
<li>成本函数衡量参数w和b在全体训练样本的效果</li>
<li>训练目标：找到使成本函数J尽可能小的参数w和b</li>
</ul>
<p>那么w和b参数是怎么调整的呢？为了说明梯度下降法（Gradient Descent），吴恩达老师假定w和b都是实数，那么J(w,b)的函数图形类似下图：</p>
<p><img src="http://pic.ex2tron.top/cost_function_graph.png" alt="cost_function_graph"></p>
<p>一般，先随机初始化w和b，然后朝着最快下降的方向不断按下面的公式调整w和b参数，最后得到最优解（:=表示更新w的值）：</p>
<p>$$w:=w-\alpha\frac{dJ(w,b)}{dw}$$<br>$$b:=b-\alpha\frac{dJ(w,b)}{db}$$</p>
<p>\(\alpha\)成为学习率（Learning Rate），表示梯度下降法的步长。</p>
<p>好了，这就是相关的logistic回归的简单理论笔记。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开启神经网络与深度学习之坑！
    
    </summary>
    
      <category term="深度学习" scheme="http://ex2tron.coding.me/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="http://ex2tron.coding.me/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="logistic" scheme="http://ex2tron.coding.me/tags/logistic/"/>
    
  </entry>
  
  <entry>
    <title>【算法贴】三点定位算法</title>
    <link href="http://ex2tron.coding.me/2017/09/29/%E3%80%90%E7%AE%97%E6%B3%95%E8%B4%B4%E3%80%91%E4%B8%89%E7%82%B9%E5%AE%9A%E4%BD%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://ex2tron.coding.me/2017/09/29/【算法贴】三点定位算法/</id>
    <published>2017-09-29T10:58:31.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>已知三个点的坐标和未知点到这三个点的距离，求未知点？<a id="more"></a></p>
<blockquote>
<p><em>过去的如果就这么过去了，以后只会越来越糟。</em>——<a href="https://movie.douban.com/subject/25921812/" target="_blank" rel="external">《驴得水》</a></p>
</blockquote>
<hr>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<p>p.s.本文引用了mathjax脚本用来显示数学公式，所以需等待加载完成才能显示正常。</p>
<h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>如下图所示，以三个已知点为圆心，d1,d2,d3为半径作圆，交点便是要求解的未知点：</p>
<p><img src="http://pic.ex2tron.top/trilateration_sample.png" alt="trilateration_sample"></p>
<p>刚开始百度了一下，各种稀奇的算法，包括将三角形平移、旋转啥的，其实不用这么麻烦，直接通过勾股定理死算就可以了。</p>
<p>$$(x_1-x_0)^2+(y_1-y_0)^2=d_1^2$$</p>
<p>$$(x_2-x_0)^2+(y_2-y_0)^2=d_2^2$$</p>
<p>$$(x_3-x_0)^2+(y_3-y_0)^2=d_3^2$$</p>
<p>将上面三个式子展开：</p>
<p>$$x_1^2+x_0^2-2x_0x_1+y_1^2+y_0^2-2y_0y_1=d_1^2 ①$$<br>$$x_2^2+x_0^2-2x_0x_2+y_2^2+y_0^2-2y_0y_2=d_2^2 ②$$<br>$$x_3^2+x_0^2-2x_0x_3+y_3^2+y_0^2-2y_0y_3=d_3^2 ③$$</p>
<p>显然通过三个式子中的任意两个相减，比如①-③和②-③就可以得到两个未知数的两个式子：</p>
<p>$$x_1^2-x_3^2-2x_0(x_1-x_3)+y_1^2-y_3^2-2y_0(y_1-y_3)=d_1^2-d_3^2$$<br>$$x_2^2-x_3^2-2x_0(x_2-x_3)+y_2^2-y_3^2-2y_0(y_2-y_3)=d_2^2-d_3^2$$</p>
<p>接下来就不用说了，其实这都是初中数学的问题( ╯□╰ )</p>
<h2 id="算法实现CSharp"><a href="#算法实现CSharp" class="headerlink" title="算法实现CSharp"></a>算法实现CSharp</h2><p>根据上面的推导，我们的算法就很好写了。先定义一个Point的结构体或类，然后编写一个函数，将已知的三个点和三个距离传入：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></div><div class="line"><span class="comment"><span class="doctag">///</span> 定义Point结构体</span></div><div class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> X;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> Point <span class="title">GetMobilePoint</span>(<span class="params">Point p1, Point p2, Point p3, <span class="keyword">double</span> d1, <span class="keyword">double</span> d2, <span class="keyword">double</span> d3</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//相当于①式-③式</span></div><div class="line">    <span class="keyword">double</span> A = p1.X - p3.X;</div><div class="line">    <span class="keyword">double</span> B = p1.Y - p3.Y;</div><div class="line">    <span class="keyword">double</span> C = Math.Pow(p1.X, <span class="number">2</span>) - Math.Pow(p3.X, <span class="number">2</span>) + Math.Pow(p1.Y, <span class="number">2</span>) - Math.Pow(p3.Y, <span class="number">2</span>) + Math.Pow(d3, <span class="number">2</span>) - Math.Pow(d1, <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="comment">//相当于②式-③式</span></div><div class="line">    <span class="keyword">double</span> D = p2.X - p3.X;</div><div class="line">    <span class="keyword">double</span> E = p2.Y - p3.Y;</div><div class="line">    <span class="keyword">double</span> F = Math.Pow(p2.X, <span class="number">2</span>) - Math.Pow(p3.X, <span class="number">2</span>) + Math.Pow(p2.Y, <span class="number">2</span>) - Math.Pow(p3.Y, <span class="number">2</span>) + Math.Pow(d3, <span class="number">2</span>) - Math.Pow(d2, <span class="number">2</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//计算结果</span></div><div class="line">    <span class="keyword">double</span> x0 = (B * F - E * C) / (<span class="number">2</span> * B * D - <span class="number">2</span> * A * E);</div><div class="line">    <span class="keyword">double</span> y0 = (A * F - D * C) / (<span class="number">2</span> * A * E - <span class="number">2</span> * B * D);</div><div class="line"></div><div class="line">    Point resultPoint;</div><div class="line">    resultPoint.X = x0;</div><div class="line">    resultPoint.Y = y0;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> resultPoint;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已知三个点的坐标和未知点到这三个点的距离，求未知点？
    
    </summary>
    
      <category term="Build篇" scheme="http://ex2tron.coding.me/categories/Build%E7%AF%87/"/>
    
    
      <category term="三角定位" scheme="http://ex2tron.coding.me/tags/%E4%B8%89%E8%A7%92%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>构建：杀死变量</title>
    <link href="http://ex2tron.coding.me/2017/09/28/%E6%9E%84%E5%BB%BA%EF%BC%9A%E6%9D%80%E6%AD%BB%E5%8F%98%E9%87%8F/"/>
    <id>http://ex2tron.coding.me/2017/09/28/构建：杀死变量/</id>
    <published>2017-09-28T13:23:45.000Z</published>
    <updated>2018-04-08T10:54:42.250Z</updated>
    
    <content type="html"><![CDATA[<p>如果你仔细回想一下，平日阅读代码的时候，是什么占用了你大量的时间和精力？毫无疑问：变量。<a id="more"></a></p>
<blockquote>
<p><em>Why do we fall, Bruce? So we can learn to pick ourselves up.</em>  ——《<a href="https://movie.douban.com/subject/1309069/" target="_blank" rel="external">Batman Begins</a>》<br><br><em>我们为何会跌倒？这样我们才可以学会自己爬起来。</em>——《<a href="https://movie.douban.com/subject/1309069/" target="_blank" rel="external">蝙蝠侠：侠影之谜</a>》</p>
</blockquote>
<hr>
<p>如果一个变量在代码中很分散，阅读者在同一时间内考虑的代码行数势必会增加，编写者引入Bug的概率也会增大。那么，该如何从减少变量的作用域角度提高代码质量呢？</p>
<blockquote>
<p>本文相关内容仍旧是我阅读<a href="https://www.amazon.cn/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8-%E5%8F%B2%E8%92%82%E5%A4%AB%E2%80%A2%E8%BF%88%E5%85%8B%E5%BA%B7%E5%A5%88%E5%B0%94/dp/B0061XKRXA/ref=sr_1_1?ie=UTF8&amp;qid=1506601446&amp;sr=8-1&amp;keywords=%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8" target="_blank" rel="external">《代码大全》</a>时的笔记与总结，大佬勿喷！</p>
</blockquote>
<h3 id="变量跨度与存活时间"><a href="#变量跨度与存活时间" class="headerlink" title="变量跨度与存活时间"></a>变量跨度与存活时间</h3><h4 id="建议一：把对变量的引用尽可能集中在一起，使变量局部化"><a href="#建议一：把对变量的引用尽可能集中在一起，使变量局部化" class="headerlink" title="建议一：把对变量的引用尽可能集中在一起，使变量局部化"></a>建议一：把对变量的引用尽可能集中在一起，使变量局部化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = 0; </div><div class="line">b = 0;</div><div class="line">c = 0;</div><div class="line">a = b + c;</div><div class="line">b += 1;</div></pre></td></tr></table></figure>
<p>跨度（span）是衡量变量不同引用点靠近程度的一种方法。比如说上面的代码，对a的第一次引用和第二次引用之间有2行代码，那么变量a的跨度就是2。引用多次的话，可以取平均跨度。如b的第一次和第二次引用之间行数为1，第二次和第三次引用之间行数为0，所以平均跨度span(b)=(1+0)/2=0.5。</p>
<p>另外一个概念是：存活时间（live time）。跟跨度类似，不过存活时间只跟变量第一次和最后一次引用有关。比如对于上面代码中的b变量，跨度是0.5，但是存活时间是4条语句。</p>
<p>显然，我们的目标就是<strong>缩短变量的跨度和存活时间</strong>。如果用这两个概念考察全局变量，就会发现全局变量的跨度和存活时间都很长，这也是为什么避免使用全局变量的原因之一。</p>
<h3 id="减小作用域的建议"><a href="#减小作用域的建议" class="headerlink" title="减小作用域的建议"></a>减小作用域的建议</h3><h4 id="建议二：把相关语句放在一起"><a href="#建议二：把相关语句放在一起" class="headerlink" title="建议二：把相关语句放在一起"></a>建议二：把相关语句放在一起</h4><p>把变量的引用点集中在一起，使代码易于自上而下的阅读，举例来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//跳来跳去的糟糕代码</div><div class="line">MarketingData marketingData;</div><div class="line">SalesData salesData;</div><div class="line">TravelData travelData;</div><div class="line"></div><div class="line">travelData.ComputeWeekly();</div><div class="line">salesData.ComputeWeekly();</div><div class="line">marketingData.ComputeWeekly();</div><div class="line"></div><div class="line">salesData.ComputeAnnually();</div><div class="line">travelData.ComputeAnnually();</div><div class="line">marketingData.ComputeAnnually();</div><div class="line"></div><div class="line">salesData.print();</div><div class="line">travelData.print();</div><div class="line">marketingData.print();</div></pre></td></tr></table></figure>
<p>显然，如果你要想知道marketingData的计算流程，就必须在这段代码的不同行数跳跃。所以，这样组织代码会更好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//组织良好，从上而下阅读</div><div class="line">MarketingData marketingData;</div><div class="line">marketingData.ComputeWeekly();</div><div class="line">marketingData.ComputeAnnually();</div><div class="line">marketingData.print();</div><div class="line"></div><div class="line">SalesData salesData;</div><div class="line">salesData.ComputeWeekly();</div><div class="line">salesData.ComputeAnnually();</div><div class="line">salesData.print();</div><div class="line"></div><div class="line">TravelData travelData;</div><div class="line">travelData.ComputeWeekly();</div><div class="line">travelData.ComputeAnnually();</div><div class="line">travelData.print();</div></pre></td></tr></table></figure>
<p>《代码大全》中介绍了一种简便的检查相关语句是否组成得当的方法，把你的代码片段打印出来，然后把相关的语句画上框，组织得当的话， 这些框是不会重叠的：</p>
<p><img src="http://pic.ex2tron.top/good_grouping_related_statements.png" alt="good_grouping_related_statements"></p>
<h4 id="建议三：把相关语句提取成单独的子程序"><a href="#建议三：把相关语句提取成单独的子程序" class="headerlink" title="建议三：把相关语句提取成单独的子程序"></a>建议三：把相关语句提取成单独的子程序</h4><p>更短的子程序相比长的子程序，变量的跨度和存活时间更小。比如，可以尝试这样重构上面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//重构，提取子程序</div><div class="line">ComputeMarketingData();</div><div class="line"></div><div class="line">ComputeSalesData();</div><div class="line"></div><div class="line">ComputeTravelData();</div></pre></td></tr></table></figure>
<h4 id="建议四：开始使用最小的作用域，然后根据需求再扩展"><a href="#建议四：开始使用最小的作用域，然后根据需求再扩展" class="headerlink" title="建议四：开始使用最小的作用域，然后根据需求再扩展"></a>建议四：开始使用最小的作用域，然后根据需求再扩展</h4><p>一句话解释就是：<strong>把全局变量转换为成员局部变量要比局部变量转换为全局变量难的多</strong>。因此，在设计程序时，如果对变量的作用域犹豫不决时，优先倾向于最小的作用域。</p>
<h4 id="建议五：循环开始之前再去初始化循环变量"><a href="#建议五：循环开始之前再去初始化循环变量" class="headerlink" title="建议五：循环开始之前再去初始化循环变量"></a>建议五：循环开始之前再去初始化循环变量</h4><p>一个不好的编程习惯就是在程序开头初始化好循环所使用的变量，如<code>int i = 0,j = 0;</code>。而在很后面才使用到循环。这样做的坏处一是查看循环时需要跳到开头才知道循环变量的值，另外，如果要修改这个循环，往往会忘记同时修改循环变量。</p>
<p>往期【构建法】系列回顾：</p>
<ul>
<li><a href="http://www.lofter.com/lpost/1d7338a1_f50d92d" target="_blank" rel="external">构建法、单点控制</a></li>
<li><a href="http://www.lofter.com/lpost/1d7338a1_10204bea" target="_blank" rel="external">构建法、表驱动法</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你仔细回想一下，平日阅读代码的时候，是什么占用了你大量的时间和精力？毫无疑问：变量。
    
    </summary>
    
      <category term="Build篇" scheme="http://ex2tron.coding.me/categories/Build%E7%AF%87/"/>
    
    
      <category term="构建法" scheme="http://ex2tron.coding.me/tags/%E6%9E%84%E5%BB%BA%E6%B3%95/"/>
    
      <category term="变量" scheme="http://ex2tron.coding.me/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="作用域" scheme="http://ex2tron.coding.me/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>【片单】诺兰神作集</title>
    <link href="http://ex2tron.coding.me/2017/09/24/%E3%80%90%E7%89%87%E5%8D%95%E3%80%91%E8%AF%BA%E5%85%B0%E7%A5%9E%E4%BD%9C%E9%9B%86/"/>
    <id>http://ex2tron.coding.me/2017/09/24/【片单】诺兰神作集/</id>
    <published>2017-09-24T12:37:41.000Z</published>
    <updated>2017-12-20T09:07:45.763Z</updated>
    
    <content type="html"><![CDATA[<p>有的导演，虽然没拿过奥斯卡，作品不多，但每部却都被影迷奉为神作，没错，说的就是诺神。<a id="more"></a>：<a href="https://baike.baidu.com/item/克里斯托弗·诺兰" target="_blank" rel="external">克里斯托弗·诺兰</a></p>
<h2 id="克里斯托弗·诺兰"><a href="#克里斯托弗·诺兰" class="headerlink" title="克里斯托弗·诺兰"></a><a href="https://baike.baidu.com/item/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E5%BC%97%C2%B7%E8%AF%BA%E5%85%B0" target="_blank" rel="external">克里斯托弗·诺兰</a></h2><p>今天周末，回顾了下诺神的<a href="https://movie.douban.com/subject/1851857/" target="_blank" rel="external">蝙蝠侠</a>和<a href="https://movie.douban.com/subject/3541415/" target="_blank" rel="external">盗梦空间</a>，加上前段时间刚看完<a href="https://movie.douban.com/subject/26607693/" target="_blank" rel="external">敦刻尔克</a>，按耐不住，就分享下诺兰的神作电影下载链接吧。</p>
<blockquote>
<p>大部分片源来自人人影视字幕组，作品按时间倒序，点击片名即可下载。</p>
</blockquote>
<h3 id="敦刻尔克-Dunkirk"><a href="#敦刻尔克-Dunkirk" class="headerlink" title="敦刻尔克 | Dunkirk"></a><a href="ed2k://|file|敦刻尔克.Dunkirk.2017.1080p.BluRay.x264.中英字幕-Fantopia.mp4|2418179223|b806cdcd02f7fbd63ce89832aa186ba3|h=452tao356tv7yxm75mzernkj43akb4ib|/" target="_blank" rel="external">敦刻尔克 | Dunkirk</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/fudEG1VUWuOqleXv6NwCExK0VLy.jpg" alt="Dunkirk"></p>
<h3 id="星际穿越-Interstellar"><a href="#星际穿越-Interstellar" class="headerlink" title="星际穿越 | Interstellar"></a><a href="ed2k://|file|Interstellar.2014.%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A.720p.Chi_Eng.ZMZ-BD-MP4-V2.mp4|2448135931|ad26bb8d5386690810d948ece0499744|h=zo7ee5uktzrarrfj37z2bpk3enoxsxxz|/" target="_blank" rel="external">星际穿越 | Interstellar</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/walWq52PP2IGRc98VkPG7Wp77lK.jpg" alt="Interstellar"></p>
<h3 id="蝙蝠侠：黑暗骑士崛起-The-Dark-Knight-Rises"><a href="#蝙蝠侠：黑暗骑士崛起-The-Dark-Knight-Rises" class="headerlink" title="蝙蝠侠：黑暗骑士崛起 | The Dark Knight Rises"></a><a href="ed2k://|file|The.Dark.Knight.Rises.2012.%E8%9D%99%E8%9D%A0%E4%BE%A0%E5%89%8D%E4%BC%A03.%E9%BB%91%E6%9A%97%E9%AA%91%E5%A3%AB%E5%B4%9B.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2696715142|1b873142c39aa7bfe7924264026b0ae4|h=s3nom7fhjxntisny4hypfimmmtxzcyw2|/" target="_blank" rel="external">蝙蝠侠：黑暗骑士崛起 | The Dark Knight Rises</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/3bgtUfKQKNi3nJsAB5URpP2wdRt.jpg" alt="The Dark Knight Rises"></p>
<h3 id="盗梦空间-Inception"><a href="#盗梦空间-Inception" class="headerlink" title="盗梦空间 | Inception"></a><a href="ed2k://|file|盗梦空间.Inception.2010.中英字幕.BDrip.AAC.720p.x264-人人影视.mp4|2216102241|744dced4b7d5c6fa22db48188c6b7327|h=vn5yfyvbcn2p2gf673pfrscnnonahxbj|/" target="_blank" rel="external">盗梦空间 | Inception</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/s2bT29y0ngXxxu2IA8AOzzXTRhd.jpg" alt="Inception"></p>
<h3 id="蝙蝠侠：黑暗骑士-The-Dark-Knight"><a href="#蝙蝠侠：黑暗骑士-The-Dark-Knight" class="headerlink" title="蝙蝠侠：黑暗骑士 | The Dark Knight"></a><a href="ed2k://|file|The.Dark.Knight.2008.%E8%9D%99%E8%9D%A0%E4%BE%A0%E5%89%8D%E4%BC%A02%EF%BC%9A%E9%BB%91%E6%9A%97%E9%AA%91%E5%A3%AB.%E5%8F%8C%E8%AF%AD%E5%AD%97%E5%B9%95.%E5%9B%BD%E8%8B%B1%E9%9F%B3%E8%BD%A8.HR-HDTV.AC3.1024X576.x264-%E4%BA%BA%E4%BA%BA%E5%BD%B1%E8%A7%86%E5%88%B6%E4%BD%9C.mkv|2869506431|c9f803597ad8ffa4d7acda888129cc94|h=ehcceg3xz2qx3msc7jvebyvmghbnd4n6|/" target="_blank" rel="external">蝙蝠侠：黑暗骑士 | The Dark Knight</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/nnMC0BM6XbjIIrT4miYmMtPGcQV.jpg" alt="The Dark Knight"></p>
<h3 id="致命魔术-The-Prestige"><a href="#致命魔术-The-Prestige" class="headerlink" title="致命魔术 | The Prestige"></a><a href="ed2k://|file|The.Prestige.致命魔术.双语字幕.HR-HDTV.AC3.1024X576.x264-人人影视制作.mkv|2077111129|A18F57470B0AB144D1B4889C8ECAF3C0|h=U6WQH2SXKRDMDCMTARJKD2IH7WOS2UUU|/" target="_blank" rel="external">致命魔术 | The Prestige</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/nbQQ6L4qRTk0WMVkRhTxc4MMRd9.jpg" alt="The Prestige"></p>
<h3 id="蝙蝠侠-侠影之谜-Batman-Begins"><a href="#蝙蝠侠-侠影之谜-Batman-Begins" class="headerlink" title="蝙蝠侠.侠影之谜 | Batman Begins"></a><a href="ed2k://|file|蝙蝠侠.侠影之谜.Batman.Begins.2005.BD-720p.1280X720.中英双语-电波字幕组.mkv|2490413875|E8FA6BDC8DD5A22E1582728C2B34B5E3|h=D2EEMY7CD7GJ33GNLHEMFSPQVPC3IZ6I|/" target="_blank" rel="external">蝙蝠侠.侠影之谜 | Batman Begins</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/v0p5dxVa9Giq6e0h31VifY0dWOX.jpg" alt="Batman Begins"></p>
<h3 id="记忆碎片-Memento"><a href="#记忆碎片-Memento" class="headerlink" title="记忆碎片 | Memento"></a><a href="ed2k://|file|Memento.10th.Anniversary.2000.记忆碎片.双语字幕.HR-HDTV.AC3.1024X544.X264-人人影视制作.mkv|1944503362|EDA2166CB8699364B9062F7F9CB700EC|h=ETS47DE4SLODZQSZ5LU2RVF6V5VA36GW|/" target="_blank" rel="external">记忆碎片 | Memento</a></h3><p><img src="https://image.tmdb.org/t/p/w740_and_h416_bestv2/oBUznaSdjkY3HtQUzAxgdIZqh4w.jpg" alt="Memento"></p>
<p>p.s.本文所有的图片均来自<a href="https://www.themoviedb.org/" target="_blank" rel="external">TMDB</a>，如果你觉得很酷炫的话，我会在后期开发一款专门下载影视壁纸的APP，敬请期待！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的导演，虽然没拿过奥斯卡，作品不多，但每部却都被影迷奉为神作，没错，说的就是诺神。
    
    </summary>
    
      <category term="谈电影" scheme="http://ex2tron.coding.me/categories/%E8%B0%88%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="诺兰" scheme="http://ex2tron.coding.me/tags/%E8%AF%BA%E5%85%B0/"/>
    
  </entry>
  
  <entry>
    <title>【利器篇】七牛云——用做每月免费10G的图床</title>
    <link href="http://ex2tron.coding.me/2017/09/18/%E3%80%90%E5%88%A9%E5%99%A8%E7%AF%87%E3%80%91%E4%B8%83%E7%89%9B%E4%BA%91%EF%BC%9A%E7%94%A8%E5%81%9A%E6%AF%8F%E6%9C%88%E5%85%8D%E8%B4%B910G%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <id>http://ex2tron.coding.me/2017/09/18/【利器篇】七牛云：用做每月免费10G的图床/</id>
    <published>2017-09-18T11:55:38.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>随着越来越多的人开始使用Markdown写自己的独立博客，一个好用稳定的图床是必不可少的了。<a id="more"></a></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>在<a href="https://www.qiniu.com/" target="_blank" rel="external">七牛云</a>之前，我使用过国外的<a href="https://www.getcloudapp.com/" target="_blank" rel="external">Cloud App</a>和<a href="https://www.aliyun.com/product/oss?utm_content=se_877546" target="_blank" rel="external">阿里云的oss对象存储</a>。</p>
<ol>
<li><p>首先，国外的东西在国内稳定性和速度都是相对较差的，我试着在阿里云和Cloud App上上传同一张图片并生成外链，Cloud App要比阿里的加载速度延迟1-2s，阿里基本秒开。</p>
</li>
<li><p>阿里的oss对象存储虽然很稳定，但是并不提供免费的空间。相对来说，七牛云提供的每月10G免费流量，对于博客来说，绰绰有余了。</p>
</li>
<li><p>另外，七牛云提供了诸多的图片处理接口，如水印、格式转换、缩放等，很实用，很强大。</p>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>注册并登陆<a href="https://www.qiniu.com/" target="_blank" rel="external">七牛云</a>，在七牛云的产品列表中，添加一个<code>对象存储</code>，如这里取名为<code>picblog</code>：</p>
<p><img src="http://pic.ex2tron.top/create_new_bucket.png" alt="create_new_bucket"></p>
<p>创建好之后，七牛云会自动生成一个测试域名：</p>
<p><img src="http://pic.ex2tron.top/test_domain_name.png" alt="test_domain_name"></p>
<p>这个域名就是你文件的前缀了。比如，我们点击<code>内容管理</code>，点击<code>上传文件</code>，选择一幅图片上传。上传完成后，复制该文件的外链地址：</p>
<p><img src="http://pic.ex2tron.top/copy_file_link.png" alt="copy_file_link"></p>
<p>这个地址就是你的图片地址辣，你可以在浏览器中访问该地址，比如你可以访问我的这个：<a href="http://pic.ex2tron.top/mycli_demo.gif" target="_blank" rel="external">mysql_demo</a></p>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="添加二级域名"><a href="#添加二级域名" class="headerlink" title="添加二级域名"></a>添加二级域名</h3><p>如同前面那张图上所说，七牛云默认的测试域名有很多限制。所以，你如果已经购买了域名的话，可以在这里绑定自己的二级域名，这样既好记又方便管理。</p>
<p>比如，这里我已经在万网上购买了<code>ex2tron.xin</code>的域名，这里我演示如何将七牛云的存储空间绑定<code>pic.ex2tron.xin</code>这个域名。</p>
<p>在七牛云的存储空间页面，点击<code>绑定域名</code>，只需要在加速域名处填写要绑定的域名，其他项保持默认即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">加速域名： pic.ex2tron.xin</div></pre></td></tr></table></figure></p>
<p><img src="http://pic.ex2tron.top/bucket_binding_domain_name.png" alt="bucket_binding_domain_name"></p>
<p>创建后，系统会配置一段时间，等待处理完成，会显示一个诸如<code>xxx.qiniudns.com</code>的CNAME记录值，记下此值，后面要用到。</p>
<p><img src="http://pic.ex2tron.top/cname_for_binding.png" alt="cname_for_binding"></p>
<h3 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h3><p>打开万网的域名控制台，添加一条CNAME的解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">记录类型：CNAME</div><div class="line">主机记录：pic</div><div class="line">记录值：xxx.qiniudns.com</div><div class="line"># 其他选型保持默认</div></pre></td></tr></table></figure></p>
<p><img src="http://pic.ex2tron.top/add_dns_for_qiniu.png" alt="add_dns_for_qiniu"></p>
<p>这样，你上传的图片外链就是：<code>http://pic.ex2tron.xin/filename.png</code>之类的了。</p>
<h2 id="添加图片样式"><a href="#添加图片样式" class="headerlink" title="添加图片样式"></a>添加图片样式</h2><p>利用七牛云做图床的另外一个强大之处在于丰富的图片样式。点击<code>图片样式</code>-<code>新建图片样式</code>，七牛云提供了如下很多种场景：</p>
<p><img src="http://pic.ex2tron.top/api_for_image_process.png" alt="api_for_image_process"></p>
<p>比如，这里我们选择<code>指定宽高，强行缩放+打图片水印</code>，然后添加一个文字水印，可以调整文字的字体样式，位置等等：</p>
<p><img src="http://pic.ex2tron.top/add_water_mark_api.png" alt="add_water_mark_api"></p>
<p>调整好之后，为样式取个名称，如<code>webpic</code>，这样，只要在原来外链的后面添加<code>-webpic</code>就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://pic.ex2tron.xin/filename.png-webpic</div></pre></td></tr></table></figure>
<p>其中<code>-</code>这个连接符可以通过存储空间控制面板的<code>样式分隔符设置</code>中进行修改。</p>
<h2 id="图床工具"><a href="#图床工具" class="headerlink" title="图床工具"></a>图床工具</h2><p>对于七牛云，每张图片都在网页端上传还是比较麻烦的，所以用一些图床客户端工具会更加快速。</p>
<p>这里推荐使用<a href="http://mpic.lzhaofu.cn/" target="_blank" rel="external">MPic</a>图床神器。打开软件后，设置好自己的AK和SK（可在七牛云的个人中心-密钥管理中看到）。MPic支持文件拖拽上传，点击复制就可以复制外链，非常方便：</p>
<p><img src="http://pic.ex2tron.top/mpic_qiniu.png" alt="mpic_qiniu"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着越来越多的人开始使用Markdown写自己的独立博客，一个好用稳定的图床是必不可少的了。
    
    </summary>
    
      <category term="利器篇" scheme="http://ex2tron.coding.me/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="七牛" scheme="http://ex2tron.coding.me/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="图床" scheme="http://ex2tron.coding.me/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages轻松搭博客(2)：在Github上部署</title>
    <link href="http://ex2tron.coding.me/2017/09/13/Hexo-Github-Pages%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%8D%9A%E5%AE%A2-2%EF%BC%9A%E5%9C%A8Github%E4%B8%8A%E9%83%A8%E7%BD%B2/"/>
    <id>http://ex2tron.coding.me/2017/09/13/Hexo-Github-Pages轻松搭博客-2：在Github上部署/</id>
    <published>2017-09-13T12:15:47.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>使用免费的Github Pages服务或者部署在自己服务器上，别人就可以访问你的博客啦！<a id="more"></a></p>
<p>如果你已经有配置好的云服务器，直接可以将Hexo博客生成的public目录文件放在服务器上就好了。比如我购买的是阿里云服务器（apache），只需要将public下的文件放在<em>/var/www/html/</em>下面就可以用你服务器地址访问博客了。很容易，不过，考虑到云服务器的价格，这里我们还是用免费的Github吧。</p>
<hr>
<h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><p>首先登陆<a href="https://github.com/" target="_blank" rel="external">Github</a>，没有账号的话，先注册一个。新建一个名为username.github.io的仓库，<strong>username必须与你的账户名相同</strong>，比如我的就是ex2tron.github.io，这就是你博客的域名地址了（绑定独立域名之后再说）。<strong>新建时注意勾选”<em>Initialize this repository with a README</em>“</strong>，因为这个仓库必须不能为空。</p>
<blockquote>
<p>如果你是git新用户的话，推荐看：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="external">廖雪峰的Git教程-远程仓库</a></p>
</blockquote>
<p><img src="http://pic.ex2tron.top/create_github_pages_repository.png" alt="create_github_pages_repository"></p>
<p>接下来打开博客目录下的_config.yml配置文件，定位到最后的deploy选项，修改如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">git</span></div><div class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:ex2tron/ex2tron.github.io.git</span></div><div class="line"><span class="attr">  branch:</span> <span class="string">master</span></div></pre></td></tr></table></figure></p>
<p>注意冒号后面有个空格，不然会出错滴~~~配置好之后，使用下面的命令就可以部署到Github上了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo g</div><div class="line">$ hexo d</div></pre></td></tr></table></figure></p>
<p>这样通过Github提供的域名地址（如我的：<a href="https://ex2tron.github.io" target="_blank" rel="external">https://ex2tron.github.io</a>）就可以访问你的博客了，简单快速高效！</p>
<h2 id="发布新博客"><a href="#发布新博客" class="headerlink" title="发布新博客"></a>发布新博客</h2><p>博客搭建起来之后，就可以用Markdown写博客辣，使用下面的命令，创建新博客（如名为：我的第一篇博客）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">'我的第一篇博客'</span></div></pre></td></tr></table></figure></p>
<p>此命令会在博客目录\source_posts\h下生成“我的第一篇博客.md”文件，这就是你的博客源文件啦，文件开头如下，记得冒号后面有空格噢，不然会出错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: 我的第一篇博客</div><div class="line">date: 2017-09-13 20:15:47</div><div class="line">tags: #文章标签，格式：[1,2,3]</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>不熟悉Markdown语法的可以看：<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown 语法说明</a>。写完之后依然使用之前的三条命令发布：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo g</div><div class="line">$ hexo d</div></pre></td></tr></table></figure></p>
<p>后面两条指令也可以简化为一条：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g -d</div></pre></td></tr></table></figure></p>
<h2 id="常出现的问题"><a href="#常出现的问题" class="headerlink" title="常出现的问题"></a>常出现的问题</h2><ol>
<li><p>在hexo d进行部署时，如果出现ERROR Deployer not found: git的问题，可以先用下面的命令修复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
</li>
<li><p>如果你没配置过ssh导致部署失败（可以通过ssh -T username@example.com来测试ssh有无配置成功），可以参考这篇文章：<a href="http://www.cnblogs.com/xsilence/p/6001938.html" target="_blank" rel="external">针对github权限导致hexo部署失败的解决方案</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用免费的Github Pages服务或者部署在自己服务器上，别人就可以访问你的博客啦！
    
    </summary>
    
      <category term="Build篇" scheme="http://ex2tron.coding.me/categories/Build%E7%AF%87/"/>
    
    
      <category term="Hexo" scheme="http://ex2tron.coding.me/tags/Hexo/"/>
    
      <category term="Github" scheme="http://ex2tron.coding.me/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages轻松搭博客(1)</title>
    <link href="http://ex2tron.coding.me/2017/09/13/Hexo-Github-Pages%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%8D%9A%E5%AE%A2-1/"/>
    <id>http://ex2tron.coding.me/2017/09/13/Hexo-Github-Pages轻松搭博客-1/</id>
    <published>2017-09-13T08:07:06.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>想用Github Pages轻松搭建自己的博客，用Hexo，10分钟！<a id="more"></a></p>
<blockquote>
<p>废话区域：我在接触Hexo（可以读作Hack So）之前，绝对没少尝试建立一个完全自由、自己说了算的独立博客：WordPress定位重量级，功能强大，生成的是动态网站，依赖数据库……太繁琐了，放弃~而Jekyll和Hexo都是静态建站工具，但Jekyll的依赖项也很多，也不简约，不想用~最后才是名气相对不高的Hexo，相信我，熟练的情况下，10分钟就可以搭出来：</p>
</blockquote>
<hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>是一个免费的静态Blog生成工具。简单来说，就是把你写的Markdown博客文件生成静态网页，把这个网页放在Github或者你自己的服务器上就可以快速访问了。软件界，从来不缺自动化工具(ง •_•)ง</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网文档：<a href="https://hexo.io/docs/" target="_blank" rel="external">Hexo Docs</a></p>
<p>Hexo安装前，你的电脑上需要先有下面这两个东西：</p>
<ul>
<li><a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a></li>
<li><a href="https://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<p>如果已经安装了的话，命令行下一句话就好啦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<h2 id="初始化博客目录"><a href="#初始化博客目录" class="headerlink" title="初始化博客目录"></a>初始化博客目录</h2><p>在你的本地新建一个存放博客的目录，比如”<em>D:\MyHexoBlog</em>“，然后在这个目录右键，选择”<em>Git Bash Here</em>“，输入下面两条命令进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<p>初始化完成之后，你的目录结构应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── source</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└── themes</div></pre></td></tr></table></figure>
<p>如果没有出错的话，继续执行下面的指令启动服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g </div><div class="line">$ hexo s</div></pre></td></tr></table></figure>
<p>启动之后，在浏览器中访问：<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>，是不是看到了漂亮的Hexo博客页面了。不过目前这个博客还是运行在你本机上的，下篇我们看一下怎么样让别人也能访问这个博客。</p>
<p><img src="http://pic.ex2tron.top/default_hexo_theme.png" alt="default_hexo_index"></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><p><a href="https://hexo.io/docs/" target="_blank" rel="external">Hexo Docs</a></p>
</li>
<li><p><a href="http://blog.csdn.net/cl534854121/article/details/76121066" target="_blank" rel="external">Hexo+Github搭建个人博客(一)——开始搭建</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想用Github Pages轻松搭建自己的博客，用Hexo，10分钟！
    
    </summary>
    
      <category term="Build篇" scheme="http://ex2tron.coding.me/categories/Build%E7%AF%87/"/>
    
    
      <category term="Hexo" scheme="http://ex2tron.coding.me/tags/Hexo/"/>
    
      <category term="Github" scheme="http://ex2tron.coding.me/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>【利器篇】用VS Code写Markdown</title>
    <link href="http://ex2tron.coding.me/2017/09/11/%E3%80%90%E5%88%A9%E5%99%A8%E7%AF%87%E3%80%91%E7%94%A8VSCode%E5%86%99Markdown/"/>
    <id>http://ex2tron.coding.me/2017/09/11/【利器篇】用VSCode写Markdown/</id>
    <published>2017-09-11T07:11:22.000Z</published>
    <updated>2017-12-20T09:20:00.144Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown以其简洁、优雅整齐的风格，成为目前非常流行的博客文件格式。甚至有人说：每个人都应该用Markdown写博客<a id="more"></a>。关于Markdown相较富文本的优势，我就不细说了。</p>
<h2 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h2><p>支持Markdown的工具有很多，大家可以参考网上，如这篇文章：<a href="https://sspai.com/post/32483" target="_blank" rel="external">码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点</a>。就我自己目前在Windows上使用的而言有：<a href="http://www.jianshu.com/" target="_blank" rel="external">简书</a>、<a href="http://note.youdao.com/" target="_blank" rel="external">有道云笔记</a>、<a href="https://www.typora.io/#windows" target="_blank" rel="external">Typora</a>、<a href="https://code.visualstudio.com" target="_blank" rel="external">VSCode</a></p>
<p>简书本身就是一个博客平台，有道云笔记是类似OneNote和印象笔迹的应用。如果你已经在使用这两个平台的话，就不用多说了。但如果只是想用一个单纯的Markdown编辑器的话，推荐极致简洁的Typora。虽说界面简洁，但功能强大，不仅内置了常见的一些Markdown样式，还支持PDF/HTML等多种格式导出：</p>
<p><img src="http://pic.ex2tron.top/markdown_in_typora.png" alt="markdown_in_typora"></p>
<p>你是一枚文青的话，千万不要错过这款编辑器。不过，对于程序猿来说，VSCode才显得更有味道。</p>
<h2 id="用VSCode写Markdown"><a href="#用VSCode写Markdown" class="headerlink" title="用VSCode写Markdown"></a>用VSCode写Markdown</h2><p>VSCode就不过多介绍了，我之前也写过关于它的介绍：</p>
<ul>
<li><p><a href="http://ex2tron.lofter.com/post/1d7338a1_86f8f92" target="_blank" rel="external">Visual Studio Code Preview初体验</a></p>
</li>
<li><p><a href="http://ex2tron.lofter.com/post/1d7338a1_870beb7" target="_blank" rel="external">Visual Studio Code Preview深度体验、使用技巧</a></p>
</li>
</ul>
<p>现在版本的VSCode默认已经支持Markdown预览，不需要下载插件。用VSCode打开md文件或将当前文件更改为Markdown格式就可以开始书写了：</p>
<p><img src="http://pic.ex2tron.top/markdown_in_vscode.png" alt="markdown_in_vscode"></p>
<p>VSCode支持两种预览方式：</p>
<ul>
<li>按下Ctrl+K V，像上图一样左右同步实时预览</li>
<li>按下Ctrl+Shift+V，只预览最终渲染结果</li>
</ul>
<p><img src="http://pic.ex2tron.top/editor_preview_Synchronization.gif" alt="editor_preview_Synchronization"></p>
<p>如上图，编写和预览界面是实时同步的，不需要的话，可以按下Ctrl+,组合键，添加如下两条设置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"markdown.preview.scrollEditorWithPreview": false,</div><div class="line">"markdown.preview.scrollPreviewWithEditorSelection": false</div></pre></td></tr></table></figure>
<p>另外，目前VSCode预览样式中，中文的显示很别扭，这里推荐下载<a href="https://github.com/ex2tron/MyLibsAndSamples/blob/master/Configs/VSCode/markdown-github.css" target="_blank" rel="external">Github风格的CSS</a></p>
<p>下载完成后，配置css文件的设置如下即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"markdown.styles": [</div><div class="line">    <span class="string">"file:///D:/markdown-github.css"</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>另外，VSCode中有很多Markdown相关的插件，如”Markdown All in One”和”Markdown Theme Kit”等，大家可以下载下来尝试一下哈！</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://code.visualstudio.com/docs/languages/markdown" target="_blank" rel="external">Markdown editing with Visual Studio Code</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown以其简洁、优雅整齐的风格，成为目前非常流行的博客文件格式。甚至有人说：每个人都应该用Markdown写博客
    
    </summary>
    
      <category term="利器篇" scheme="http://ex2tron.coding.me/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="Markdown" scheme="http://ex2tron.coding.me/tags/Markdown/"/>
    
      <category term="VSCode" scheme="http://ex2tron.coding.me/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>【利器篇】MyCLI：自动补全和语法高亮的MySQL命令行工具</title>
    <link href="http://ex2tron.coding.me/2017/09/11/%E3%80%90%E5%88%A9%E5%99%A8%E7%AF%87%E3%80%91MyCLI%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E7%9A%84MySQL%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    <id>http://ex2tron.coding.me/2017/09/11/【利器篇】MyCLI：自动补全和语法高亮的MySQL命令行工具/</id>
    <published>2017-09-11T06:32:14.000Z</published>
    <updated>2017-12-25T15:17:44.463Z</updated>
    
    <content type="html"><![CDATA[<p>mycli是MySQL命令行工具，支持关键字语法高亮和自动补全，看上面的动图你就知道了。<a id="more"></a></p>
<p>mycli不仅会提示MySQL的关键字，更牛掰的是数据库名、表名、字段名都可以提示，非常方便。如果你经常在命令行里码MySQL命令，相信这款工具一定会让你满意。</p>
<p>官网：<a href="http://www.mycli.net/" target="_blank" rel="external">MyCLI</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>其实mycli是一个Python的包，所以你已经安装了Python(pip)的话，用下面一条指令就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mycli</div></pre></td></tr></table></figure>
<p>如果出现问题，可以参考<a href="http://www.mycli.net/" target="_blank" rel="external">官网</a>，有详细的说明。</p>
<p><img src="http://pic.ex2tron.top/install_mycli.png" alt="install_mycli"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装好之后，在cmd下，将以往登陆MySQL用的mysql换成mycli就可以了：</p>
<p><img src="http://pic.ex2tron.top/login_with_mycli.png" alt="login_with_mycli"></p>
<p>好了，大家觉得好用的话，欢迎扩散噢！</p>
<blockquote>
<p><em>Never give up. Never stop fighting. Excelsior!</em></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mycli是MySQL命令行工具，支持关键字语法高亮和自动补全，看上面的动图你就知道了。
    
    </summary>
    
      <category term="利器篇" scheme="http://ex2tron.coding.me/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="MyCLI" scheme="http://ex2tron.coding.me/tags/MyCLI/"/>
    
      <category term="MySQL" scheme="http://ex2tron.coding.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>博客新篇章！Brave New World</title>
    <link href="http://ex2tron.coding.me/2017/08/23/%E5%8D%9A%E5%AE%A2%E6%96%B0%E7%AF%87%E7%AB%A0%EF%BC%81/"/>
    <id>http://ex2tron.coding.me/2017/08/23/博客新篇章！/</id>
    <published>2017-08-23T12:56:32.000Z</published>
    <updated>2017-11-16T14:33:08.434Z</updated>
    
    <content type="html"><![CDATA[<p>从2014/08/23在lofter上写我的<a href="http://ex2tron.lofter.com/post/1d7338a1_86b724e" target="_blank" rel="external">第一篇博客</a>开始，已经过去了整整三年……<a id="more"></a></p>
<h2 id="再见，lofter"><a href="#再见，lofter" class="headerlink" title="再见，lofter"></a>再见，lofter</h2><p>lofter是一个非常不错的轻博客平台，我喜欢它的设计和定位。但lofter终究不适合程序猿，长久以来不支持markdown也让我很头痛。现在，终于还是要说再见了!</p>
<blockquote>
<p><a href="http://ex2tron.lofter.com" target="_blank" rel="external">http://ex2tron.lofter.com</a></p>
</blockquote>
<h2 id="旧的66篇博客"><a href="#旧的66篇博客" class="headerlink" title="旧的66篇博客"></a>旧的66篇博客</h2><h3 id="【Code-编程-开发】"><a href="#【Code-编程-开发】" class="headerlink" title="【Code/编程/开发】"></a>【Code/编程/开发】</h3><p><a href="http://www.lofter.com/lpost/1d7338a1_f50d92d" target="_blank" rel="external">构建法、单点控制</a></p>
<p><a href="http://www.lofter.com/lpost/1d7338a1_10204bea" target="_blank" rel="external">构建法、表驱动法</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_f0c9638" target="_blank" rel="external">【云端漫步】一起上“阿里云”（1）、购买学生党套餐</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_fea154c" target="_blank" rel="external">【云端漫步】一起上“阿里云”（2）、远程登陆服务器</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_ffa2f60" target="_blank" rel="external">【云端漫步】一起上“阿里云”（3）、LAMP环境搭建</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_ffad954" target="_blank" rel="external">【云端漫步】一起上“阿里云”（4）、搭建Git服务器</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_10171f1e" target="_blank" rel="external">【云端漫步】一起上“阿里云”（5）、域名购买和解析</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_f59f87a" target="_blank" rel="external">Python多字节二进制文件读取</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_eaa8b0d" target="_blank" rel="external">C#中集合List的深浅拷贝</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_eb8cdad" target="_blank" rel="external">C#中常用的集合List去重方法</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_f59ed25" target="_blank" rel="external">C#多字节二进制文件读取</a></p>
<p><a href="http://www.lofter.com/lpost/1d7338a1_da4b787" target="_blank" rel="external">深入理解C#（01）：堆栈、值类型和引用类型、值传递和引用传递</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_870bee8" target="_blank" rel="external">宽字符</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86c86dd" target="_blank" rel="external">编程命名法</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_8b70ad4" target="_blank" rel="external">编程字体推荐</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_a9009ce" target="_blank" rel="external">Json序列化与反序列化（1）-JavaScriptSerializer</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_cb8b36b" target="_blank" rel="external">Json序列化与反序列化（2）-Json.Net</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_cc1a00c" target="_blank" rel="external">Json序列化与反序列化（3）-DataContractJsonSerializer</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86b7467" target="_blank" rel="external">CR与LF（操作系统“下一行”的不同）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86f8f92" target="_blank" rel="external">Visual Studio Code Preview初体验</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_870beb7" target="_blank" rel="external">Visual Studio Code Preview深度体验、使用技巧</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_ca1a61f" target="_blank" rel="external">Brand7-品牌漆上架商店啦！</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_c388b82" target="_blank" rel="external">UWP应用Brand7开发小记（1）、判断App是否是第一次启动</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_c665a5c" target="_blank" rel="external">UWP应用Brand7开发小记（2）、用Excel和Json初始化本地数据源Part1</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_c66b082" target="_blank" rel="external">UWP应用Brand7开发小记（2）、用Excel和Json初始化本地数据源Part2</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_c7ae2f8" target="_blank" rel="external">UWP 应用Brand7开发小记（3）、判断GridView的滚动方向</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_c7f56c1" target="_blank" rel="external">UWP应用Brand7开发小记（4）、集合控件的虚拟化问题</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_cccfc2d" target="_blank" rel="external">UWP 应用Brand7开发小记（5）、控件嵌入标题栏</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_cc38035" target="_blank" rel="external">MySQL学习小记（1）-不能启动MySQL服务</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_cca3bd7" target="_blank" rel="external">MySQL学习小记（2）-添加远程访问权限详解</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_d3d0794" target="_blank" rel="external">MySQL学习小记（3）-外键的使用</a></p>
<p><a href="http://www.lofter.com/lpost/1d7338a1_d5494fc" target="_blank" rel="external">MySQL学习小记（4）-最大连接数</a></p>
<p><a href="http://www.lofter.com/lpost/1d7338a1_10c4cf02" target="_blank" rel="external">MySQL学习小记（5）-主从服务器同步</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86dd19e" target="_blank" rel="external">VS至强插件ReSharper指南01、安装入门</a></p>
<h3 id="【视觉与图像】"><a href="#【视觉与图像】" class="headerlink" title="【视觉与图像】"></a>【视觉与图像】</h3><p><a href="http://ex2tron.lofter.com/post/1d7338a1_fa820b3" target="_blank" rel="external">【视觉与图像】摄像头篇（1）、CCD靶面尺寸</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_fad34dc" target="_blank" rel="external">【视觉与图像】摄像头篇（2）、焦距和视角</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_10bc7d39" target="_blank" rel="external">CMake编译OpenCV3.2（Qt平台）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_10bc7e4e" target="_blank" rel="external">Qt+OpenCV环境搭建</a></p>
<h3 id="【Design-演示-设计】"><a href="#【Design-演示-设计】" class="headerlink" title="【Design/演示/设计】"></a>【Design/演示/设计】</h3><p><a href="http://ex2tron.lofter.com/post/1d7338a1_86c7385" target="_blank" rel="external">玩转PPT放映第一篇、演示者视图</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86dc94e" target="_blank" rel="external">玩转PPT放映第二篇、快捷键</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_870bc93" target="_blank" rel="external">玩转PPT放映第三篇、自定义放映</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86d9038" target="_blank" rel="external">【PPT动画】钟摆效果</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_87060ac" target="_blank" rel="external">【PPT动画】模糊渐变切换效果</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86c72ce" target="_blank" rel="external">【PPT动画】制作左、右浮入效果</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_8700201" target="_blank" rel="external">PPT制作画中画效果</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_870bdfa" target="_blank" rel="external">PPT绘制长阴影图标</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86c9304" target="_blank" rel="external">PPT三维立体图形绘制</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86dd125" target="_blank" rel="external">PPT巧用矩形等分区域（黄金分割线）</a></p>
<h3 id="【Lens-摄影-影视】"><a href="#【Lens-摄影-影视】" class="headerlink" title="【Lens/摄影/影视】"></a>【Lens/摄影/影视】</h3><p><a href="http://ex2tron.lofter.com/post/1d7338a1_eaa874a" target="_blank" rel="external">家乡 | 黑白 | PENTAX K-50 | 看见不一样</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86dc98c" target="_blank" rel="external">看见，时光（延时摄影短片）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_a483017" target="_blank" rel="external">我那时的“计量”（一），黑白质感</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_a526318" target="_blank" rel="external">我那时的“计量”（二），迎新色彩</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_a1952f4" target="_blank" rel="external">Lumia 1520 by iPhone6s</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_a93fda1" target="_blank" rel="external">历届奥斯卡最佳动画长片下载（1）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_a9207ea" target="_blank" rel="external">历届奥斯卡最佳动画长片下载（2）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_8bc8efc" target="_blank" rel="external">「精品」皮克斯15部动画长片下载</a></p>
<h3 id="【Other-科普-发现】"><a href="#【Other-科普-发现】" class="headerlink" title="【Other/科普/发现】"></a>【Other/科普/发现】</h3><p><a href="http://ex2tron.lofter.com/post/1d7338a1_86b724e" target="_blank" rel="external">PPI与DPI</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_87060f2" target="_blank" rel="external">USB接口类型（2.0概述）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_f078121" target="_blank" rel="external">Type-C和USB3.0（3.1）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_dda20a4" target="_blank" rel="external">发现Win10 Bug两枚（均得微软官方确认，一枚已解决）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_9f2bdda" target="_blank" rel="external">再战之后，这场旅途，只属于我</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_a1b9c49" target="_blank" rel="external">Win8以上系统安装PL2303驱动</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86f6444" target="_blank" rel="external">硬盘容量计算的差别</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_8700192" target="_blank" rel="external">硬盘整数分区原理及计算（附工具下载）</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_870619b" target="_blank" rel="external">详解Windows运行组件第一篇、原理篇</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_870bd17" target="_blank" rel="external">详解Windows运行组件第二篇、自定义运行指令</a></p>
<p><a href="http://ex2tron.lofter.com/post/1d7338a1_86dd0c5" target="_blank" rel="external">Windows 10技术预览版体验视频</a></p>
<blockquote>
<p><em>Never give up. Never stop fighting. Excelsior!</em></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2014/08/23在lofter上写我的&lt;a href=&quot;http://ex2tron.lofter.com/post/1d7338a1_86b724e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第一篇博客&lt;/a&gt;开始，已经过去了整整三年……
    
    </summary>
    
    
  </entry>
  
</feed>
