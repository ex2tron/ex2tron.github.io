<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Codec42</title>
  
  <subtitle>保持对技术的热爱！Excelsior!</subtitle>
  <link href="/atom.xaml" rel="self"/>
  
  <link href="http://www.codec.wang/"/>
  <updated>2020-04-07T08:14:08.183Z</updated>
  <id>http://www.codec.wang/</id>
  
  <author>
    <name>小强本强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我开源了一个视频滑动对比组件</title>
    <link href="http://www.codec.wang/video-compassion-slider/"/>
    <id>http://www.codec.wang/video-compassion-slider/</id>
    <published>2020-04-06T09:19:36.000Z</published>
    <updated>2020-04-07T08:14:08.183Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎大家体验并Star🙂：<a href="http://codec.wang/vsc" target="_blank" rel="noopener">http://codec.wang/vsc</a></p><p>先水点背景：由于在做视频&amp;图像质量评测相关的事，为了人眼可以区分前后算法的效果，自然要想个合理的展示方式。目前常见的三种方式是：<a id="more"></a></p><ul><li>序列对比：先看A，再看B，缺点是无法同时观看，记不住细节造成难以区分</li><li>同窗对比：AB左右同时展示，效果更优。但视觉上还是要左右跳转，对于动态的视频而言，人眼在左右跳转时很难同步到同一帧</li><li>滑动对比：AB叠加同时展示，通过滑块控制显示的部分，效果最佳</li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/vsc-compare-method.png_webp"><img class="image" src="http://blog.codec.wang/vsc-compare-method.png" alt=""></picture></p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>好了，正文开始：要在H5中实现序列和左右同窗较为简单。但滑动要怎么做呢？</p><p>简单理下思路：把AB叠在一起，B放下面，A放上面。滑动条滑动时，B不变，A隐藏掉部分。</p><p>那么怎么隐藏掉部分呢？🤔难道滑动的时候要实时裁切视频吗？这肯定是不行滴～～</p><p>这时候就得翻开我们的CSS大全了，我发现有这么一个属性：<strong>overflow</strong></p><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</a></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/vcs-understand-css-overflow.png_webp"><img class="image" src="http://blog.codec.wang/vcs-understand-css-overflow.png" alt=""></picture></p><p>由上图可见，<code>overflow</code>表示元素里面的内容太大以至于无法容纳时应该做什么。<code>visible</code>说：”老子就直接显示出来，难看就难看(直男⚠️)”，而优雅的’<code>hidden</code>说：”超出的部分给我消失(隐藏)”😗</p><p>这不就完美解决我们的问题了嘛：在上层video的外面包一层div，默认宽度与视频一致。然后我们只需要控制div的宽度，超出div的video部分会被自动隐藏掉。Perfect，开干！</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/vcs-understand-slider-compare.png_webp"><img class="image" src="http://blog.codec.wang/vcs-understand-slider-compare.png" alt=""></picture></p><blockquote><p>知道原理就会发现很简单。然而知道原理之前却很难，你如果认真攻破了这个难点，即使这个难点是“如此简单”，你的成长和解决问题的能力是别人比不了的，这也将会是你的核心竞争力。</p><p>The easy way is the hard way.</p></blockquote><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>首先我们把最基本的html写出来，用于验证上述原理，不用添加交互功能。视频可到<a href="#引用">引用</a>处下载。</p><ul><li>index.html</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"video-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"video-a"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">video</span> <span class="attr">autoplay</span> <span class="attr">muted</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">"videos/dolby_amaze_crf32_color.mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"video-b"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">video</span> <span class="attr">autoplay</span> <span class="attr">muted</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">"videos/dolby_amaze_crf32_gray.mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>index.css</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.video-container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">448px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.video-a</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.video-b</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">448px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/vcs-start-image-compare.png_webp"><img class="image" src="http://blog.codec.wang/vcs-start-image-compare.png" alt=""></picture></p><p>这样效果就出来了，so easy。由于要把两个video叠加在一起，所以父容器用<code>relative</code>定位，视频div用<code>absolute</code>定位。然后将上层的视频<code>video-a</code>设置宽度为一半，最关键的<code>overflow</code>为<code>hidden</code>。</p><h2 id="滑动交互"><a href="#滑动交互" class="headerlink" title="滑动交互"></a>滑动交互</h2><p>接下来就是滑动条的实现，以及滑动的交互了。这部分我暂时不写，感兴趣的可以直接看源码，大家⛽️！</p><blockquote><p>保持对技术的热爱！</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://codec.wang/vcs" target="_blank" rel="noopener">组件体验</a></li><li><a href="https://github.com/ex2tron/Image-Video-Comparsion-Slider" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://blog.codec.wang/dolby_amaze_crf32_color.mp4" target="_blank" rel="noopener">视频素材：杜比彩色</a></li><li><a href="http://blog.codec.wang/dolby_amaze_crf32_gray.mp4" target="_blank" rel="noopener">视频素材：杜比黑白</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow" target="_blank" rel="noopener">overflow</a></li><li><a href="https://www.w3schools.com/howto/howto_js_image_comparison.asp" target="_blank" rel="noopener">ImageComparsionSlider</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎大家体验并Star🙂：&lt;a href=&quot;http://codec.wang/vsc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codec.wang/vsc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先水点背景：由于在做视频&amp;amp;图像质量评测相关的事，为了人眼可以区分前后算法的效果，自然要想个合理的展示方式。目前常见的三种方式是：
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="图像对比" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%AF%B9%E6%AF%94/"/>
    
      <category term="视频对比" scheme="http://www.codec.wang/tags/%E8%A7%86%E9%A2%91%E5%AF%B9%E6%AF%94/"/>
    
  </entry>
  
  <entry>
    <title>小程序H5问卷开发2：模版&amp;脚本</title>
    <link href="http://www.codec.wang/wechat-h5-questionnaire2/"/>
    <id>http://www.codec.wang/wechat-h5-questionnaire2/</id>
    <published>2020-03-20T08:29:15.000Z</published>
    <updated>2020-04-07T03:46:59.406Z</updated>
    
    <content type="html"><![CDATA[<p>上一节介绍了问卷开发的技术方案，通过一个小demo走了一遍小程序调用H5进行交互的过程，但其实最大的工作量在H5网页的动态生成。基本流程如下：</p><ol><li>制定JSON问卷格式，存储问卷配置</li><li>用模版库如jinja2，编写HTML模版</li><li>Python读取JSON配置，填充模版，生成最终的H5网页<a id="more"></a></li></ol><ul><li><a href="http://codec.wang/h5-questionnaire" target="_blank" rel="noopener">问卷网页版Demo体验</a></li></ul><hr><h2 id="JSON配置"><a href="#JSON配置" class="headerlink" title="JSON配置"></a>JSON配置</h2><p>这一块没啥好说的，按照需求定义好字段就行，比如我这里：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"qn_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"page_title"</span>: <span class="string">"考核问卷"</span>,</span><br><span class="line">    <span class="attr">"tips"</span>: [</span><br><span class="line">        <span class="string">"请预留30分钟并自行完成；"</span>,</span><br><span class="line">        <span class="string">"中途退出结果不会缓存，请一次性作答完毕。"</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"questions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"question"</span>: <span class="string">"观察图片，哪个更清晰？"</span>,</span><br><span class="line">            <span class="attr">"pic_a"</span>: <span class="string">"http://blog.codec.wang/wechat-h5-questionnaire.jpg_webp"</span>,</span><br><span class="line">            <span class="attr">"pic_b"</span>: <span class="string">"http://blog.codec.wang/wechat-h5-questionnaire.jpg_webp"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"radio"</span>,</span><br><span class="line">            <span class="attr">"options"</span>: [<span class="string">"A更好"</span>, <span class="string">"B更好"</span>, <span class="string">"无法判断"</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别表示：问卷ID、问卷标题、提示、问题。其中type表示问题的类型，有单选框radio、多选框checkbox和输入框input等。</p><h2 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h2><p>要动态生成文本文件，最简单的方式就是字符串拼接。但显然这种方式对HTML这种标记语言来说太不现实了，于是就有了模版。</p><p>首先，编写一个HTML文件，这个文件内容除了常规的HTML标记外，主要是嵌入了一些变量和指令。我们称这个文件为模版。然后根据传入的数据执行替换操作，生成最终的HTML文件。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/templates-sample.png_webp"><img class="image" src="http://blog.codec.wang/templates-sample.png" alt=""></picture></p><p>不同的模版引擎的语法和性能有所不同，常用的有<a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ejs</a>、<a href="https://docs.djangoproject.com/zh-hans/3.0/topics/templates/" target="_blank" rel="noopener">Django模版</a>、<a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">jinja2</a>、<a href="https://www.makotemplates.org/" target="_blank" rel="noopener">mako</a>、<a href="https://genshi.edgewall.org/" target="_blank" rel="noopener">genshi</a>等，其中jinja2是一个仿Django模版的模版引擎，轻量简单，我用起来熟悉点。</p><p>编写之前，可以去<a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">官网</a>学习下基本的语法，常用的循环、条件判断等都比较简单。</p><p>当然模版引擎是很强大的，这里举几个我遇到的操作：</p><ul><li>格式化字符串</li></ul><p>模版引擎中可以将变量经过某种操作进行修改，该操作称之为<a href="http://docs.jinkan.org/docs/jinja2/templates.html#filters" target="_blank" rel="noopener">过滤器</a>。jinja2中有很多<a href="http://docs.jinkan.org/docs/jinja2/templates.html#builtin-filters" target="_blank" rel="noopener">内置过滤器</a>，最常用的就是格式化字符串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; "%s. %s"|format(a, b) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果a = 1，b = ‘hello’的话，最终生成出来就是：<code>1. hello</code></p><ul><li>获取循环索引</li></ul><p>前面定义的JSON中，问卷的提示是个数组，渲染时我想在每个提示前面加个标号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tips"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>评测提示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    &#123;% for tip in data.tips %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; "%s. %s"|format(loop.index, tip) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>loop.index</code>索引从1开始，<code>loop.index0</code>索引从0开始，参考：<a href="http://docs.jinkan.org/docs/jinja2/templates.html#id18" target="_blank" rel="noopener">循环For</a></p><ul><li>两层循环嵌套时的内外索引</li></ul><p>问卷的所有题目是个数组，题目的单选/多选选项也是个数组，所以需要两个循环生成。此时，单选框的id可以通过内外两个索引共同唯一确定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for item in data.questions %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">    &#123;% if item.type == 'radio' or item.type == 'checkbox' %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        &#123;% set outer_loop = loop %&#125;</span><br><span class="line">        &#123;% for option in item.options %&#125;</span><br><span class="line">        &#123;% set id = '%s-%s'|format(outer_loop.index0, loop.index0) %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"&#123;&#123;id&#125;&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;option&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"&#123;&#123;item.type&#125;&#125;"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123;loop.index0&#125;&#125;"</span> <span class="attr">id</span>=<span class="string">"&#123;&#123;id&#125;&#125;"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"weui-icon-checked"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>这里在进入第二个循环之前，使用了<code>set outer_loop = loop</code>，用outer_loop表示外部循环。</p><h2 id="Py脚本"><a href="#Py脚本" class="headerlink" title="Py脚本"></a>Py脚本</h2><p>有了模版引擎后，就需要一个数据提供和执行生成的脚本。最简单的就是Python了。</p><ul><li>安装模版引擎</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install jinja2</span><br></pre></td></tr></table></figure><ul><li>加载模版并生成</li></ul><p>jinja2使用Environment对象表示一个模版环境，比如模版<code>template.html</code>跟脚本放在统一目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Environment, FileSystemLoader</span><br><span class="line"></span><br><span class="line">env = Environment(loader=FileSystemLoader(<span class="string">'.'</span>))</span><br><span class="line">template = env.get_template(<span class="string">'template.html'</span>) <span class="comment"># 加载模版</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'index.html'</span>, <span class="string">'w+'</span>) <span class="keyword">as</span> fout:<span class="comment"># 生成最终文件</span></span><br><span class="line">  html_content = template.render(title=<span class="string">'生成模版'</span>)</span><br><span class="line">  fout.write(html_content)</span><br></pre></td></tr></table></figure><p>这里的数据只有<code>title</code>。当然真正的业务逻辑中，数据是从问卷配置文件<code>config.json</code>中读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'config.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> fin:</span><br><span class="line">  data = json.loads(fin.read())</span><br></pre></td></tr></table></figure><h2 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h2><p>因为是小程序上调用，所以构建一套适用于移动端的UI会好很多。自己写太费事也没必要，找一套UI组件套上即可。我这里选择了<a href="https://weui.io/" target="_blank" rel="noopener">WeUI</a>，它是微信官方推出的一套与微信原生视觉体验一致的基础样式库，完美符合需求。    </p><ul><li><a href="https://github.com/Tencent/weui/blob/master/README_cn.md" target="_blank" rel="noopener">WeUI Github</a></li></ul><p>在自己的H5页面链接<a href="https://github.com/Tencent/weui/wiki" target="_blank" rel="noopener">CSS样式文件</a>，组件使用参考官方Github的<a href="https://github.com/Tencent/weui/tree/master/src/example" target="_blank" rel="noopener">源码示例</a>即可。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/question-all-types-design.png_webp"><img class="image" src="http://blog.codec.wang/question-all-types-design.png" alt=""></picture></p><h2 id="前端交互"><a href="#前端交互" class="headerlink" title="前端交互"></a>前端交互</h2><p>网页虽然是个静态文本，但还是需要加入一些交互代码，如问卷问题的切换，结果的提交等。</p><p>这里就很简单粗暴了，我只使用了原生JavaScript：首先生成所有的题目，默认全部隐藏。点击开始评测后，显示第一道题，然后点击下一步的时候隐藏上一题同时显示下一题……</p><p>显示和隐藏可通过<code>display</code>或<code>visibility</code>来控制，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tips = <span class="built_in">document</span>.getElementById(<span class="string">'tips'</span>);</span><br><span class="line">tips.style.display = <span class="string">'none'</span>;<span class="comment">// 隐藏</span></span><br><span class="line">tips.style.display = <span class="string">'block'</span>;<span class="comment">// 显示</span></span><br></pre></td></tr></table></figure><p>对于最后的结果提交，有两种方案，</p><ol><li>采用上一节提到的<code>postMessage</code>将数据发送到小程序，小程序再调用接口提交</li><li>网页本身发送HTTP请求提交结果，提交成功则退出网页，否则弹出错误提示</li></ol><p>两种方式各有优劣。第一种好处是保证小程序所有的接口只有小程序本身能请求，H5只起到记录结果的作用。第二种好处是在网页内部请求，更通用，以后移植到其他Web系统上，也很便捷。</p><p>我这里用第二种，关键代码在于HTTP请求和导航退出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTTP POST Demo */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Submit</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">'http://api.test.com/'</span></span><br><span class="line">    <span class="keyword">const</span> httpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    httpRequest.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    httpRequest.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    httpRequest.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">  </span><br><span class="line">    httpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(httpRequest.responseText);</span><br><span class="line">            wx.miniProgram.navigateBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，评测结果data是在每次点击下一步的时候记录的：</p><ul><li>对于单选和多选，遍历当前的所有input，选择勾选的并记录</li><li>对于输入框，则直接记录当前input的内容即可</li></ul><p>这里就不写Demo了，具体可以看本项目的<a href="https://github.com/ex2tron/BlogCode/blob/master/WeChat-H5-Questionnaire/demo2/h5/js/qn.js" target="_blank" rel="noopener">qn.js</a>文件。</p><hr><p>好了，到这里，这个基础问卷系统就已经成型了。灵活可配置、也可以跨平台使用，bingo～</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://developers.weixin.qq.com/s/cNn5uZmd75f0" target="_blank" rel="noopener">在微信开发者工具中预览</a></li><li><a href="https://github.com/ex2tron/BlogCode/tree/master/WeChat-H5-Questionnaire/demo2" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017806952856928" target="_blank" rel="noopener">使用模板</a></li><li><a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">jinja2</a></li><li><a href="https://weui.io/" target="_blank" rel="noopener">WeUI</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一节介绍了问卷开发的技术方案，通过一个小demo走了一遍小程序调用H5进行交互的过程，但其实最大的工作量在H5网页的动态生成。基本流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;制定JSON问卷格式，存储问卷配置&lt;/li&gt;
&lt;li&gt;用模版库如jinja2，编写HTML模版&lt;/li&gt;
&lt;li&gt;Python读取JSON配置，填充模版，生成最终的H5网页
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="微信" scheme="http://www.codec.wang/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="小程序" scheme="http://www.codec.wang/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="问卷" scheme="http://www.codec.wang/tags/%E9%97%AE%E5%8D%B7/"/>
    
      <category term="H5" scheme="http://www.codec.wang/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>小程序H5问卷开发1：方案</title>
    <link href="http://www.codec.wang/wechat-h5-questionnaire/"/>
    <id>http://www.codec.wang/wechat-h5-questionnaire/</id>
    <published>2020-03-19T09:27:08.000Z</published>
    <updated>2020-04-07T03:46:13.524Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做个需求：用户在使用小程序前先要填写一个问卷，三个要求：</p><ol><li>问卷内容不会经常变动，但需要可配</li><li>问卷提交结果数据直接记录现有的数据库上</li><li>题型：单选/多选/输入框<a id="more"></a></li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/h5-questionnaire-sketch-design.png_webp"><img class="image" src="http://blog.codec.wang/h5-questionnaire-sketch-design.png" alt="最终UI/UX设计图"></picture></p><ul><li><a href="http://codec.wang/h5-questionnaire" target="_blank" rel="noopener">问卷网页版Demo体验</a></li><li><a href="https://developers.weixin.qq.com/s/cNn5uZmd75f0" target="_blank" rel="noopener">在微信开发者工具中预览</a></li></ul><hr><p>从需求来看，问题的关键在于后端问卷数据库存储和前端的页面设计。</p><p>显然，数据库搞成固定字段，实在太捉急了，总不能配一次问卷就换一张表吧。所以最简单的方案就是用JSON数据库，如：</p><table><thead><tr><th>问卷ID</th><th>UserID</th><th>Result</th></tr></thead><tbody><tr><td>001</td><td>005</td><td>{1: ‘wang’, 2: 0, 3: [1, 2] }</td></tr></tbody></table><p>接下来，就是问卷的界面设计。先来说下我调查过的一些方案。</p><h2 id="方案调查"><a href="#方案调查" class="headerlink" title="方案调查"></a>方案调查</h2><h3 id="第三方问卷系统"><a href="#第三方问卷系统" class="headerlink" title="第三方问卷系统"></a>第三方问卷系统</h3><p>这是我最先想到的：直接使用腾讯问卷之类的第三方系统。经过调查，常用问卷系统都可以使用：</p><ul><li><a href="https://wj.qq.com/article/single-348.html" target="_blank" rel="noopener">小程序跳转腾讯问卷指引</a></li><li><a href="https://www.wjx.cn/help/help.aspx?helpid=430" target="_blank" rel="noopener">问卷星：在自己小程序中打开问卷或考试（小程序跳转）</a></li><li><a href="https://www.wjx.cn/help/help.aspx?helpid=399" target="_blank" rel="noopener">问卷星：在自己小程序中打开问卷或考试（跳转H5页面）</a></li></ul><p>一般是自己的小程序跳转到相关问卷的小程序中，或者像问卷星一样，在自己的小程序中调用H5问卷网页。嗯，看上去不错……</p><p>等等，我们的需求是提交时直接记录在自己的数据库中。那么这些问卷系统有开放API吗？</p><p>目前而言，腾讯问卷官方没开放API，问卷星有：<a href="https://www.wjx.cn/help/help.aspx?helpid=407" target="_blank" rel="noopener">数据推送API</a></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/wenjuanxing-push-api.png_webp"><img class="image" src="http://blog.codec.wang/wenjuanxing-push-api.png" alt=""></picture></p><p>但，尊享版服务？查了下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/wenjuanxing-vip-service.png_webp"><img class="image" src="http://blog.codec.wang/wenjuanxing-vip-service.png" alt=""></picture></p><p>好吧，再见👋</p><h3 id="小程序Native实现"><a href="#小程序Native实现" class="headerlink" title="小程序Native实现"></a>小程序Native实现</h3><p>如果用小程序组件原生实现，需求基本是可以满足的，但开发量比较大且限制比较多。流程上：首先后端需要设计获取问卷的接口，小程序访问此接口，得到所有的题目和题型，然后动态生成UI。相当于开发一个简单的问卷系统了，且这种方式生成的界面也只能在小程序上用。</p><h2 id="自建H5方案"><a href="#自建H5方案" class="headerlink" title="自建H5方案"></a>自建H5方案</h2><p>自建H5的话没有问卷系统那么复杂，也能保证足够的灵活度。所以还是自己动手，丰衣足食啊，方案如下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/custom-h5-design.jpg_webp"><img class="image" src="http://blog.codec.wang/custom-h5-design.jpg" alt=""></picture></p><ul><li>虽然问卷内容要求可配，但因为不经常改动，所以不用做配置界面，改动时用脚本生成即可</li><li>H5网页是自己编写的，且部署在自己的服务器上，自然可以直接用自己的API</li><li>最后小程序直接调用H5进行交互即可</li></ul><p>这种方式后端只需要设计一个接口，即提交问卷结果的接口。因为是网页，所以也不仅限于小程序使用，任何浏览器上都可以使用，大大提升灵活性。那么开发量主要集中在：</p><ol><li>HTML模版和H5脚本编写</li><li>小程序与H5交互（鉴权、数据交互和页面跳转）</li></ol><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>为便于理解和走通方案流程，首先编写一个简单的index.html，在小程序上显示并交互：<a href="https://github.com/ex2tron/BlogCode/tree/master/WeChat-H5-Questionnaire/demo1" target="_blank" rel="noopener">本节源码</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我用的编辑器是VSCode，使用<a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener">Live Server</a>插件可以快速启动一个本地Web服务：<a href="http://127.0.0.1:5500/index.html" target="_blank" rel="noopener">http://127.0.0.1:5500/index.html</a></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/vscode-live-server.png_webp"><img class="image" src="http://blog.codec.wang/vscode-live-server.png" alt=""></picture></p><h3 id="小程序web-view"><a href="#小程序web-view" class="headerlink" title="小程序web-view"></a>小程序web-view</h3><p>小程序承载网页的容器是<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noopener">web-view</a>组件，组件本身很简单，src指定要跳转的网页地址即可。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/wechat-web-view-src.jpg_webp"><img class="image" src="http://blog.codec.wang/wechat-web-view-src.jpg" alt=""></picture></p><p>好，赶紧跳转个百度看看🙃……No，不行，自定义网页的域名需要在小程序<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">管理后台配置</a></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/wechat-business-domain.jpg_webp"><img class="image" src="http://blog.codec.wang/wechat-business-domain.jpg" alt=""></picture></p><p>不过为开发方便，本地开发时勾选<strong>不校验合法域名、web-view（业务域名）、TLS版本以及HTTPS证书</strong>。这样就不会校验，可以随便跳转。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/donot-check-https-domain.png_webp"><img class="image" src="http://blog.codec.wang/donot-check-https-domain.png" alt=""></picture></p><h3 id="小程序与H5交互"><a href="#小程序与H5交互" class="headerlink" title="小程序与H5交互"></a>小程序与H5交互</h3><ul><li>小程序传参给H5网页</li></ul><p>这个很简单，参数拼接在地址上就行。如将小程序的登陆信息和用户信息传递给H5，相当于给网页鉴权：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-view</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:5500/index.html?userid=xxx&amp;cookie=xxx/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-view</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>H5传参及导航到小程序</li></ul><p>首先在H5页面引入微信JSSDK才可以使用小程序相关接口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"https://res.wx.qq.com/open/js/jweixin-1.3.2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后网页可以通过<code>wx.miniProgram.postMessage()</code> 接口发送信息，最后web-view组件设置<code>bindmessage</code>事件接收数据。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/web-view-bindmessage-limit.png_webp"><img class="image" src="http://blog.codec.wang/web-view-bindmessage-limit.png" alt=""></picture></p><p>但这里有个坑：这个消息只有在特定时机才能收到，如小程序后退、组件销毁、分享。也就是说，如果在网页中只使用<code>wx.miniProgram.postMessage()</code>接口发送消息，但没有调用小程序后退/分享等接口的话，小程序是收不到消息的，举例：</p><p>我在网页中加了一个按钮，用来向小程序发送消息：</p><ul><li>H5代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"SendMsg()"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/qn.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://res.wx.qq.com/open/js/jweixin-1.3.2.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>H5 JS代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SendMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这句话触发小程序后退事件</span></span><br><span class="line">    <span class="comment">// 这句话不加，则后面两句发送的消息小程序接收不到</span></span><br><span class="line">    wx.miniProgram.navigateBack();</span><br><span class="line">  </span><br><span class="line">    wx.miniProgram.postMessage(&#123; <span class="attr">data</span>: <span class="string">'tencent'</span> &#125;);</span><br><span class="line">    wx.miniProgram.postMessage(&#123; <span class="attr">data</span>: &#123;<span class="attr">name</span>: <span class="string">'wang'</span>&#125; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，发送消息的数据结构必须在data中，否则小程序接收不到。</p><p>然后在小程序中接收消息，接收到的数据以数组形式记录：</p><ul><li>小程序wxml代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-view</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:5501/"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">bindmessage</span>=<span class="string">"handleMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">web-view</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>小程序js代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleMsg: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"message: "</span>, e.detail.data);</span><br><span class="line">  <span class="comment">// message:  ['tencent', &#123;name: "wang"&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境判断"><a href="#环境判断" class="headerlink" title="环境判断"></a>环境判断</h3><p>H5还可以使用更多的小程序接口，具体请参考：<a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noopener">web-view</a></p><p>比较常用的一个是判断当前是否是小程序环境的接口<code>getEnv()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wx.miniProgram.getEnv(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="built_in">console</span>.log(res) &#125;);</span><br><span class="line"><span class="comment">// &#123;miniprogram: true&#125;</span></span><br></pre></td></tr></table></figure><p>不过实际中，区分环境最好的实践方式是通过URL参数来区分。</p><h3 id="H5页面调试"><a href="#H5页面调试" class="headerlink" title="H5页面调试"></a>H5页面调试</h3><p>在微信开发者工具上，跳转H5网页后，可以在任意地方右键，打开网页调试面板：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/wechat-devtools-h5-debug.png_webp"><img class="image" src="http://blog.codec.wang/wechat-devtools-h5-debug.png" alt=""></picture></p><p>这样使用<code>debugger</code>或<code>console.log()</code>之类的调试方法就很方便。</p><p>在真机上，目前没有比较好的方法，比较粗暴的就是alert()大法了。</p><p>Okay，本文主要分享了我这两天做小程序H5问卷时一些方案，下一节开始Coding H5代码。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://developers.weixin.qq.com/s/zTlHfZmw7nfD" target="_blank" rel="noopener">在微信开发者工具中预览</a></li><li><a href="https://github.com/ex2tron/BlogCode/tree/master/WeChat-H5-Questionnaire/demo1" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noopener">小程序web-view组件</a></li><li><a href="https://imweb.io/topic/5c0aa26f611a25cc7bf1d7ea" target="_blank" rel="noopener">微信小程序 web-view 开发踩坑大全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做个需求：用户在使用小程序前先要填写一个问卷，三个要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;问卷内容不会经常变动，但需要可配&lt;/li&gt;
&lt;li&gt;问卷提交结果数据直接记录现有的数据库上&lt;/li&gt;
&lt;li&gt;题型：单选/多选/输入框
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="微信" scheme="http://www.codec.wang/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="小程序" scheme="http://www.codec.wang/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="问卷" scheme="http://www.codec.wang/tags/%E9%97%AE%E5%8D%B7/"/>
    
      <category term="H5" scheme="http://www.codec.wang/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>MightyPy：(l/r)strip函数的巨坑</title>
    <link href="http://www.codec.wang/mighty-py-strip/"/>
    <id>http://www.codec.wang/mighty-py-strip/</id>
    <published>2019-06-30T14:26:41.000Z</published>
    <updated>2020-04-07T03:43:57.760Z</updated>
    
    <content type="html"><![CDATA[<p>先来猜下Python中这句话的输出是啥<a id="more"></a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename = <span class="string">"journey_p4.mp4"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename.rstrip(<span class="string">".mp4"</span>)</span><br></pre></td></tr></table></figure><p>答案是：<code>journey_</code>，那<code>p4</code>去哪了呢？怎么样，有兴趣看下去了吗？↓</p><blockquote><p><em>I Am Iron Man.</em>  ——<a href="https://movie.douban.com/subject/1432146/" target="_blank" rel="noopener">《钢铁侠》</a><br><em>我就是钢铁侠。</em>——<a href="https://movie.douban.com/subject/1432146/" target="_blank" rel="noopener">《Iron Man》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><hr><h2 id="strip-函数"><a href="#strip-函数" class="headerlink" title="strip()函数"></a>strip()函数</h2><p>Python中常用<code>strip()</code>从字符串的开头和结尾移除指定的字符，不指定参数的话，默认移除的是空格、制表符、换行符等。同样<code>lstrip()</code>和<code>rstrip()</code>分别表示单独从开头、结尾移除指定的字符。</p><ul><li>函数原型：<a href="https://docs.python.org/3/library/stdtypes.html?highlight=strip#str.strip" target="_blank" rel="noopener">str.strip([chars])</a>、<a href="https://docs.python.org/3/library/stdtypes.html?highlight=lstrip#str.lstrip" target="_blank" rel="noopener">str.lstrip([chars])</a>、<a href="https://docs.python.org/3/library/stdtypes.html?highlight=rstrip#str.rstrip" target="_blank" rel="noopener">str.rstrip([chars])</a></li></ul><p>但很多人并不真正了解函数用法，胡乱使用就会导致开头的那种问题，包括之前的我( ╯□╰ )。</p><h2 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h2><p>其实<a href="https://docs.python.org/3/library/stdtypes.html?highlight=strip#str.strip" target="_blank" rel="noopener">官方文档</a>上写的很清楚并举了几个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The chars argument <span class="keyword">is</span> <span class="keyword">not</span> a prefix <span class="keyword">or</span> suffix; rather, all combinations of its values are stripped.</span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><blockquote><p>strip函数的参数并不是指前缀或后缀，而是所有其组合值都会被删除掉！</p></blockquote><p>啥意思呢？以开头问题为例，虽然我们指定了从尾部删除<code>.mp4</code>这个字符串，但它并不会老老实实只删除<code>.mp4</code>，而是包含<code>.mp4</code>所以组合值的字符串都会被删除，比如末尾包含了<code>m/pm/mp/4p/p4/pm4</code>等等都会被删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename = <span class="string">"journey_p4mmp.mp4"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename.rstrip(<span class="string">".mp4"</span>)</span><br><span class="line">journey_</span><br></pre></td></tr></table></figure><p>再来看些官方的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'www.example.com'</span>.strip(<span class="string">'cmowz.'</span>)</span><br><span class="line">example</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment_string = <span class="string">'#....... Section 3.2.1 Issue #32 .......'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>comment_string.strip(<span class="string">'.#! '</span>)</span><br><span class="line">Section <span class="number">3.2</span><span class="number">.1</span> Issue <span class="comment">#32</span></span><br></pre></td></tr></table></figure><p><code>strip()</code>函数会从开头和结尾开始检索，直到找到不满足要求的第一个字符为止。所以上面的例子从结尾检索时，遇到2不满足要求就结束了。</p><p>综上，<code>strip()/lstrip()/rstrip()</code>要慎用噢。</p><h3 id="去扩展名"><a href="#去扩展名" class="headerlink" title="去扩展名"></a>去扩展名</h3><p>p.s.开头那种去扩展名其实有很多实现方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename = <span class="string">"journey_p4.mp4"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename.split(<span class="string">"."</span>)[<span class="number">0</span>]</span><br><span class="line">journey_p4</span><br></pre></td></tr></table></figure><p>或者用os模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(filename)</span><br><span class="line">(<span class="string">'journey_p4'</span>, <span class="string">'.mp4'</span>)</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://docs.python.org/3/library/stdtypes.html?highlight=strip#str.strip" target="_blank" rel="noopener">str.strip([chars])</a></li><li><a href="https://docs.python.org/3/library/stdtypes.html?highlight=lstrip#str.lstrip" target="_blank" rel="noopener">str.lstrip([chars])</a></li><li><a href="https://docs.python.org/3/library/stdtypes.html?highlight=rstrip#str.rstrip" target="_blank" rel="noopener">str.rstrip([chars])</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来猜下Python中这句话的输出是啥
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="strip" scheme="http://www.codec.wang/tags/strip/"/>
    
      <category term="lstrip" scheme="http://www.codec.wang/tags/lstrip/"/>
    
      <category term="rstrip" scheme="http://www.codec.wang/tags/rstrip/"/>
    
  </entry>
  
  <entry>
    <title>MightyPy：处理命令行参数和选项的几种方式</title>
    <link href="http://www.codec.wang/mighty-py-command-line-arguments/"/>
    <id>http://www.codec.wang/mighty-py-command-line-arguments/</id>
    <published>2019-05-03T02:30:18.000Z</published>
    <updated>2020-04-07T03:44:47.855Z</updated>
    
    <content type="html"><![CDATA[<p>设计Python模块功能时，命令行参数是一个非常灵活且便捷的方法：<strong>从外部获取配置参量，而不是直接修改代码</strong>。Python内置几种命令行参数和选项的处理方式，当然也有更加强大的第三方的模块，如：<a href="https://click.palletsprojects.com/en/7.x/" target="_blank" rel="noopener">click</a>。<a id="more"></a></p><p>一般来说内置就够用了，所以本节主要看下内置的三种方式。</p><blockquote><p><em>Louis, I think this is the beginning of a beautiful friendship.</em>  ——<a href="https://movie.douban.com/subject/1296753/" target="_blank" rel="noopener">《Casablanca》</a><br><em>路易，我想这是美好友谊的开始。</em>——<a href="https://movie.douban.com/subject/1296753/" target="_blank" rel="noopener">《卡萨布兰卡》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><hr><h2 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h2><p>这是最常用的一种方式，命令行传入的参数全部存储在sys.argv(argument values)这个列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(type(sys.argv)) <span class="comment"># list</span></span><br></pre></td></tr></table></figure><p>需要注意的是，Python后面跟的第一个文本是第一个参数，所以一般<strong>脚本名是第一个参数</strong>。如下面脚本名为<code>using_sys_argv.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"参数个数：\t%s"</span>%len(sys.argv))</span><br><span class="line">print(<span class="string">'脚本名：\t%s'</span>%sys.argv[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'参数列表：'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(sys.argv)):</span><br><span class="line">    print(<span class="string">'\t\t参数%s: %s'</span>%(i,sys.argv[i]))</span><br></pre></td></tr></table></figure><ul><li>运行<code>python using_sys_argv.py</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数个数：      1</span><br><span class="line">脚本名：        using_sys_argv.py</span><br><span class="line">参数列表：</span><br></pre></td></tr></table></figure><ul><li>运行<code>python using_sys_argv.py tencent wang</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数个数：      3</span><br><span class="line">脚本名：        using_sys_argv.py</span><br><span class="line">参数列表：</span><br><span class="line">                参数1: tencent</span><br><span class="line">                参数2: wang</span><br></pre></td></tr></table></figure><p><strong>这种方式虽然很简单，但不能很好地识别命令行选项</strong>，需要自己写额外代码，如：</p><ul><li>运行<code>python using_sys_argv.py -c tencent --name wang</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数个数：      5</span><br><span class="line">脚本名：        using_sys_argv.py</span><br><span class="line">参数列表：</span><br><span class="line">                参数1: -c</span><br><span class="line">                参数2: tencent</span><br><span class="line">                参数3: --name</span><br><span class="line">                参数4: wang</span><br></pre></td></tr></table></figure><p>如上，sys.argv统一识别成了参数量。</p><h2 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h2><p>argparse是Python内置的模块，它会从sys.argv中正确<strong>解析出命令行选项和参数，并自动生成帮助和使用信息</strong>。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>argparse使用基本是三个步骤：</p><ul><li>创建<code>ArgumentParser()</code>解析器对象</li><li>使用<code>add_argument()</code>添加参数</li><li>使用<code>parse_args()</code>解析参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.定义解析器</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"><span class="comment"># 2.添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">'integer'</span>,type=int,help=<span class="string">'base number x'</span>)</span><br><span class="line"><span class="comment"># 3.解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.integer)</span><br></pre></td></tr></table></figure><p>上面就是argparse的一个简单示例，运行下看看效果：</p><ul><li>直接运行<code>python using_argparse.py</code>，会报错：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: using_argparse.py [-h] <span class="built_in">integer</span></span><br><span class="line">using_argparse.py: error: the following arguments are required: <span class="built_in">integer</span></span><br></pre></td></tr></table></figure><p>提示通过<code>-h</code>获取帮助，并且<code>integer</code>这个参数是必须的。</p><ul><li>运行<code>python using_argparse.py -h</code>，显示帮助文档：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">usage: using_argparse.py [-h] <span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  <span class="built_in">integer</span>     base number x</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ul><li>运行<code>python using_argparse.py 100</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>平常使用最多的应该是添加短选项<code>-</code>或长选项<code>--</code>的可选参数，比如要计算一个数的n次方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.定义解析器</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"><span class="comment"># 2.添加位置参数</span></span><br><span class="line">parser.add_argument(<span class="string">'integer'</span>,type=int,help=<span class="string">'base number x'</span>)</span><br><span class="line"><span class="comment"># 添加可选参数</span></span><br><span class="line">parser.add_argument(<span class="string">'--powern'</span>,type=int,help=<span class="string">'n power of a number'</span>)</span><br><span class="line"><span class="comment"># 3.解析参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.powern: <span class="comment"># 判断可选参数</span></span><br><span class="line">    print(args.integer**args.powern)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(args.integer)</span><br></pre></td></tr></table></figure><p>此时不加<code>--powern</code>的运行结果跟之前一样，添加后，会计算x^n：</p><ul><li>运行<code>python using_argparse.py 100 --powern 2</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000</span><br></pre></td></tr></table></figure><h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>虽说主要通过三个方法实现，但方法的参数很多，我们挑几个常用的说下，更多请参考<a href="#接口文档">接口文档</a>。</p><ul><li><strong>ArgumentParser()</strong></li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/depth_python_argparse_argumentparser_method.jpg_webp"><img class="image" src="http://blog.codec.wang/depth_python_argparse_argumentparser_method.jpg" alt=""></picture></p><p>其中最常用的是<code>description</code>项，在脚本帮助文档中起说明作用，如前面代码更改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Basic Operations of an Integer.'</span>)</span><br></pre></td></tr></table></figure><p>此时运行<code>python using_argparse.py -h</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usage: using_argparse.py [-h] [--powern POWERN] <span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line">Basic Operations of an Integer.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">……</span><br></pre></td></tr></table></figure><ul><li><strong>add_argument()</strong></li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/depth_python_argparse_add_argument_method.jpg_webp"><img class="image" src="http://blog.codec.wang/depth_python_argparse_add_argument_method.jpg" alt=""></picture></p><p>其中参量类型<code>type</code>和帮助信息<code>help</code>不用多讲，其他几个常用的说明一下：</p><ol><li><code>name of flags</code>，想让脚本同一个可选参数既支持短选项<code>-</code>又支持长选项<code>--</code>，可以：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>,<span class="string">'-f'</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.foo) <span class="comment"># 注意不是args.f噢！</span></span><br></pre></td></tr></table></figure><p>这样的话，运行时<code>python script.py -f param</code>或<code>python script.py --foo param</code>都可以。</p><p>2.<code>nargs</code>，要读取的命令行参数个数</p><ul><li><code>nargs=n</code>，表示要读取n个参数，如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>,<span class="string">'-f'</span>,nargs=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运行时需要在<code>-f</code>后加两个参数：<code>python script.py -f p1 p2</code></p><ul><li><code>nargs=&#39;*&#39;/&#39;+&#39;</code>，将所有参数合在一个列表中（<code>*</code>号和<code>+</code>号的区别：<code>+</code>号需至少1个参数）：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>,<span class="string">'-f'</span>,nargs=<span class="string">'+'</span>)</span><br></pre></td></tr></table></figure><p>运行<code>python script.py -f p1 p2 p3</code>结果为：<code>foo=[&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;]</code></p><ul><li><code>nargs=&#39;?&#39;</code>，参数没提供时，使用默认值（可选参数是const，位置参数是default）：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>,<span class="string">'-f'</span>,nargs=<span class="string">'?'</span>,const=<span class="string">'param'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integer'</span>,nargs=<span class="string">'?'</span>,default=<span class="string">'0'</span>)</span><br></pre></td></tr></table></figure><p>运行<code>python script.py -f</code>，结果为：<code>foo=&#39;param&#39;,integer=&#39;0&#39;</code></p><p>3.<code>required</code>，默认情况下，argparse会把<code>-</code>和<code>--</code>的参数作为可选的，如果需要指定成必须的话，可以将required设置为True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>,<span class="string">'-f'</span>,required=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>运行<code>python script.py</code>会提示：<code>error: the following arguments are required: --foo/-f</code></p><p>4.<code>choices</code>，限定参数值的范围，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>,<span class="string">'-f'</span>,choices=[<span class="string">'p1'</span>,<span class="string">'p2'</span>,<span class="string">'p3'</span>])</span><br></pre></td></tr></table></figure><p>运行<code>python scipt.py -f param</code>会提示：<code>error: argument --foo/-f: invalid choice: &#39;param&#39; (choose from &#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;)</code></p><ul><li><strong>parse_args()</strong></li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/depth_python_argparse_parse_args_method.jpg_webp"><img class="image" src="http://blog.codec.wang/depth_python_argparse_parse_args_method.jpg" alt=""></picture></p><p>这个方法没啥好讲的，主要是第一个参数args，默认是从sys.argv取值，调试时也可以把命令行参数加上去，这样就不用在命令行中设置了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--foo'</span>,<span class="string">'-f'</span>,choices=[<span class="string">'p1'</span>,<span class="string">'p2'</span>,<span class="string">'p3'</span>])</span><br><span class="line">parser.add_argument(<span class="string">'integer'</span>,nargs=<span class="string">'?'</span>,default=<span class="string">'0'</span>)</span><br><span class="line"><span class="comment"># 直接在代码中传入命令行参数</span></span><br><span class="line">args = parser.parse_args([<span class="string">'100'</span>,<span class="string">'-f'</span>,<span class="string">'p1'</span>])</span><br></pre></td></tr></table></figure><p>此时，在编辑器中直接运行或在命令行中不加参数运行：<code>python scipt.py</code>都能得到正确结果：<code>integer=&#39;100&#39;,foo=&#39;p1&#39;</code></p><h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><p>Python还有一个getopt模块，它的设计与C语言中的getopt类似。Python官方建议是你如果不熟悉C中的getopt或者想写更少的代码的话，更推荐用argparse，所以不再详述，感兴趣可参考<a href="#接口文档">接口文档</a>：</p><blockquote><p>Note: The <a href="https://docs.python.org/3/library/getopt.html#module-getopt" target="_blank" rel="noopener"><code>getopt</code></a> module is a parser for command line options whose API is designed to be familiar to users of the C <code>getopt()</code> function. Users who are unfamiliar with the C <code>getopt()</code> function or who would like to write less code and get better help and error messages should consider using the <a href="https://docs.python.org/3/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> module instead.</p></blockquote><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.python.org/3/library/sys.html" target="_blank" rel="noopener">Python sys</a></li><li><a href="https://docs.python.org/zh-cn/3/library/argparse.html" target="_blank" rel="noopener">Python argparse</a></li><li><a href="https://docs.python.org/3/library/getopt.html" target="_blank" rel="noopener">Python getopt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计Python模块功能时，命令行参数是一个非常灵活且便捷的方法：&lt;strong&gt;从外部获取配置参量，而不是直接修改代码&lt;/strong&gt;。Python内置几种命令行参数和选项的处理方式，当然也有更加强大的第三方的模块，如：&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;click&lt;/a&gt;。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="argv" scheme="http://www.codec.wang/tags/argv/"/>
    
      <category term="命令行参数" scheme="http://www.codec.wang/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【树莓派】变身全能无线路由器(2/2B)</title>
    <link href="http://www.codec.wang/raspberrypi-as-router/"/>
    <id>http://www.codec.wang/raspberrypi-as-router/</id>
    <published>2019-04-03T03:16:34.000Z</published>
    <updated>2020-04-07T04:48:38.999Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派能做的事情实在是太多了，今天我们就来把它改造成一台全能的无线路由器。要知道树莓派的Soc性能可比廉价路由器高出不少。<a id="more"></a></p><blockquote><p><em>人在顺境时候的友谊，可能不是那么坚固的。</em>  ——<a href="https://movie.douban.com/subject/30163509/" target="_blank" rel="noopener">《飞驰人生》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><hr><h2 id="硬件-软件版本说明"><a href="#硬件-软件版本说明" class="headerlink" title="硬件/软件版本说明"></a>硬件/软件版本说明</h2><p>我一开始是用3B+的，但官方的固件烧写后不断重启，有问题，网上很多人也遇到。虽然通过烧写开发版固件解决了，但本文还是先以官方固件为主，后续再写篇3B+的。</p><ul><li>树莓派 2B</li><li>OS：OpenWrt 18.06.2 </li><li>TF卡：闪迪SanDisk 16GB C10</li><li>USB无线网卡：EDUP EP-N8508GS</li></ul><h2 id="WAN、LAN、WLAN区别"><a href="#WAN、LAN、WLAN区别" class="headerlink" title="WAN、LAN、WLAN区别"></a>WAN、LAN、WLAN区别</h2><p>在开干之前，有几个小概念还是要了解一下：</p><ul><li><a href="https://baike.baidu.com/item/LAN" target="_blank" rel="noopener">LAN</a>：<code>Local Area Network</code>局域网</li><li><a href="https://baike.baidu.com/item/wan" target="_blank" rel="noopener">WAN</a>：<code>Wide Area Network</code>广域网</li><li><a href="https://baike.baidu.com/item/wlan" target="_blank" rel="noopener">WLAN</a>：<code>Wireless Local Area Networks</code>无线局域网</li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_understand_wan_lan_wlan.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_understand_wan_lan_wlan.jpg" alt=""></picture></p><p>简单来说，LAN就是用来组建有线局域网，而WLAN是用来组建无线局域网的。要使局域网内的设备访问外网，就需要WAN口接入网络运营商或者上层网络。感兴趣的可参考<a href="#引用">引用</a>。</p><h2 id="安装配置OpenWrt"><a href="#安装配置OpenWrt" class="headerlink" title="安装配置OpenWrt"></a>安装配置OpenWrt</h2><p>OpenWrt官网提供了树莓派系列的相关资料和最新固件下载：</p><ul><li><a href="https://openwrt.org/toh/raspberry_pi_foundation/raspberry_pi" target="_blank" rel="noopener">https://openwrt.org/toh/raspberry_pi_foundation/raspberry_pi</a></li></ul><table><thead><tr><th>型号</th><th>SoC</th><th>CPU MHz</th><th>WLAN Hardware</th></tr></thead><tbody><tr><td>Raspberry Pi 2B</td><td>Broadcom BCM2836</td><td>900</td><td>无</td></tr></tbody></table><p>首先明确下我们要做的事情：将树莓派的有线网口作为新路由器的WAN口，由于2/2B不带无线网卡，所以将USB无线网卡作为WLAN产生WIFI。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_purpose.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_purpose.jpg" alt=""></picture></p><h3 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h3><p>安装固件和升级固件任意下载一个即可：</p><ul><li>安装固件：<a href="http://downloads.openwrt.org/releases/18.06.2/targets/brcm2708/bcm2709/openwrt-18.06.2-brcm2708-bcm2709-rpi-2-ext4-factory.img.gz" target="_blank" rel="noopener">openwrt-18.06.2-brcm2708-bcm2709-rpi-2-ext4-factory.img.gz</a></li><li>升级固件：<a href="http://downloads.openwrt.org/releases/18.06.2/targets/brcm2708/bcm2709/openwrt-18.06.2-brcm2708-bcm2709-rpi-2-ext4-sysupgrade.img.gz" target="_blank" rel="noopener">openwrt-18.06.2-brcm2708-bcm2709-rpi-2-ext4-sysupgrade.img.gz</a></li></ul><h3 id="固件烧写"><a href="#固件烧写" class="headerlink" title="固件烧写"></a>固件烧写</h3><p>Windows系统的话，可以使用<a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">Win32DiskImager</a>或<a href="https://www.balena.io/etcher/" target="_blank" rel="noopener">Etcher</a>，操作都很简单，选择固件和TF卡，点击烧写就可以了。后者的颜值更高一些，我喜欢(●ˇ∀ˇ●)</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_etcher.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_etcher.jpg" alt=""></picture></p><h3 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h3><p>现在跟玩传统树莓派一样，接上电源、显示屏和键盘后，正常开机，都是终端界面，不需要鼠标。</p><p>启动后，根据提示，按下回车，就可以进入终端界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Please press Enter to activate this console.</span><br><span class="line"></span><br><span class="line"> _______                     ________        __      </span><br><span class="line"> |       |.-----.-----.-----.|  |  |  |.----.|  |_    </span><br><span class="line"> |   -   ||  _  |  -__|     ||  |  |  ||   _||   _|   </span><br><span class="line"> |_______||   __|_____|__|__||________||__|  |____|   </span><br><span class="line">          |__| W I R E L E S S   F R E E D O M        </span><br><span class="line"> -----------------------------------------------------</span><br><span class="line"> OpenWrt 18.06.2, r7676-cddd7b4c77                   </span><br><span class="line"> -----------------------------------------------------</span><br><span class="line">=== WARNING! =====================================    </span><br><span class="line">There is no root password defined on this device!     </span><br><span class="line">Use the "passwd" command to set up a new password     </span><br><span class="line">in order to prevent unauthorized SSH logins.          </span><br><span class="line">--------------------------------------------------    </span><br><span class="line">root@OpenWrt:~#</span><br></pre></td></tr></table></figure><h3 id="进入路由器后台"><a href="#进入路由器后台" class="headerlink" title="进入路由器后台"></a>进入路由器后台</h3><p>进入后台有多种方式，我归纳为两种：网线直连的方式和终端操作的方式。推荐终端操作，虽然看上去复杂了点，但其实更快捷。</p><h4 id="方法1：网线直连"><a href="#方法1：网线直连" class="headerlink" title="方法1：网线直连"></a>方法1：网线直连</h4><p>将网线的一端插入树莓派，另一端插入电脑，断开电脑的其他有线或无线连接。待网络成功识别后，浏览器中访问<code>192.168.1.1</code>便可进入后台。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_direct_connect.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_direct_connect.jpg" alt=""></picture></p><p>默认没有密码直接登录，进入之后，需要让树莓派连接到已有的网络中：点击 ‘Network’ - ‘Interface’ - ‘Add new interface’，这里我让树莓派接入家里路由器LAN口分出的有线网络，所以协议选择 ‘DHCP client’，点击 ‘Submit’提交。</p><p>如果你打算将树莓派接入网络运营商设备，可能需要输入宽带账号密码，协议选择’PPPoE’。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_add_wan_interface.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_add_wan_interface.jpg" alt=""></picture></p><p>点击’Submit’提交之后再点击’Save &amp; Apply’，会弹出30s的配置应用时间。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_configure_waiting_time.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_configure_waiting_time.jpg" alt=""></picture></p><p>此时拔掉树莓派与电脑的直连网线，插入有线网。编辑<code>/etc/config/network</code>网络配置文件，将lan配置的ifname一行注释掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config interface 'lan'</span><br><span class="line">        option type 'bridge'</span><br><span class="line"><span class="meta">#</span><span class="bash">       option ifname <span class="string">'eth0'</span></span></span><br><span class="line">        option proto 'static'</span><br><span class="line">        option ipaddr '192.168.1.1'</span><br><span class="line">        option netmask '255.255.255.0'</span><br><span class="line">        option ip6assign '60'</span><br></pre></td></tr></table></figure><p>用<code>ifconfig</code>查看树莓派的IP地址，如<code>192.168.1.112</code>，在局域网内的其他设备上访问此IP就可以进入树莓派的路由器后台。</p><h4 id="方法2：终端操作"><a href="#方法2：终端操作" class="headerlink" title="方法2：终端操作"></a>方法2：终端操作</h4><p>其实方法1本身就是更改<code>/etc/config/network</code>文件，所以可以直接在终端编辑，添加一个广域网wan口配置，并将lan的ifname一行注释掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">config interface 'lan'</span><br><span class="line">        option type 'bridge'</span><br><span class="line"><span class="meta">#</span><span class="bash">       option ifname <span class="string">'eth0'</span></span></span><br><span class="line">        option proto 'static'</span><br><span class="line">        option ipaddr '192.168.1.1'</span><br><span class="line">        option netmask '255.255.255.0'</span><br><span class="line">        option ip6assign '60'</span><br><span class="line"></span><br><span class="line">config interface 'wan'</span><br><span class="line">        option proto 'dhcp'</span><br><span class="line">        option ifname 'eth0'</span><br></pre></td></tr></table></figure><p>如果树莓派接的是家里路由器LAN口出来的网线，一般配置成DHCP协议就可以了。如果是直接从网络运营商设备出来的网线，则可能需要输入宽带账号密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config interface 'wan'</span><br><span class="line">        option proto 'pppoe'</span><br><span class="line">        option ifname 'eth0'</span><br><span class="line">        option username 'xxxxxx'</span><br><span class="line">        option password 'xxxxxx'</span><br></pre></td></tr></table></figure><p>添加完之后，使用<code>/etc/init.d/network restart</code>重启网络服务，使用ifconfig查看ip地址：如<code>192.168.1.112</code>，然后在局域网内的其他设备上输入此IP便可以访问OpenWrt 的后台了。</p><p>如果访问有问题，可以关闭防火墙试下：<code>/etc/init.d/firewall stop</code></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_terminal_configure.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_terminal_configure.jpg" alt=""></picture></p><p>不论使用哪种方法，进入之后，默认都是没有密码的。为安全起见，这里先设置个密码，点击 ‘Go to password configuration…’，输入密码后，直接点击 ‘Save &amp; Apply’，其他不用管。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_change_password.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_change_password.jpg" alt=""></picture></p><h3 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h3><p>树莓派成功联网后，需要下载一些插件。一方面官方的源亲测是不包含USB网卡驱动和中文插件的，不知道什么原因，另一方面国内的源速度会快很多，所以这里统一换成中科大的源。</p><ul><li>中国科学技术大学开源镜像站 LEDE：<a href="http://mirrors.ustc.edu.cn/help/lede.html" target="_blank" rel="noopener">使用帮助</a></li></ul><p>可以在终端操作，也可以在Web后台操作：</p><h4 id="Web后台操作"><a href="#Web后台操作" class="headerlink" title="Web后台操作"></a>Web后台操作</h4><p>进入路由器后台，依次点击 ‘System’ - ‘Software’ - ‘Configuration’，在 ‘Distribution feeds’下面我们更换成国内的源，注意版本噢（最好先将原有的备份下）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/gz openwrt_core http://mirrors.ustc.edu.cn/lede/releases/18.06.2/targets/brcm2708/bcm2709/packages</span><br><span class="line">src/gz openwrt_base http://mirrors.ustc.edu.cn/lede/releases/18.06.2/packages/arm_cortex-a7_neon-vfpv4/base</span><br><span class="line">src/gz openwrt_luci http://mirrors.ustc.edu.cn/lede/releases/18.06.2/packages/arm_cortex-a7_neon-vfpv4/luci</span><br><span class="line">src/gz openwrt_packages http://mirrors.ustc.edu.cn/lede/releases/18.06.2/packages/arm_cortex-a7_neon-vfpv4/packages</span><br><span class="line">src/gz openwrt_routing http://mirrors.ustc.edu.cn/lede/releases/18.06.2/packages/arm_cortex-a7_neon-vfpv4/routing</span><br><span class="line">src/gz openwrt_telephony http://mirrors.ustc.edu.cn/lede/releases/18.06.2/packages/arm_cortex-a7_neon-vfpv4/telephony</span><br></pre></td></tr></table></figure><p>然后切换到 ‘Actions’标签下，点击 ‘Update lists’便可以获取所有可用的ipk包：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_achieve_all_aviable_pkgs.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_achieve_all_aviable_pkgs.jpg" alt=""></picture></p><h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>首先将原有的源配置文件备份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/opkg/distfeeds.conf /etc/opkg/distfeeds.conf.bak</span><br></pre></td></tr></table></figure><p>然后用sed命令替换掉源地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i 's|downloads.openwrt.org|mirrors.ustc.edu.cn/lede|g' /etc/opkg/distfeeds.conf</span><br></pre></td></tr></table></figure><p>最后记得执行更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br></pre></td></tr></table></figure><h3 id="安装必要的软件包"><a href="#安装必要的软件包" class="headerlink" title="安装必要的软件包"></a>安装必要的软件包</h3><p>在路由器后台的 ‘System’ - ‘Software’下面的 ‘Filter’中搜索要安装的软件包，或者在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opkg install pkg_name</span><br></pre></td></tr></table></figure><p>都可以安装，主要装3个包：</p><ul><li>路由器后台中文插件：<code>luci-i18n-base-zh-cn</code></li><li>USB无线网卡驱动：<code>kmod-rtl8192cu</code></li><li>无线配置工具：<code>wireless-tools</code></li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_chinese_language_pkg.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_chinese_language_pkg.jpg" alt=""></picture></p><h3 id="配置无线"><a href="#配置无线" class="headerlink" title="配置无线"></a>配置无线</h3><p>安装中文包后，后台自动变成了中文。此时菜单栏’网络’中会多出个’无线’，点击进入：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_wireless_interface.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_wireless_interface.jpg" alt=""></picture></p><p>默认情况下，无线并没有启用，只需点击启用就可以了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_wireless_enable.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_wireless_enable.jpg" alt=""></picture></p><p>不过还有点小问题，首先这个WiFi没密码，其次也没网。点击’编辑’，将网络来源选择为WAN：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_network_source.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_network_source.jpg" alt=""></picture></p><p>其次在’无线安全’这里给WiFi设置个密码，最后保存就可以了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_wireless_password.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_wireless_password.jpg" alt=""></picture></p><p>现在手机或电脑可以连接上试试辣：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_as_router_phone_connect.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_as_router_phone_connect.jpg" alt=""></picture></p><h3 id="万能路由器"><a href="#万能路由器" class="headerlink" title="万能路由器"></a>万能路由器</h3><p>之所以称之为’万能路由器’，是因为OpenWrt不仅完全开源，可玩性很高，而且第三方插件非常丰富，比如可以科学上网的shadowsocks，安装配置之后，全天24h出国旅游不成问题呀（有空写篇( $ _ $ )）。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://jingyan.baidu.com/article/3c343ff7e862850d3679637b.html" target="_blank" rel="noopener">LAN、WAN、WLAN的区别</a></li><li><a href="https://openwrt.org/toh/raspberry_pi_foundation/raspberry_pi" target="_blank" rel="noopener">OpenWrt Raspberry Pi</a></li><li><a href="http://blog.lxx1.com/3294" target="_blank" rel="noopener">树莓派安装 OpenWrt 打造超级路由器</a></li><li><a href="https://www.vediotalk.com/?p=956" target="_blank" rel="noopener">VLOG丨树莓派(raspberrypi Pi1-Pi3)安装OPENWRT LEDE秒变xxx</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树莓派能做的事情实在是太多了，今天我们就来把它改造成一台全能的无线路由器。要知道树莓派的Soc性能可比廉价路由器高出不少。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="树莓派" scheme="http://www.codec.wang/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="OpenWrt" scheme="http://www.codec.wang/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>【树莓派】用PLEX打造家庭影音中心！</title>
    <link href="http://www.codec.wang/raspberrypi-how-to-install-plex-server/"/>
    <id>http://www.codec.wang/raspberrypi-how-to-install-plex-server/</id>
    <published>2019-03-27T14:43:35.000Z</published>
    <updated>2020-04-07T03:53:27.982Z</updated>
    
    <content type="html"><![CDATA[<p>电脑下载了部电影，晚上想在手机上看，老婆也想看（啥？！），拷贝？想在手机上看以前的电影或者硬盘里存的视频/照片，拷贝？使用云盘存储呢？速度、容量、播放码率、重复占用本地容量都是问题。如果有一块存放资源的硬盘，家人都可以高速访问它，何乐而不为呢？我说的不是NAS噢~<a id="more"></a></p><blockquote><p><em>May the force be with you.</em>  ——<a href="https://movie.douban.com/subject/1293838/" target="_blank" rel="noopener">《Star Wars》</a><br><em>愿原力与你同在！</em>——<a href="https://movie.douban.com/subject/1293838/" target="_blank" rel="noopener">《星球大战》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><hr><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><ul><li>树莓派 3B+</li><li>OS：Raspbian 9.4 (Stretch)</li><li>TF卡：三星SAMSUNG 32GB EVO+</li><li>PMS：1.15.2.793 armhf</li><li>移动硬盘：1TB</li></ul><h2 id="什么是Plex"><a href="#什么是Plex" class="headerlink" title="什么是Plex"></a>什么是Plex</h2><p>Plex主打流媒体传输服务，简单来说，有一台放满资料的设备，通过安装 <code>PMS(Plex Media Server)</code>，就可以打通Windows/Linux/Mac电脑、电视TV、Android/IOS手机、PS/XBOX游戏主机等等设备。Plex是在服务端解码，然后实现串流，所以在树莓派上安装Plex服务的话，受性能限制，720P以下的感觉还行，流畅播放，再高就有点吃不消了。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_what_is_plex.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_what_is_plex.jpg" alt=""></picture></p><p>相比<a href="https://www.zhihu.com/question/30096498" target="_blank" rel="noopener">Kodi</a>，Plex的界面美观简单、交互优秀、服务完整，配置起来对新手也友好。p.s想了解更多Plex的东西可以看下<a href="#引用">引用</a>，这篇我主要分享下树莓派上的安装和挂载U盘等技术问题。</p><h2 id="安装PMS"><a href="#安装PMS" class="headerlink" title="安装PMS"></a>安装PMS</h2><p><strong>官网已经有了基于armhf/ARMv7并支持树莓派的安装包了，非常方便！</strong></p><p>之所以强调上面这句话，是因为网上大部分资料都是基于<a href="https://dev2day.de/plex-media-server-arm/" target="_blank" rel="noopener">dev2day.de</a>的版本，装起来略微麻烦一点，就连这个包的<a href="https://github.com/uglymagoo/" target="_blank" rel="noopener">作者</a>都表示：</p><blockquote><p>Plex now provides official packages. So, this project is considered EOL by me.</p></blockquote><p>官方的版本装起来就很容易了，安装之前，大家需要到<a href="https://plex.tv/" target="_blank" rel="noopener">Plex官网</a>先注册个账号。</p><p>第一步：更新树莓派到最新。可以更换成<a href="/python-ubuntu-nodejs-change-sources/">国内源</a>，速度会快很多。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更换清华大学源</span></span><br><span class="line">sudo sed -i 's|raspbian.raspberrypi.org|mirrors.tuna.tsinghua.edu.cn/raspbian|g' /etc/apt/sources.list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新系统</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最好重启一下</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>更新后，最好重启一下，有时候也会提示重启。</p><p>第二步：下载官方包并安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://downloads.plex.tv/plex-media-server-new/1.15.2.793-782228f99/debian/plexmediaserver_1.15.2.793-782228f99_armhf.deb</span><br></pre></td></tr></table></figure><p>下载慢的话，可以到官网下载离线版：<a href="https://www.plex.tv/media-server-downloads/" target="_blank" rel="noopener">https://www.plex.tv/media-server-downloads/</a>，注意选择ARMv7版本（armhf与ARMv7、ARMv8等区别可参考<a href="#引用">引用</a>）。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_download_plex.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_download_plex.jpg" alt=""></picture></p><p>deb的包安装大家应该很熟悉了，一句话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i plexmediaserver_1.15.2.793-782228f99_armhf.deb</span><br></pre></td></tr></table></figure><p>最后看下服务有没有启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status plexmediaserver</span><br></pre></td></tr></table></figure><p>如果出现running的提示 ，就说明服务运行正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">● plexmediaserver.service - Plex Media Server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/plexmediaserver.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2019-03-27 17:30:23 CST; 2h 51min ago</span><br></pre></td></tr></table></figure><p>此时可以在菜单里面启动，或者直接在浏览器中输入：<a href="http://localhost:32400/web/" target="_blank" rel="noopener">http://localhost:32400/web/</a></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_start_from_gui2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_start_from_gui2.jpg" alt=""></picture></p><p>首次启动需要你登录Plex账号：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_login_in_plex2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_login_in_plex2.jpg" alt=""></picture></p><p>设置服务器的名称：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_name_your_server2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_name_your_server2.jpg" alt=""></picture></p><p>在添加资料库这里，默认是不支持树莓派上挂载的U盘和移动硬盘（what？我的pian都在硬盘里啊），别担心，我们后续解决。现在先不添加，直接下一步：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_add_your_lib2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_add_your_lib2.jpg" alt=""></picture></p><p>点击完成就进入Plex的控制面板了，局域网内的任何设备在浏览器中访问<a href="https://app.plex.tv/" target="_blank" rel="noopener">https://app.plex.tv</a>也可以。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_config_complete2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_config_complete2.jpg" alt=""></picture></p><h2 id="外挂U盘或移动硬盘"><a href="#外挂U盘或移动硬盘" class="headerlink" title="外挂U盘或移动硬盘"></a>外挂U盘或移动硬盘</h2><p> 现在总不能把电影、资料啥的都存在树莓派的TF卡里吧。解决方法也很简单：使用分区的唯一标识码（<a href="https://baike.baidu.com/item/UUID" target="_blank" rel="noopener">Universally Unique Identifier/UUID</a>）在fstab文件中自动挂载分区。</p><p>首先在树莓派上插入移动硬盘，打印出其状态信息，比如我的设备地址是<code>/dev/sda1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /proc/mounts</span><br><span class="line"><span class="meta">#</span><span class="bash"> /dev/sda1 /media/pi/ex2tronMovie fuseblk rw,nosuid,nodev,relatime,user_id=0,group_id=0,default_permissions,allow_other,blksize=4096 0 0</span></span><br></pre></td></tr></table></figure><p>安装<a href="https://baike.baidu.com/item/NTFS-3G" target="_blank" rel="noopener">NTFS-3G</a>驱动程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ntfs-3g</span><br></pre></td></tr></table></figure><p>使用<a href="https://linoxide.com/linux-command/linux-id-command/" target="_blank" rel="noopener">id</a>指令打印出<code>User ID(UID)</code>和<code>Group ID(GID)</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id -g pi  # 1000</span><br><span class="line">id -u pi  # 1000</span><br></pre></td></tr></table></figure><p>再打印出硬盘分区的UUID，比如我的是：<code>B6A28862A2882947</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev/disk/by-uuid</span><br><span class="line"><span class="meta">#</span><span class="bash"> lrwxrwxrwx 1 root root 10 3月  27 16:13 B6A28862A2882947 -&gt; ../../sda1</span></span><br></pre></td></tr></table></figure><p>现在创建一个挂载硬盘的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /media/usb1</span><br></pre></td></tr></table></figure><p>Linux系统开机时会读取<code>/etc/fstab</code>文件中的内容，然后根据配置挂载磁盘。所以编辑这个文件，在末尾新增一条配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=B6A28862A2882947 /media/usb1 auto nofail,uid=1000,gid=1000,noatime 0 0</span><br></pre></td></tr></table></figure><p>其中三个id根据前面打印出来的实际情况填写。</p><p>接下来先卸载、再重新挂载硬盘，最后重启树莓派生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /dev/sda1</span><br><span class="line">sudo mount -a</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h2 id="添加资源库"><a href="#添加资源库" class="headerlink" title="添加资源库"></a>添加资源库</h2><p>重启后，打开Plex网页面板，在左侧点击”添加资源库”，选择usb1，哇啦，出来咯：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_add_libraries.png_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_add_libraries.png" alt=""></picture></p><p>我里面放了几部电影，添加后，Plex会自动解码并检索影片的相关信息，比如影片封面/资料等：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_my_movies2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_my_movies2.jpg" alt=""></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_my_movies_detail2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_my_movies_detail2.jpg" alt=""></picture></p><p><strong>一个字：爽~！</strong></p><p>最后，我测试了下在局域网内其他设备上的播放速度表现，如预期，720P 2G以下的流畅播放，表现不错。其他的嘛，”要什么自行车！！！”</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_actual_running2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_actual_running2.jpg" alt=""></picture></p><p>关于Plex设置远程访问和更多配置玩法，大家自行探索啊，不是本文的重点，有时间我也会分享下我的经验。p.s.看看我这个”电影达人”的片(●ˇ∀ˇ●)：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/raspberry_pi_plex_all_movies2.jpg_webp"><img class="image" src="http://blog.codec.wang/raspberry_pi_plex_all_movies2.jpg" alt=""></picture></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://forums.plex.tv/t/read-me-first-about-server-armv7-and-armv8-ubuntu-debian/226567" target="_blank" rel="noopener">About Server ARMv7 and ARMv8 Ubuntu / Debian</a></li><li><a href="https://dev2day.de/plex-media-server-arm/" target="_blank" rel="noopener">Plex Media Server on Debian armhf</a></li><li><a href="https://flixed.io/install-plex-raspberry-pi/" target="_blank" rel="noopener">How to Install Plex on a Raspberry Pi – Raspberry Pi Plex Server</a></li><li><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=214655" target="_blank" rel="noopener">HOWTO - Using Raspberry Pi 3+ as Plex Media Server</a></li><li><a href="http://support.plex.tv/articles/categories/media-preparation/" target="_blank" rel="noopener">官方：更好的命名你的资源文件</a></li><li><a href="http://shumeipai.nxez.com/2019/01/17/fstab-and-mobile-hard-disk-mounting-method.html" target="_blank" rel="noopener">树莓派实验室：浅析 fstab 与移动硬盘挂载方法</a></li><li><a href="https://www.vediotalk.com/?p=267" target="_blank" rel="noopener">VLOG丨树莓派Raspberry Pi 3安装PLEX…</a>]</li><li><a href="http://www.howtoip.com/how-to-set-up-plex-and-watch-your-movies-on-any-device/" target="_blank" rel="noopener">如何设置Plex（并在任何设备上观看您的电影）</a></li><li><a href="https://post.smzdm.com/p/552816/" target="_blank" rel="noopener">树莓派PI3的充分利用 篇三：搞定树莓派端的Plex服务端…</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电脑下载了部电影，晚上想在手机上看，老婆也想看（啥？！），拷贝？想在手机上看以前的电影或者硬盘里存的视频/照片，拷贝？使用云盘存储呢？速度、容量、播放码率、重复占用本地容量都是问题。如果有一块存放资源的硬盘，家人都可以高速访问它，何乐而不为呢？我说的不是NAS噢~
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="树莓派" scheme="http://www.codec.wang/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Plex" scheme="http://www.codec.wang/tags/Plex/"/>
    
  </entry>
  
  <entry>
    <title>串口传输中对float数据的处理</title>
    <link href="http://www.codec.wang/float-data-in-serialport/"/>
    <id>http://www.codec.wang/float-data-in-serialport/</id>
    <published>2019-03-25T08:16:35.000Z</published>
    <updated>2020-04-07T03:54:25.206Z</updated>
    
    <content type="html"><![CDATA[<p>我本专业是搞控制的，软件上就是天天跟上/下位机、通讯协议打交道。一次，有个学弟问我，他单片机采集的温度是小数，串口应该怎么发，协议怎么设计。<a id="more"></a></p><hr><blockquote><p><em>爱你所爱，行你所行，听从你心，无问西东。</em>——<a href="https://movie.douban.com/subject/6874741/" target="_blank" rel="noopener">《无问西东》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><p>他的想法是整数部分和小数部分分开发，比如100.3，1个字节代表整数部分，1个字节代表小数部分，那如果是300.421呢？超出了1个字节的表示范围，负数-3.14又该怎么发呢？当然可以设置多个字节表示数据，然后单独设置1个字节表示正负，但显然这种方式即麻烦又不合理。</p><p>其实，float类型数据，无论正负/大小，它都是占用4个字节的。因此，下位机可以将传感器数据转成4个字节，上位机再把四个字节转成float即可，并且转换在C和C#等语言中都是一句话的事。完整代码可到<a href="#引用">源码处</a>下载。</p><ul><li><a href="http://lostphp.com/hexconvert/" target="_blank" rel="noopener">IEE 754浮点数16进制在线转换</a></li></ul><h2 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h2><p><a href="https://baike.baidu.com/item/大小端模式" target="_blank" rel="noopener">大小端模式</a>大家应该比较熟悉了，大端模式是高字节存放在低地址中，低字节存放在高地址中。类似我们正常的从左到右阅读，数据由小到大，小端模式反之。这里之所以提及，是因为有时候不同的系统/工具得到的结果是反的，此时不用在意，是没错的。</p><h2 id="C语言-下位机"><a href="#C语言-下位机" class="headerlink" title="C语言/下位机"></a>C语言/下位机</h2><ul><li><a href="https://c.runoob.com/compile/11" target="_blank" rel="noopener">菜鸟C在线工具</a></li></ul><p>下位机一般是C语言编写的，可以将传感器数据转成字节数组，C中也就是字符数组，有多种方式：</p><blockquote><p>有的单片机芯片，当使用unsigned char时，串口发送不了，此时可以去掉unsigned试下。</p></blockquote><h3 id="方法一：强制指针类型转换"><a href="#方法一：强制指针类型转换" class="headerlink" title="方法一：强制指针类型转换"></a>方法一：强制指针类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float -&gt; char []</span></span><br><span class="line"><span class="keyword">float</span> sensorData = <span class="number">-3.14</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *arr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(&amp;sensorData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X,%02X,%02X,%02X\n"</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>], arr[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 结果：C3,F5,48,C0</span></span><br></pre></td></tr></table></figure><p>如果想保存到char数组中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> charArr[<span class="number">4</span>], i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) charArr[i] = *arr++;</span><br></pre></td></tr></table></figure><p>接下来反向转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char [] -&gt; float</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sBuf[<span class="number">4</span>];</span><br><span class="line">sBuf[<span class="number">0</span>] = <span class="number">0xC3</span>;</span><br><span class="line">sBuf[<span class="number">1</span>] = <span class="number">0xF5</span>;</span><br><span class="line">sBuf[<span class="number">2</span>] = <span class="number">0x48</span>;</span><br><span class="line">sBuf[<span class="number">3</span>] = <span class="number">0xC0</span>;</span><br><span class="line"><span class="keyword">float</span> *data = (<span class="keyword">float</span>*)(&amp;sBuf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, *data); <span class="comment">// 结果：-3.140000</span></span><br></pre></td></tr></table></figure><h3 id="方法二：使用联合体"><a href="#方法二：使用联合体" class="headerlink" title="方法二：使用联合体"></a>方法二：使用联合体</h3><p>利用联合体共享内存的原理，可以在联合体内同时定义float和char数组类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">float</span> data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> arr[<span class="number">4</span>];</span><br><span class="line">&#125; dataFormat;</span><br></pre></td></tr></table></figure><p>然后转换就比较简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float -&gt; char []</span></span><br><span class="line">dataFormat.data = <span class="number">-3.14</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X,%02X,%02X,%02X\n"</span>, dataFormat.arr[<span class="number">0</span>], dataFormat.arr[<span class="number">1</span>], dataFormat.arr[<span class="number">2</span>], dataFormat.arr[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 结果：C3,F5,48,C0</span></span><br></pre></td></tr></table></figure><p>反向转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char [] -&gt; float</span></span><br><span class="line">dataFormat.arr[<span class="number">0</span>] = <span class="number">0xC3</span>;</span><br><span class="line">dataFormat.arr[<span class="number">1</span>] = <span class="number">0xF5</span>;</span><br><span class="line">dataFormat.arr[<span class="number">2</span>] = <span class="number">0x48</span>;</span><br><span class="line">dataFormat.arr[<span class="number">3</span>] = <span class="number">0xC0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, dataFormat.data); <span class="comment">// 结果：-3.140000</span></span><br></pre></td></tr></table></figure><p>C语言还是很深奥的，上面两种是最通俗易懂的方式，更多牛逼的方式尽在Google…＞﹏＜</p><h2 id="C-上位机"><a href="#C-上位机" class="headerlink" title="C#/上位机"></a>C#/上位机</h2><ul><li><a href="https://c.runoob.com/compile/14" target="_blank" rel="noopener">菜鸟C#在线工具</a></li></ul><p>我一般使用C#编写上位机，所以以它为例。一般这类语言中都有自带的函数可以一句解决，比如C#中用<code>BitConverter.ToSingle()</code>和<code>BitConverter.GetBytes()</code>便可实现转换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// byte[] -&gt; float</span></span><br><span class="line"><span class="keyword">byte</span>[] recData = &#123;<span class="number">0xC3</span>,<span class="number">0XF5</span>,<span class="number">0X48</span>,<span class="number">0XC0</span>&#125;;</span><br><span class="line"><span class="keyword">float</span> sensorData = BitConverter.ToSingle(recData,<span class="number">0</span>); </span><br><span class="line">Console.WriteLine(sensorData); <span class="comment">// 结果：-3.14</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float -&gt; byte[]</span></span><br><span class="line"><span class="keyword">float</span> sData = <span class="number">-3.14f</span>;</span><br><span class="line"><span class="keyword">byte</span>[] rData = BitConverter.GetBytes(sData);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">byte</span> data <span class="keyword">in</span> rData) Console.Write(<span class="string">"&#123;0:X000&#125;,"</span>, data);</span><br><span class="line"><span class="comment">// 结果：C3,F5,48,C0,</span></span><br><span class="line"><span class="comment">// 判断大小端：Console.WriteLine(BitConverter.IsLittleEndian);</span></span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>既然知道了float数据怎么处理，那int/double呢？（原理是一样的）</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/BlogCode/tree/master/Float-In-SerialPort" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/float" target="_blank" rel="noopener">Microsoft float (C# Reference)</a></li><li><a href="https://blog.csdn.net/sijigang/article/details/1546117" target="_blank" rel="noopener">浮点型(FLOAT)与CHAR型转换</a></li><li><a href="https://blog.csdn.net/sygdp21/article/details/20476697" target="_blank" rel="noopener">float型数据与字节数组的转化</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我本专业是搞控制的，软件上就是天天跟上/下位机、通讯协议打交道。一次，有个学弟问我，他单片机采集的温度是小数，串口应该怎么发，协议怎么设计。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="串口" scheme="http://www.codec.wang/tags/%E4%B8%B2%E5%8F%A3/"/>
    
      <category term="float" scheme="http://www.codec.wang/tags/float/"/>
    
  </entry>
  
  <entry>
    <title>速度UP！Python/Ubuntu/NodeJS/树莓派等更换国内源汇总</title>
    <link href="http://www.codec.wang/python-ubuntu-nodejs-change-sources/"/>
    <id>http://www.codec.wang/python-ubuntu-nodejs-change-sources/</id>
    <published>2019-03-21T07:08:09.000Z</published>
    <updated>2020-04-07T03:55:42.910Z</updated>
    
    <content type="html"><![CDATA[<p>在Python/Linux/Node.js开发中，要经常下载各种各样的的包，然而由于默认的安装源大部分是在国外的服务器上，所以下载速度嘛……<a id="more"></a></p><blockquote><p><em>You‘ll never win with violence, Tony, you only win when you maintain your dignity.</em>  ——<a href="https://movie.douban.com/subject/27060077/" target="_blank" rel="noopener">《Green Book》</a></br><br><em>暴力永远无法取胜，托尼，只有坚守尊严才会赢。</em>——<a href="https://movie.douban.com/subject/27060077/" target="_blank" rel="noopener">《绿皮书》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><hr><p>有时真的是很捉急呀，所以学会更改安装源还是很有必要滴……Python默认源：<a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org/</a>，Ubuntu默认源：<a href="http://mirrors.ubuntu.com/" target="_blank" rel="noopener">http://mirrors.ubuntu.com/</a>，Node默认源：<a href="http://registry.npmjs.org" target="_blank" rel="noopener">http://registry.npmjs.org</a>。</p><h2 id="Python-pip更换源"><a href="#Python-pip更换源" class="headerlink" title="Python/pip更换源"></a>Python/pip更换源</h2><h3 id="更换前后速度对比"><a href="#更换前后速度对比" class="headerlink" title="更换前后速度对比"></a>更换前后速度对比</h3><p>具体速度提升跟网络也有关系，不过一般来说，提升还是相当明显的：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/python_ubuntu_node_before_change.jpg_webp"><img class="image" src="http://blog.codec.wang/python_ubuntu_node_before_change.jpg" alt="默认源，这速度够我出去旅游一趟了(。﹏。)"></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/python_ubuntu_node_after_change.jpg_webp"><img class="image" src="http://blog.codec.wang/python_ubuntu_node_after_change.jpg" alt="清华大学源"></picture></p><h3 id="常用国内源"><a href="#常用国内源" class="headerlink" title="常用国内源"></a>常用国内源</h3><ul><li>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a> | <a href="https://mirror.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">pypi镜像使用帮助</a></li><li>阿里巴巴：<a href="https://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">https://mirrors.aliyun.com/pypi/simple/</a> </li><li>腾讯云：<a href="http://mirrors.cloud.tencent.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.cloud.tencent.com/pypi/simple/</a></li><li>豆瓣：<a href="https://pypi.doubanio.com/simple/" target="_blank" rel="noopener">https://pypi.doubanio.com/simple/</a></li></ul><h3 id="临时更改"><a href="#临时更改" class="headerlink" title="临时更改"></a>临时更改</h3><p>临时更换源只需要多加一个<code>-i</code>参数（i表示index索引），比如这里更换成清华源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pkg -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h3 id="永久更改"><a href="#永久更改" class="headerlink" title="永久更改"></a>永久更改</h3><p>如果不想每次都这么麻烦的话，可以写入配置文件。新版的pip(&gt;=10.0.0)直接用下面一句话就行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pip版本：pip --version</span></span><br></pre></td></tr></table></figure><p>执行后，Windows/Linux都会在用户目录生成pip配置文件，如我的Windows是在： <code>C:\Users\ex2tron\AppData\Roaming\pip\pip.ini</code>，Linux是在： <code>/home/ex2tron/.config/pip/pip.conf</code>。</p><p>如果是旧版的pip，可以手动新建上面两个文件，然后编辑内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure><p>配置文件也可以直接建在用户目录下，如Windows：<code>C:\Users\ex2tron\pip\pip.ini</code>，Linux：<code>/home/ex2tron/.pip/pip.conf</code>。保存后，照常<code>pip install pkg</code>即可。</p><h2 id="Ubuntu-apt更换源"><a href="#Ubuntu-apt更换源" class="headerlink" title="Ubuntu/apt更换源"></a>Ubuntu/apt更换源</h2><h3 id="图形界面配置（新手推荐）"><a href="#图形界面配置（新手推荐）" class="headerlink" title="图形界面配置（新手推荐）"></a>图形界面配置（新手推荐）</h3><p>如果使用的是Ubuntu的Desktop版本，更换起来就比较容易了：打开’软件和更新’，’下载自’这里选择’其他站点’：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/python_ubuntu_node_change_ubuntu_source.png_webp"><img class="image" src="http://blog.codec.wang/python_ubuntu_node_change_ubuntu_source.png" alt=""></picture></p><p>然后在弹出的界面中选择你要更换的服务器，比如这里更换为阿里云：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/python_ubuntu_node_ubuntu_china_source.png_webp"><img class="image" src="http://blog.codec.wang/python_ubuntu_node_ubuntu_china_source.png" alt=""></picture></p><p>点击’选择服务器’后需要验证密码，执行更新操作就可以了。</p><h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><p>如果是不带GUI的Ubuntu服务器，或是想装X，那么可以手动更换。更换源时跟Ubuntu系统的版本也有关系，这里我以Ubuntu 18.04和清华镜像为例，后面我写了个小脚本，方便不同版本的童鞋使用。</p><p>首先需要知道的是，Linux把源列表存在<code>/etc/apt/sources.list</code>里面，有兴趣可以看下其中内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>接下来更换方法都一样，很多开源镜像站官方也有说明，比如：</p><ul><li><a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华大学Ubuntu镜像使用帮助</a></li><li><a href="http://mirrors.ustc.edu.cn/help/ubuntu.html" target="_blank" rel="noopener">中国科学技术大学Ubuntu镜像使用帮助</a></li><li><a href="https://opsx.alibaba.com/mirror?lang=zh-CN" target="_blank" rel="noopener">阿里云Ubuntu镜像使用帮助 点Ubuntu项右侧的帮助</a></li><li><a href="http://mirrors.163.com/.help/ubuntu.html" target="_blank" rel="noopener">网易Ubuntu镜像使用帮助</a></li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/python_ubuntu_node_tuna_tsinghua_help.jpg_webp"><img class="image" src="http://blog.codec.wang/python_ubuntu_node_tuna_tsinghua_help.jpg" alt=""></picture></p><p>第一步：先将原有的备份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>第二步：sudo编辑<code>sources.list文件</code>，修改其内容为镜像站提供的，如清华镜像站18.04：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line"># deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>第三步：保存关闭后，执行更新索引的操作就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>其实只要Ubuntu系统的版本代号对应起来就行。Ubuntu X.XX，第一个X代表年份，后两个X代表月份，一般4月份会发布LTS(<code>Long Term Support</code>)长期支持版本，常见的版本号和代码如下：</p><p>感兴趣的可以看<a href="#引用">引用</a>。</p><table><thead><tr><th align="center">版本</th><th align="center">代号</th><th align="center">日期</th></tr></thead><tbody><tr><td align="center">14.04 LTS</td><td align="center">Trusty Tahr / 可靠的塔尔羊</td><td align="center">2014年4月</td></tr><tr><td align="center">16.04 LTS</td><td align="center">Xenial Xerus / 好客的非洲地松鼠</td><td align="center">2016年4月</td></tr><tr><td align="center">18.04 LTS</td><td align="center">Bionic Beaver / 仿生海狸</td><td align="center">2018年4月</td></tr></tbody></table><h3 id="自动化脚本"><a href="#自动化脚本" class="headerlink" title="自动化脚本"></a>自动化脚本</h3><p>为了方便在Ubuntu常见的版本上更换源，我写了个自动化小脚本：<a href="https://github.com/ex2tron/MyLibsAndSamples/blob/master/016.Ubuntu%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%28Shell%29/UbuntuAutoChangeSource.sh" target="_blank" rel="noopener">UbuntuAutoChangeSource.sh</a>。脚本会自动检测Ubuntu系统版本，然后选择你想更换的镜像源就可以了：</p><p><img src="http://blog.codec.wang/python_ubuntu_node_auto_scripts.gif" alt=""></p><h2 id="树莓派Raspbian"><a href="#树莓派Raspbian" class="headerlink" title="树莓派Raspbian"></a>树莓派Raspbian</h2><h3 id="常用源"><a href="#常用源" class="headerlink" title="常用源"></a>常用源</h3><p>树莓派支持的OS很多，经常用的也是官方推荐的是<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">Raspbian</a>。官网上有个镜像列表：<a href="http://www.raspbian.org/RaspbianMirrors" target="_blank" rel="noopener">http://www.raspbian.org/RaspbianMirrors</a>，国内常用：</p><ul><li>清华大学：<a href="http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> | <a href="https://mirror.tuna.tsinghua.edu.cn/help/raspbian/" target="_blank" rel="noopener">使用帮助</a></li><li>中国科学技术大学：<a href="http://mirrors.ustc.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/raspbian/raspbian/</a> | <a href="http://mirrors.ustc.edu.cn/help/raspbian.html" target="_blank" rel="noopener">使用帮助</a></li></ul><h3 id="更换方法"><a href="#更换方法" class="headerlink" title="更换方法"></a>更换方法</h3><p>源列表同样存储在 <code>/etc/apt/sources.list</code>中，所以最好先备份下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><p>更换时也跟版本有关，比如基于Debian 9 Stretch构建的<code>Raspbian 2018-11-13</code>版本修改成清华大学的源（可将原先的用#注释掉，也可以覆盖修改，反正已经备份了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; stretch main contrib non-free rpi</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure><p>虽说跟版本有关，但基本上只要把源的地址改掉就好了。比如上面的修改方式也可以使用sed工具一键修改（针对<code>Raspbian 2018-04-19</code>后的版本）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i 's|raspbian.raspberrypi.org|mirrors.tuna.tsinghua.edu.cn/raspbian|g' /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>最后记得更新一下就好了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="Node-js-npm更换源"><a href="#Node-js-npm更换源" class="headerlink" title="Node.js/npm更换源"></a>Node.js/npm更换源</h2><h3 id="临时更换"><a href="#临时更换" class="headerlink" title="临时更换"></a>临时更换</h3><p>国内最常用的npm镜像站是淘宝的：<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a> 。临时更换就是加上<code>--registry</code>选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pkg --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="永久更改-1"><a href="#永久更改-1" class="headerlink" title="永久更改"></a>永久更改</h3><p>类似于pip，可以直接使用<code>npm config</code>设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>验证有无生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>要恢复默认的话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.npmjs.org</span><br></pre></td></tr></table></figure><p>速度对比我就不放了，总之，各类包管理器，更换为国内的源之后，速度都会大幅提升。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华大学开源镜像站</a></li><li><a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener">阿里巴巴开源镜像站</a></li><li><a href="http://mirrors.163.com/" target="_blank" rel="noopener">网易开源镜像站</a></li><li><a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">浙江大学开源镜像站</a></li><li><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">中国科学技术大学开源镜像站</a></li><li><a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像站</a></li><li><a href="https://github.com/ex2tron/MyLibsAndSamples/tree/master/016.Ubuntu%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%28Shell%29" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://wiki.ubuntu.com/DevelopmentCodeNames" target="_blank" rel="noopener">Ubuntu官网版本号及代号说明：DevelopmentCodeNames</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Python/Linux/Node.js开发中，要经常下载各种各样的的包，然而由于默认的安装源大部分是在国外的服务器上，所以下载速度嘛……
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="Ubuntu" scheme="http://www.codec.wang/tags/Ubuntu/"/>
    
      <category term="NodeJS" scheme="http://www.codec.wang/tags/NodeJS/"/>
    
      <category term="pip" scheme="http://www.codec.wang/tags/pip/"/>
    
      <category term="nmp" scheme="http://www.codec.wang/tags/nmp/"/>
    
      <category term="apt" scheme="http://www.codec.wang/tags/apt/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上安装Windows10双系统步骤及常见问题</title>
    <link href="http://www.codec.wang/install-windows10-on-ubuntu/"/>
    <id>http://www.codec.wang/install-windows10-on-ubuntu/</id>
    <published>2019-03-17T12:42:59.000Z</published>
    <updated>2020-04-07T04:46:51.592Z</updated>
    
    <content type="html"><![CDATA[<p>之前想装个Windows10+Ubuntu的双系统，网上有很多教程是Windows上怎么安装Ubuntu的，可我电脑TMD本身就是Ubuntu啊，在Ubuntu上安装Windows的资料相对较少，真是神坑。下面分享下我的教程：<a id="more"></a></p><blockquote><p><em>The world is full of lonely people waiting to make the first move.</em>  ——<a href="https://movie.douban.com/subject/27060077/" target="_blank" rel="noopener">《Green Book》</a></br><br><em>世界上有太多孤独的人害怕先踏出第一步。</em>——<a href="https://movie.douban.com/subject/27060077/" target="_blank" rel="noopener">《绿皮书》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><hr><p>分区和安装有风险，不熟悉的同学请提前<strong>备份数据</strong>并<strong>谨慎操作</strong>！！！</p><ul><li>Ubuntu 16.04.5</li><li>Windows 10 1809</li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>分区是最为关键的步骤，一般有两种情况：</p><ol><li><p>你的电脑上已经有一个单独的不用的分区，比如有的电脑上是SSD+HDD的，这种情况下你可以将Windows直接安装在这个分区上，最后只要添加下引导就行。</p></li><li><p>如果不是上面的情况，也就是整个硬盘都在为Ubuntu所使用，就要分出一个区来：</p></li></ol><p><strong>简单的分区方式（简单的不行可以看后面复杂的）</strong></p><p>Ubuntu上安装<code>gparted</code>图形化分区工具：<code>sudo apt install gparted</code>。打开之后，选择要分区的区域，比如我要从<code>/dev/sda1</code>中分区，然后点击菜单栏的调整分区大小按钮：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_install_gparted.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_install_gparted.jpg" alt=""></picture></p><p>如果出来的界面某些项是灰色的（就像上图这样），说明不可以用这种方式分区。</p><p><strong>略微复杂的方式</strong></p><p>需要一个Ubuntu的U盘镜像（不必跟你原来的Ubuntu系统同版本），以普通的装机方式进入安装程序后，到安装类型这一步，千万不要乱选，一定要选<strong>其他选项</strong>：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_disk_part_with_install_ubuntu.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_disk_part_with_install_ubuntu.jpg" alt=""></picture></p><p>然后选择你要分区的区域，点击下方的更改：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_disk_part_with_install_ubuntu2.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_disk_part_with_install_ubuntu2.jpg" alt=""></picture></p><p>在弹出的更改区域大小中，输入新分区的大小，点击OK，成功之后，<strong>就退出安装</strong>，不要再安装一个Ubuntu了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_disk_part_with_install_ubuntu3.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_disk_part_with_install_ubuntu3.jpg" alt=""></picture></p><p>前面就实现了分区，但Windows的分区格式跟Ubuntu不一样，所以需要回到Ubuntu系统，打开gparted，将分区转换成ntfs格式，用于安装Windows：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_convert_ntfs2.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_convert_ntfs2.jpg" alt=""></picture></p><h3 id="安装Windows"><a href="#安装Windows" class="headerlink" title="安装Windows"></a>安装Windows</h3><p>这一步就是正常的Windows安装流程（不赘述，安装的时候记得选择我们刚分好的区）</p><h3 id="引导项修复"><a href="#引导项修复" class="headerlink" title="引导项修复"></a>引导项修复</h3><p>安装完Windows后，Ubuntu的引导项就不见了。最简单的方法是在Windows上安装使用<a href="https://neosmart.net/EasyBCD/" target="_blank" rel="noopener">EasyBCD</a>引导Ubuntu：</p><p><strong>首先添加引导项，一定记得选Swap交换分区</strong></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_boot_grub_add.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_boot_grub_add.jpg" alt=""></picture></p><p><strong><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_boot_grub_add2.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_boot_grub_add2.jpg" alt=""></picture></strong></p><p><strong>然后点击“编辑引导菜单”并保存设置</strong></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_boot_grub_add3.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_boot_grub_add3.jpg" alt=""></picture></p><p>这样就完成了全部安装流程。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>问题1：如果开机选择Ubuntu系统时出现：</strong></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_cannot_bootin_ubuntu.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_cannot_bootin_ubuntu.jpg" alt=""></picture></p><p>解决方案：进入Windows系统，使用EasyBCD重新引导即可，具体步骤：</p><ul><li>先将原有的Ubuntu引导项删除</li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_delete_boot_option.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_delete_boot_option.jpg" alt=""></picture></p><ul><li>然后重复之前添加引导项的步骤即可。</li></ul><p><strong>问题2：使用刻录的Ubuntu U盘镜像安装系统时出现：</strong></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_install_ubuntu_problem.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_install_ubuntu_problem.jpg" alt=""></picture></p><p>解决方案：按下<strong>tab键</strong>，会弹出如下提示：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/ubuntu_windows_install_ubuntu_problem2.jpg_webp"><img class="image" src="http://blog.codec.wang/ubuntu_windows_install_ubuntu_problem2.jpg" alt=""></picture></p><p>按照提示，输入<code>live live-install</code>回车即可。</p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前想装个Windows10+Ubuntu的双系统，网上有很多教程是Windows上怎么安装Ubuntu的，可我电脑TMD本身就是Ubuntu啊，在Ubuntu上安装Windows的资料相对较少，真是神坑。下面分享下我的教程：
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Build" scheme="http://www.codec.wang/tags/Build/"/>
    
      <category term="Windows" scheme="http://www.codec.wang/tags/Windows/"/>
    
      <category term="Ubuntu" scheme="http://www.codec.wang/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>使用环境变量避免在代码中写明密码和密钥等重要信息</title>
    <link href="http://www.codec.wang/hiding-passwds-secret-keys-in-environment-variables/"/>
    <id>http://www.codec.wang/hiding-passwds-secret-keys-in-environment-variables/</id>
    <published>2019-01-19T14:29:07.000Z</published>
    <updated>2020-04-07T03:55:17.425Z</updated>
    
    <content type="html"><![CDATA[<p>很多人会在代码中直接明码写上数据库用户名/密码、API Key这些重要信息，这种方式很不安全，因为别人在看到代码后是可以直接使用这些信息的。<a id="more"></a>有很多隐藏密码的技巧，环境变量便是其中之一。</p><hr><p>使用环境变量的好处在于，你仍然可以完全共享你的代码而不用担心泄露重要信息。</p><iframe src="//player.bilibili.com/player.html?aid=41137201&cid=72253896&page=1" width="640" height="480"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>以下面这段Python代码为例，代码中直接写明了数据库用户名和密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db_user = <span class="string">"ex2tron"</span></span><br><span class="line">db_passwd = <span class="string">"ex2tron12345"</span></span><br><span class="line"></span><br><span class="line">print(db_user, db_passwd)</span><br></pre></td></tr></table></figure><p>我们看下如何使用环境变量隐藏这些信息：</p><h2 id="Linux下隐藏方式"><a href="#Linux下隐藏方式" class="headerlink" title="Linux下隐藏方式"></a>Linux下隐藏方式</h2><p>Linux系统的运行是以各种可自由编辑的配置文件为基础的，以Ubuntu为例，我们可以编辑当前用户的终端配置文件<code>.bashrc</code>。</p><blockquote><p>大部分配置文件位于当前用户目录下，如果在其他目录的话，可以直接输入cd快速切换。</p></blockquote><p>在<code>.bashrc</code>文件的末尾添加下面两句，注意等号左右无空格噢：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DB_USER="ex2tron"</span><br><span class="line">export DB_PASSWD="ex2tron12345"</span><br></pre></td></tr></table></figure><p>可以在当前终端<code>source ~/.bashrc</code>或重启终端使环境变量生效。之后代码只需略作修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">db_user = os.environ.get(<span class="string">"DB_USER"</span>)</span><br><span class="line">db_passwd = os.environ.get(<span class="string">"DB_PASSWD"</span>)</span><br><span class="line"></span><br><span class="line">print(db_user, db_passwd)</span><br></pre></td></tr></table></figure><h2 id="Windows下隐藏方式"><a href="#Windows下隐藏方式" class="headerlink" title="Windows下隐藏方式"></a>Windows下隐藏方式</h2><p>熟悉Windows配置软件的童鞋应该经常用到Path环境变量，同样，我们也可以建两个自己的环境变量。在开始菜单搜索环境变量，打开系统属性窗口并点击“环境变量”：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hiding_info_open_environment_variables.jpg_webp"><img class="image" src="http://blog.codec.wang/hiding_info_open_environment_variables.jpg" alt=""></picture></p><p>在环境变量界面，可以在用户环境变量下点击新建，新建两个变量用来存储数据库用户名和密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB_USERex2tron</span><br><span class="line">DB_PASSWDex2tron12345</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hiding_info_add_new_variable.jpg_webp"><img class="image" src="http://blog.codec.wang/hiding_info_add_new_variable.jpg" alt=""></picture></p><p>编辑好之后，代码跟前面的修改方式一样。如果打印出来为空，说明环境变量没有生效，可以重启你的IDE。</p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人会在代码中直接明码写上数据库用户名/密码、API Key这些重要信息，这种方式很不安全，因为别人在看到代码后是可以直接使用这些信息的。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Build" scheme="http://www.codec.wang/tags/Build/"/>
    
      <category term="hiding-info" scheme="http://www.codec.wang/tags/hiding-info/"/>
    
      <category term="environment-variables" scheme="http://www.codec.wang/tags/environment-variables/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Windows 10的OpenSSH Client和Server</title>
    <link href="http://www.codec.wang/how-to-use-ssh-on-windows10/"/>
    <id>http://www.codec.wang/how-to-use-ssh-on-windows10/</id>
    <published>2019-01-02T13:00:54.000Z</published>
    <updated>2020-04-07T03:54:51.684Z</updated>
    
    <content type="html"><![CDATA[<p>SSH目前是Unix和Linux上用于加密连接远程服务器的命令行工具，微软也在最新的Windows10中集成了OpenSSH，下面就来看下怎么开启并使用。<a id="more"></a></p><hr><iframe src="//player.bilibili.com/player.html?aid=39769302&cid=69862435&page=1" width="640" height="480"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>新版Windows 10（1803及以上）都已预装了OpenSSH Client，但默认并没有装SSH Server。要测试有没有安装的话，可以打开命令行cmd，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -V</span><br><span class="line"><span class="comment"># OpenSSH_for_Windows_7.6p1, LibreSSL 2.6.4</span></span><br></pre></td></tr></table></figure><p>如果你的Win10版本较低的话，可能没有预装，也没有关系，下面来看。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Windows 10开始菜单搜索“管理可选功能”，或打开Windows 10的设置，找到应用和功能，并选择“管理可选功能”：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/win10-ssh-client-app-features.jpg_webp"><img class="image" src="http://blog.codec.wang/win10-ssh-client-app-features.jpg" alt=""></picture></p><p>在管理可选功能页面，点击“添加功能”，找到<code>OpenSSH 客户端</code>和<code>OpenSSH 服务器</code>，客户端没有的话，说明已经安装了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/win10-ssh-client-app-features-add-server-client.jpg_webp"><img class="image" src="http://blog.codec.wang/win10-ssh-client-app-features-add-server-client.jpg" alt=""></picture></p><p>如果你只是想使用SSH连接服务器，而不是把自己的电脑当作服务器的话，Server是不需要安装的。安装路径是在<code>C:\Windows\System32\OpenSSH\</code>目录下，可以看到除了SSH，Windows 10也自带了scp，sftp等很实用的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dir C:\Windows\System32\OpenSSH</span><br><span class="line"><span class="comment"># scp.exe</span></span><br><span class="line"><span class="comment"># sftp.exe</span></span><br><span class="line"><span class="comment"># ssh-keygen.exe</span></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure><h2 id="SSH-Client的使用"><a href="#SSH-Client的使用" class="headerlink" title="SSH Client的使用"></a>SSH Client的使用</h2><p>安装好之后，就和正常使用SSH没有区别了，比如局域网内有台服务器IP地址是<code>192.168.1.110</code>，那么在Win10 cmd下输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@192.168.1.110</span><br></pre></td></tr></table></figure><p>客户端的使用跟Linux下SSH的使用一致，就不赘述了。主要来看下Win10上Server的配置。</p><h2 id="SSH-Server的使用"><a href="#SSH-Server的使用" class="headerlink" title="SSH Server的使用"></a>SSH Server的使用</h2><p>安装好<code>OpenSSH Server</code>后，Win10开始菜单搜索服务，打开服务，找到<code>OpenSSH SSH Server</code>，目前它的状态是手动并已停止服务：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/win10-ssh-sever-services-status.jpg_webp"><img class="image" src="http://blog.codec.wang/win10-ssh-sever-services-status.jpg" alt=""></picture></p><p>我们可以右键启动服务，如果你经常用到它的话，可以在属性中设置为自动启动。</p><p>要检测SSH服务有没有运行的话，可以在cmd中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | findstr 22</span><br><span class="line"><span class="comment"># TCP    0.0.0.0:22             ex2tronSurface:0       LISTENING</span></span><br></pre></td></tr></table></figure><p>确认开启后，本机Win10就可以接收外部SSH连接了。在cmd输入<code>ipconfig</code>，获取现在Win10的IP，比如是<code>192.168.1.199</code>，用另一台任意操作系统的电脑使用SSH便可连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@192.168.1.199</span><br></pre></td></tr></table></figure><p>注意此时用户名和密码是你Win10的用户名和密码。</p><h2 id="sshd-配置文件"><a href="#sshd-配置文件" class="headerlink" title="sshd 配置文件"></a>sshd 配置文件</h2><p>SSH服务开启后，默认的配置文件在<code>C:\Windows\System32\OpenSSH\</code>目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir C:\Windows\System32\OpenSSH\</span><br><span class="line"><span class="comment"># sshd_config_default</span></span><br></pre></td></tr></table></figure><p>但实际运行的配置文件是<code>C:\ProgramData\ssh\sshd_config</code>，熟悉SSH的同学对里面的配置项应该都了解，比如ssh默认启动路径<code>ChrootDirectory</code>。默认情况下，ssh连接后，启动路径是Windows的个人文件夹，如<code>C:\Users\ex2tron</code>，我一般会更改到我的工作路径，如：<code>D:\Surface</code>，就可以这样修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChrootDirectory D:\Surface</span><br></pre></td></tr></table></figure><p>其他配置项常用的有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin # 是否允许root登陆</span><br><span class="line">PasswordAuthentication # 是否运行使用密码登陆，如果你已经建立好ssh公钥的话，可以设置为no免密登陆，更安全</span><br><span class="line">PermitEmptyPasswords # 是否允许空密码</span><br><span class="line">AuthorizedKeysFile # ssh公钥目录</span><br></pre></td></tr></table></figure><p>配置完之后一定记得重启<code>ssh server</code>，否则是不会生效的。一种方法是服务里面，右键选择重启：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/win10-ssh-server-config-reboot-service.jpg_webp"><img class="image" src="http://blog.codec.wang/win10-ssh-server-config-reboot-service.jpg" alt=""></picture></p><p>还有一种就是在cmd下直接重启，cmd需以管理员权限打开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop sshd</span><br><span class="line">net start sshd</span><br></pre></td></tr></table></figure><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSH目前是Unix和Linux上用于加密连接远程服务器的命令行工具，微软也在最新的Windows10中集成了OpenSSH，下面就来看下怎么开启并使用。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Build" scheme="http://www.codec.wang/tags/Build/"/>
    
      <category term="Windows10" scheme="http://www.codec.wang/tags/Windows10/"/>
    
      <category term="SSH" scheme="http://www.codec.wang/tags/SSH/"/>
    
      <category term="SSH-Server" scheme="http://www.codec.wang/tags/SSH-Server/"/>
    
  </entry>
  
  <entry>
    <title>2018最后一个工作日，一份小礼物</title>
    <link href="http://www.codec.wang/a-gift-for-2019-moviequotes/"/>
    <id>http://www.codec.wang/a-gift-for-2019-moviequotes/</id>
    <published>2018-12-29T10:00:31.000Z</published>
    <updated>2020-04-07T03:54:06.736Z</updated>
    
    <content type="html"><![CDATA[<center>[**moviequotes.ex2tron.wang**](http://moviequotes.ex2tron.wang)</center><hr><blockquote><p>2018是感伤的一年，很多人离我们而去，太多的不开心…好在就要结束了。今天是最后一个工作日（其实在学校我每天都在放假(●ˇ∀ˇ●)），特送上一份小礼物给大家：<a href="http://moviequotes.ex2tron.wang" target="_blank" rel="noopener">MovieQuotes</a></p></blockquote><a id="more"></a>这是个简单的电影经典台词网站，灵感来自我以前在腾讯学习Scrapy时的一个网站[quotes.toscrape.com](http://quotes.toscrape.com)，这上面是一些名人名句。因为我平常喜欢看电影，写博客的时候也经常在开头放一句经典台词，所以平时搜集了不少，于是就有了这个网站。网站本身很简单，用Python和Django搭的，没什么难的东西，下面是一些截图：<p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/moviequotes_phone_ui_demo2.jpg_webp"><img class="image" src="http://blog.codec.wang/moviequotes_phone_ui_demo2.jpg" alt="手机 显示效果图"></picture></p><p>各位看官不要嫌UI丑啊，我是完全模仿原网站做的。后期如果有时间我会更换一套自己的UI。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/moviequotes_pc_ui_demo.jpg_webp"><img class="image" src="http://blog.codec.wang/moviequotes_pc_ui_demo.jpg" alt="PC 显示效果图"></picture></p><p>其实每句电影台词配一张截图最好了，不过加上去有点丑，所以没放出来。另外，多用户登陆注册和分享的功能同样也没放出来，目前一切从简。有想要贡献词条的同学可以联系我噢，最后<strong>祝大家元旦快乐！</strong>(☆▽☆)</p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;[**moviequotes.ex2tron.wang**](http://moviequotes.ex2tron.wang)&lt;/center&gt;

&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;2018是感伤的一年，很多人离我们而去，太多的不开心…好在就要结束了。今天是最后一个工作日（其实在学校我每天都在放假(●ˇ∀ˇ●)），特送上一份小礼物给大家：&lt;a href=&quot;http://moviequotes.ex2tron.wang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MovieQuotes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Build" scheme="http://www.codec.wang/tags/Build/"/>
    
      <category term="Django" scheme="http://www.codec.wang/tags/Django/"/>
    
      <category term="电影台词" scheme="http://www.codec.wang/tags/%E7%94%B5%E5%BD%B1%E5%8F%B0%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>MightyPy：Base64</title>
    <link href="http://www.codec.wang/mighty-py-base64/"/>
    <id>http://www.codec.wang/mighty-py-base64/</id>
    <published>2018-04-28T14:20:53.000Z</published>
    <updated>2020-04-07T03:43:24.716Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道日常的图片、视频、pdf、exe等等这些文件都是二进制文件，如果用文本编辑器打开它们，基本都是乱码，那么有没有一种简单的二进制转成字符串的方式呢？<a id="more"></a></p><blockquote><p><em>Valar Morghulis, Valar Dohaeris.</em>  ——<a href="https://movie.douban.com/subject/3016187/" target="_blank" rel="noopener">《Game of Thrones》</a><br><em>凡人皆有一死，凡人皆须侍奉。</em>——<a href="https://movie.douban.com/subject/3016187/" target="_blank" rel="noopener">《权力的游戏》</a></p><p><strong>友情广告：电影台词分享网站：<a href="http://moviequotes.ex2tron.wang/" target="_blank" rel="noopener">MovieQuotes</a></strong></p></blockquote><hr><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64是一种用64个可打印字符来表示二进制数据的一种方法。</p><p>原理其实很简单，首先定义一个长度为64的字符数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base = [<span class="string">'A'</span>, <span class="string">'B'</span>, ..., <span class="string">'Z'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, ..., <span class="string">'z'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, ..., <span class="string">'9'</span>, <span class="string">'+'</span>, <span class="string">'/'</span>]</span><br></pre></td></tr></table></figure><p>标准的Base64编码是由26个大写字母、26个小写字母、[0-9]10个数字、’+’、’/‘共64个字符组成的。你也可以自定义这些字符来实现自己的Base64编码。</p><p>将原二进制数据每3个字节为一组进行划分，一共3×8=24bit，划分成4组，也就是每组6bit，6bit可表示的长度为2^6=64，这就是Base64名称的由来。然后将每组6bit对应的值作为索引，在前面定义的数组中查表，就得到了编码后对应的4个字符。</p><p>比如，把”Man”进行Base64编码：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/depth_python_base64_sample2.jpg_webp"><img class="image" src="http://blog.codec.wang/depth_python_base64_sample2.jpg" alt=""></picture></p><p>Python中可以直接用内置的<a href="#接口文档">base64</a>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">print(base64.b64encode(<span class="string">b'Man'</span>))  <span class="comment"># 'TWFu'</span></span><br><span class="line"><span class="comment"># 或：base64.b64encode(b'\x4D\x61\x6E')</span></span><br><span class="line">print(base64.b64decode(<span class="string">'TWFu'</span>))  <span class="comment"># 'man'</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/depth_python_base64_index_table.jpg_webp"><img class="image" src="http://blog.codec.wang/depth_python_base64_index_table.jpg" alt="@维基百科 Base64"></picture></p><h3 id="不是3的倍数"><a href="#不是3的倍数" class="headerlink" title="不是3的倍数"></a>不是3的倍数</h3><p>Base64是每3个字节编码的，遇到不足3个字节的情况时，会在末尾补0，再在末尾加个1个或2个 ‘=’号表示补了多少个字节，解码时再将’=’去掉。</p><p>比如参考前面的’Man’，对’M’单独进行编码：第一组还是原有的6bit，结果是字符’T’；第二组只剩下’01’，补充4个0，即’010000’，索引值为16，对应的字符是’Q’；第三和第四组都是0了，所以再加两个’=’，最终结果是’TQ==’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(base64.b64encode(<span class="string">b'M'</span>))  <span class="comment"># 'TQ=='</span></span><br></pre></td></tr></table></figure><p><strong>总之，Base64编码后的长度永远是4的倍数！</strong></p><h3 id="URL中特殊字符的处理"><a href="#URL中特殊字符的处理" class="headerlink" title="URL中特殊字符的处理"></a>URL中特殊字符的处理</h3><p>标准Base64编码中会出现’+’和’/‘字符，如果在url中使用，url编码器会转换成’%2B’和’%2F’，解码或数据库存储时需要将%再次转换。为避免出错并简化操作，提出了一种可用于url的改进Base64编码：将’+’和’/‘分别改成’-‘和’_’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(base64.b64encode(<span class="string">b'\xFB\xfe'</span>))  <span class="comment"># '+/4='</span></span><br><span class="line">print(base64.urlsafe_b64encode(<span class="string">b'\xFB\xfe'</span>))  <span class="comment"># '-_4='</span></span><br></pre></td></tr></table></figure><h3 id="图片Base64编码"><a href="#图片Base64编码" class="headerlink" title="图片Base64编码"></a>图片Base64编码</h3><p>图片的Base64编码用的较多。Python打开文件时，指定’rb’参数，可以获取原始的二进制数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'lena.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> pic:</span><br><span class="line">    pic_str_data = base64.b64encode(pic.read())</span><br><span class="line"></span><br><span class="line">print(pic_str_data)</span><br></pre></td></tr></table></figure><h3 id="中文Base64编码"><a href="#中文Base64编码" class="headerlink" title="中文Base64编码"></a>中文Base64编码</h3><p>Base64只跟二进制有关系，跟字符集无关。对于中文的话，按照你使用的字符集（比如utf-8）编码成二进制后再用Base64就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch_bytes = <span class="string">'中'</span>.encode(<span class="string">'utf-8'</span>) <span class="comment"># b'\xe4\xb8\xad'</span></span><br><span class="line"><span class="comment"># encode()默认是utf-8，可省略</span></span><br><span class="line">print(ch_bytes.decode()) <span class="comment"># '中'</span></span><br><span class="line"></span><br><span class="line">print(base64.b64encode(ch_bytes))</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>作为一种二进制到字符串的编码方式，Base64可以编码任意的二进制数据，便于文本显示和接口处理；但因为是将3个字节编码成4个字节，二进制数据长度相当于增加了1/3=33%左右。</p><h2 id="手动实现Base64"><a href="#手动实现Base64" class="headerlink" title="手动实现Base64"></a>手动实现Base64</h2><p>当然我们也可以实现自己的Base64编码，不过一般没有必要。比如下面是我自己实现的标准Base64编码，效率慢了8倍左右，仅供学习参考，网上也有其他方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义64字符</span></span><br><span class="line">base_charset = string.ascii_uppercase+string.ascii_lowercase+string.digits+<span class="string">"+/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_b64_encode</span><span class="params">(ori_bytes)</span>:</span></span><br><span class="line">    ret, ori_len = <span class="string">""</span>, len(ori_bytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, ori_len, <span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 第一组</span></span><br><span class="line">        first = (ori_bytes[i] &amp; <span class="number">0xFC</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">        ret += base_charset[first]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二组</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &gt;= ori_len:</span><br><span class="line">            second = (ori_bytes[i] &amp; <span class="number">0x03</span>)*<span class="number">16</span></span><br><span class="line">            ret += base_charset[second] + <span class="string">"=="</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        second = (ori_bytes[i] &amp; <span class="number">0x03</span>)*<span class="number">16</span> + ((ori_bytes[i+<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>)</span><br><span class="line">        ret += base_charset[second]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三组</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">2</span> &gt;= ori_len:</span><br><span class="line">            third = (ori_bytes[i+<span class="number">1</span>] &amp; <span class="number">0x0F</span>)*<span class="number">4</span></span><br><span class="line">            ret += base_charset[third] + <span class="string">"="</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        third = (ori_bytes[i+<span class="number">1</span>] &amp; <span class="number">0x0F</span>)*<span class="number">4</span> + ((ori_bytes[i+<span class="number">2</span>] &amp; <span class="number">0xC0</span>) &gt;&gt; <span class="number">6</span>)</span><br><span class="line">        ret += base_charset[third]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四组</span></span><br><span class="line">        fourth = ori_bytes[i+<span class="number">2</span>] &amp; <span class="number">0x3F</span></span><br><span class="line">        ret += base_charset[fourth]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">print(my_b64_encode(<span class="string">b'ManM'</span>))  <span class="comment"># TWFuTQ==</span></span><br></pre></td></tr></table></figure><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.python.org/3/library/base64.html" target="_blank" rel="noopener">Python base64</a></li><li><a href="https://docs.python.org/3/library/string.html" target="_blank" rel="noopener">Python string</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/BlogCode/tree/master/DepthPython/Base64" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">维基百科 Base64</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431954588961d6b6f51000ca4279a3415ce14ed9d709000" target="_blank" rel="noopener">廖雪峰Python教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道日常的图片、视频、pdf、exe等等这些文件都是二进制文件，如果用文本编辑器打开它们，基本都是乱码，那么有没有一种简单的二进制转成字符串的方式呢？
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="Base64" scheme="http://www.codec.wang/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程挑战任务：车道检测</title>
    <link href="http://www.codec.wang/opencv-python-lane-road-detection/"/>
    <id>http://www.codec.wang/opencv-python-lane-road-detection/</id>
    <published>2017-12-28T03:38:11.000Z</published>
    <updated>2020-04-07T04:59:50.572Z</updated>
    
    <content type="html"><![CDATA[<p>挑战任务：实际公路的车道线检测。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="挑战内容"><a href="#挑战内容" class="headerlink" title="挑战内容"></a>挑战内容</h2><blockquote><p><strong>1. 在所提供的公路图片上检测出车道线并标记：</strong></p></blockquote><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_result_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_result_sample.jpg" alt=""></picture></p><blockquote><p><strong>2. 在所提供的公路视频上检测出车道线并标记：</strong></p></blockquote><video autoplay muted loop src="http://blog.codec.wang/cv2_white_lane_green_mark.mp4"></video>本次挑战内容来自Udacity自动驾驶纳米学位课程，素材中车道保持不变，车道线清晰明确，易于检测，是车道检测的基础版本，网上也有很多针对复杂场景的高级实现，感兴趣的童鞋可以自行了解。<p><strong>挑战题不会做也木有关系，但请务必在自行尝试后，再看下面的解答噢，</strong>不然…我也没办法(￣▽￣)”</p><hr><h2 id="挑战解答"><a href="#挑战解答" class="headerlink" title="挑战解答"></a>挑战解答</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>要检测出当前车道，就是要检测出左右两条车道直线。由于无人车一直保持在当前车道，那么无人车上的相机拍摄的视频中，车道线的位置应该基本固定在某一个范围内：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_roi_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_roi_sample.jpg" alt=""></picture></p><p>如果我们手动把这部分ROI区域抠出来，就会排除掉大部分干扰。接下来检测直线肯定是用霍夫变换，但ROI区域内的边缘直线信息还是很多，考虑到只有左右两条车道线，一条斜率为正，一条为负，可将所有的线分为两组，每组再通过均值或最小二乘法拟合的方式确定唯一一条线就可以完成检测。总体步骤如下：</p><ol><li>灰度化</li><li>高斯模糊</li><li>Canny边缘检测</li><li>不规则ROI区域截取</li><li>霍夫直线检测</li><li>车道计算</li></ol><p>对于视频来说，只要一幅图能检查出来，合成下就可以了，问题不大。</p><h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><p>灰度化和滤波操作是大部分图像处理的必要步骤。灰度化不必多说，因为不是基于色彩信息识别的任务，所以没有必要用彩色图，可以大大减少计算量。而滤波会削弱图像噪点，排除干扰信息。另外，根据前面学习的知识，边缘提取是基于图像梯度的，梯度对噪声很敏感，所以平滑滤波操作必不可少。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_gray_blur_result.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_gray_blur_result.jpg" alt="原图 vs 灰度滤波图"></picture></p><p>这次的代码我们分模块来写，规范一点。其中<code>process_an_image()</code>是主要的图像处理流程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波核大小</span></span><br><span class="line">blur_ksize = <span class="number">5</span></span><br><span class="line"><span class="comment"># Canny边缘检测高低阈值</span></span><br><span class="line">canny_lth = <span class="number">50</span></span><br><span class="line">canny_hth = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_an_image</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 1. 灰度化、滤波和Canny</span></span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</span><br><span class="line">    blur_gray = cv2.GaussianBlur(gray, (blur_ksize, blur_ksize), <span class="number">1</span>)</span><br><span class="line">    edges = cv2.Canny(blur_gray, canny_lth, canny_hth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">'test_pictures/lane.jpg'</span>)</span><br><span class="line">    result = process_an_image(img)</span><br><span class="line">    cv2.imshow(<span class="string">"lane"</span>, np.hstack((img, result)))</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_canny_result.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_canny_result.jpg" alt="边缘检测结果图"></picture></p><h3 id="ROI截取"><a href="#ROI截取" class="headerlink" title="ROI截取"></a>ROI截取</h3><p>按照前面描述的方案，只需保留边缘图中的红线部分区域用于后续的霍夫直线检测，其余都是无用的信息：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_canny_roi_reserve.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_canny_roi_reserve.jpg" alt=""></picture></p><p>如何实现呢？还记得图像混合中的这张图吗？</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_mask.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_mask.jpg" alt=""></picture></p><p> 我们可以创建一个梯形的mask掩膜，然后与边缘检测结果图混合运算，掩膜中白色的部分保留，黑色的部分舍弃。梯形的四个坐标需要手动标记：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_mask_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_mask_sample.jpg" alt="掩膜mask"></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_an_image</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 1. 灰度化、滤波和Canny</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 标记四个坐标点用于ROI截取</span></span><br><span class="line">    rows, cols = edges.shape</span><br><span class="line">    points = np.array([[(<span class="number">0</span>, rows), (<span class="number">460</span>, <span class="number">325</span>), (<span class="number">520</span>, <span class="number">325</span>), (cols, rows)]])</span><br><span class="line">    <span class="comment"># [[[0 540], [460 325], [520 325], [960 540]]]</span></span><br><span class="line">    roi_edges = roi_mask(edges, points)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roi_mask</span><span class="params">(img, corner_points)</span>:</span></span><br><span class="line">    <span class="comment"># 创建掩膜</span></span><br><span class="line">    mask = np.zeros_like(img)</span><br><span class="line">    cv2.fillPoly(mask, corner_points, <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    masked_img = cv2.bitwise_and(img, mask)</span><br><span class="line">    <span class="keyword">return</span> masked_img</span><br></pre></td></tr></table></figure><p>这样，结果图”roi_edges”应该是：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_masked_roi_edges.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_masked_roi_edges.jpg" alt="只保留关键区域的边缘检测图"></picture></p><h3 id="霍夫直线提取"><a href="#霍夫直线提取" class="headerlink" title="霍夫直线提取"></a>霍夫直线提取</h3><p>为了方便后续计算直线的斜率，我们使用统计概率霍夫直线变换（因为它能直接得到直线的起点和终点坐标）。霍夫变换的参数比较多，可以放在代码开头，便于修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 霍夫变换参数</span></span><br><span class="line">rho = <span class="number">1</span></span><br><span class="line">theta = np.pi / <span class="number">180</span></span><br><span class="line">threshold = <span class="number">15</span></span><br><span class="line">min_line_len = <span class="number">40</span></span><br><span class="line">max_line_gap = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_an_image</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 1. 灰度化、滤波和Canny</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 标记四个坐标点用于ROI截取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 霍夫直线提取</span></span><br><span class="line">    drawing, lines = hough_lines(roi_edges, rho, theta, threshold, min_line_len, max_line_gap)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hough_lines</span><span class="params">(img, rho, theta, threshold, min_line_len, max_line_gap)</span>:</span></span><br><span class="line">    <span class="comment"># 统计概率霍夫直线变换</span></span><br><span class="line">    lines = cv2.HoughLinesP(img, rho, theta, threshold, minLineLength=min_line_len, maxLineGap=max_line_gap)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 新建一副空白画布</span></span><br><span class="line">    drawing = np.zeros((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>], <span class="number">3</span>), dtype=np.uint8)</span><br><span class="line">    <span class="comment"># draw_lines(drawing, lines)     # 画出直线检测结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> drawing, lines</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_lines</span><span class="params">(img, lines, color=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>], thickness=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            cv2.line(img, (x1, y1), (x2, y2), color, thickness)</span><br></pre></td></tr></table></figure><p><code>draw_lines()</code>是用来画直线检测的结果，后面我们会接着处理直线，所以这里注释掉了，可以取消注释看下效果：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_hough_lines_direct_result.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_hough_lines_direct_result.jpg" alt="霍夫变换结果图"></picture></p><p>对本例的这张测试图来说，如果打印出直线的条数<code>print(len(lines))</code>，应该是有16条。</p><h3 id="车道计算"><a href="#车道计算" class="headerlink" title="车道计算"></a>车道计算</h3><p>这部分应该算是本次挑战任务的核心内容了：前面通过霍夫变换得到了多条直线的起点和终点，我们的目的是通过某种算法只得到左右两条车道线。</p><p><strong>第一步、根据斜率正负划分某条线是左车道还是右车道。</strong><br>$$<br>斜率=\frac{y_2-y_1}{x_2-x_1}(\leq0:左,&gt;0:右)<br>$$</p><blockquote><p>经验之谈：再次强调，斜率计算是在图像坐标系下，所以斜率正负/左右跟平面坐标有区别。</p></blockquote><p><strong>第二步、迭代计算各直线斜率与斜率均值的差，排除掉差值过大的异常数据。</strong></p><p>注意这里迭代的含义，意思是第一次计算完斜率均值并排除掉异常值后，再在剩余的斜率中取均值，继续排除……这样迭代下去。</p><p><strong>第三步、最小二乘法拟合左右车道线。</strong></p><p>经过第二步的筛选，就只剩下可能的左右车道线了，这样只需从多条直线中拟合出一条就行。拟合方法有很多种，最常用的便是最小二乘法，它通过最小化误差的平方和来寻找数据的最佳匹配函数。</p><p>具体来说，假设目前可能的左车道线有6条，也就是12个坐标点，包括12个x和12个y，我们的目的是拟合出这样一条直线：<br>$$<br>f(x_i) = ax_i+b<br>$$<br>使得误差平方和最小：<br>$$<br>E=\sum(f(x_i)-y_i)^2<br>$$</p><p>Python中可以直接使用<code>np.polyfit()</code>进行最小二乘法拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_an_image</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 1. 灰度化、滤波和Canny</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 标记四个坐标点用于ROI截取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 霍夫直线提取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 车道拟合计算</span></span><br><span class="line">    draw_lanes(drawing, lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 最终将结果合在原图上</span></span><br><span class="line">    result = cv2.addWeighted(img, <span class="number">0.9</span>, drawing, <span class="number">0.2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_lanes</span><span class="params">(img, lines, color=[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], thickness=<span class="number">8</span>)</span>:</span></span><br><span class="line">    <span class="comment"># a. 划分左右车道</span></span><br><span class="line">    left_lines, right_lines = [], []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            k = (y2 - y1) / (x2 - x1)</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                left_lines.append(line)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_lines.append(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len(left_lines) &lt;= <span class="number">0</span> <span class="keyword">or</span> len(right_lines) &lt;= <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># b. 清理异常数据</span></span><br><span class="line">    clean_lines(left_lines, <span class="number">0.1</span>)</span><br><span class="line">    clean_lines(right_lines, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># c. 得到左右车道线点的集合，拟合直线</span></span><br><span class="line">    left_points = [(x1, y1) <span class="keyword">for</span> line <span class="keyword">in</span> left_lines <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line]</span><br><span class="line">    left_points = left_points + [(x2, y2) <span class="keyword">for</span> line <span class="keyword">in</span> left_lines <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line]</span><br><span class="line">    right_points = [(x1, y1) <span class="keyword">for</span> line <span class="keyword">in</span> right_lines <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line]</span><br><span class="line">    right_points = right_points + [(x2, y2) <span class="keyword">for</span> line <span class="keyword">in</span> right_lines <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line]</span><br><span class="line"></span><br><span class="line">    left_results = least_squares_fit(left_points, <span class="number">325</span>, img.shape[<span class="number">0</span>])</span><br><span class="line">    right_results = least_squares_fit(right_points, <span class="number">325</span>, img.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意这里点的顺序</span></span><br><span class="line">    vtxs = np.array([[left_results[<span class="number">1</span>], left_results[<span class="number">0</span>], right_results[<span class="number">0</span>], right_results[<span class="number">1</span>]]])</span><br><span class="line">    <span class="comment"># d. 填充车道区域</span></span><br><span class="line">    cv2.fillPoly(img, vtxs, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 或者只画车道线</span></span><br><span class="line">    <span class="comment"># cv2.line(img, left_results[0], left_results[1], (0, 255, 0), thickness)</span></span><br><span class="line">    <span class="comment"># cv2.line(img, right_results[0], right_results[1], (0, 255, 0), thickness)</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_lines</span><span class="params">(lines, threshold)</span>:</span></span><br><span class="line">    <span class="comment"># 迭代计算斜率均值，排除掉与差值差异较大的数据</span></span><br><span class="line">    slope = [(y2 - y1) / (x2 - x1) <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line]</span><br><span class="line">    <span class="keyword">while</span> len(lines) &gt; <span class="number">0</span>:</span><br><span class="line">        mean = np.mean(slope)</span><br><span class="line">        diff = [abs(s - mean) <span class="keyword">for</span> s <span class="keyword">in</span> slope]</span><br><span class="line">        idx = np.argmax(diff)</span><br><span class="line">        <span class="keyword">if</span> diff[idx] &gt; threshold:</span><br><span class="line">            slope.pop(idx)</span><br><span class="line">            lines.pop(idx)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">least_squares_fit</span><span class="params">(point_list, ymin, ymax)</span>:</span></span><br><span class="line">    <span class="comment"># 最小二乘法拟合</span></span><br><span class="line">    x = [p[<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line">    y = [p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> point_list]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># polyfit第三个参数为拟合多项式的阶数，所以1代表线性</span></span><br><span class="line">    fit = np.polyfit(y, x, <span class="number">1</span>)</span><br><span class="line">    fit_fn = np.poly1d(fit)  <span class="comment"># 获取拟合的结果</span></span><br><span class="line"></span><br><span class="line">    xmin = int(fit_fn(ymin))</span><br><span class="line">    xmax = int(fit_fn(ymax))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [(xmin, ymin), (xmax, ymax)]</span><br></pre></td></tr></table></figure><p>这段代码比较多，请每个步骤单独来看。最后得到的是左右两条车道线的起点和终点坐标，可以选择画出车道线，这里我直接填充了整个区域：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lane_detection_result_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lane_detection_result_sample.jpg" alt=""></picture></p><h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p>搞定了一张图，视频也就没什么问题了，关键就是视频帧的提取和合成，为此，我们要用到Python的视频编辑包<a href="https://pypi.org/project/moviepy/#files" target="_blank" rel="noopener">moviepy</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install moviepy</span><br></pre></td></tr></table></figure><p>另外还需要ffmpeg，首次运行moviepy时会自动下载，也可<a href="https://github.com/imageio/imageio-binaries/tree/master/ffmpeg" target="_blank" rel="noopener">手动</a>下载。</p><p>只需在开头导入moviepy，然后将主函数改掉就可以了，其余代码不需要更改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开头导入moviepy</span></span><br><span class="line"><span class="keyword">from</span> moviepy.editor <span class="keyword">import</span> VideoFileClip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数更改为：</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    output = <span class="string">'test_videos/output.mp4'</span></span><br><span class="line">    clip = VideoFileClip(<span class="string">"test_videos/cv2_white_lane.mp4"</span>)</span><br><span class="line">    out_clip = clip.fl_image(process_an_image)</span><br><span class="line">    out_clip.write_videofile(output, audio=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>本文实现了车道检测的基础版本，如果你感兴趣的话，可以自行搜索或参考引用部分了解更多。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://blog.codec.wang/cv2_lane_detection_material.zip" target="_blank" rel="noopener">图片和视频素材</a></li><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A13%EF%BC%9A%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://zhuanlan.zhihu.com/p/25354571" target="_blank" rel="noopener">从零开始学习无人驾驶技术 — 车道检测</a></li><li><a href="https://blog.csdn.net/u010665216/article/details/80152458" target="_blank" rel="noopener">无人驾驶之高级车道线检测</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;挑战任务：实际公路的车道线检测。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="车道检测" scheme="http://www.codec.wang/tags/%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程17：霍夫变换</title>
    <link href="http://www.codec.wang/opencv-python-hough-transform/"/>
    <id>http://www.codec.wang/opencv-python-hough-transform/</id>
    <published>2017-12-28T03:35:11.000Z</published>
    <updated>2020-04-07T04:55:46.735Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用霍夫变换识别出图像中的直线和圆。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>理解霍夫变换的实现</li><li>分别使用霍夫线变换和圆变换检测图像中的直线和圆</li><li>OpenCV函数：<code>cv2.HoughLines()</code>, <code>cv2.HoughLinesP()</code>, <code>cv2.HoughCircles()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="理解霍夫变换"><a href="#理解霍夫变换" class="headerlink" title="理解霍夫变换"></a>理解霍夫变换</h3><p>霍夫变换常用来在图像中提取直线和圆等几何形状，我来做个简易的解释：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_hough_transform.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_hough_transform.jpg" alt=""></picture></p><p>学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_line_expression_in_coordinate.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_line_expression_in_coordinate.jpg" alt=""></picture></p><p>那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示：</p><p>$$<br>r_\theta=x_0\cdot\cos \theta+y_0\cdot\sin \theta<br>$$</p><p>也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点：</p><p>  <picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_curve_of_r_theta.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_curve_of_r_theta.jpg" alt=""></picture> </p><p>OpenCV中首先计算(r,θ) 累加数，累加数超过一定值后就认为在同一直线上。</p><h3 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h3><p>OpenCV中用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.加载图片，转为二值图</span></span><br><span class="line">img = cv2.imread(<span class="string">'shapes.jpg'</span>)</span><br><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv2.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.霍夫直线变换</span></span><br><span class="line">lines = cv2.HoughLines(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>)</span><br></pre></td></tr></table></figure><p>函数中：</p><ul><li>参数1：要检测的二值图（一般是阈值分割或边缘检测后的图）</li><li>参数2：距离r的精度，值越大，考虑越多的线</li><li>参数3：角度θ的精度，值越小，考虑越多的线</li><li>参数4：累加数阈值，值越小，考虑越多的线</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来（注意是极坐标噢）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho, theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a * rho</span><br><span class="line">    y0 = b * rho</span><br><span class="line">    x1 = int(x0 + <span class="number">1000</span> * (-b))</span><br><span class="line">    y1 = int(y0 + <span class="number">1000</span> * (a))</span><br><span class="line">    x2 = int(x0 - <span class="number">1000</span> * (-b))</span><br><span class="line">    y2 = int(y0 - <span class="number">1000</span> * (a))</span><br><span class="line"></span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_hough_line_function.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_hough_line_function.jpg" alt=""></picture></p><h3 id="统计概率霍夫直线变换"><a href="#统计概率霍夫直线变换" class="headerlink" title="统计概率霍夫直线变换"></a>统计概率霍夫直线变换</h3><p>前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r和θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 3.统计概率霍夫线变换</span></span><br><span class="line">lines = cv2.HoughLinesP(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">90</span>,</span><br><span class="line">                        minLineLength=<span class="number">50</span>, maxLineGap=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>前面几个参数跟之前的一样，有两个可选参数：</p><ul><li><code>minLineLength</code>：最短长度阈值，比这个长度短的线会被排除</li><li><code>maxLineGap</code>：同一直线两点之间的最大距离</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.将检测的线画出来</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1, y1, x2, y2 = line[<span class="number">0</span>]</span><br><span class="line">    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure><p><code>cv2.LINE_AA</code>在之前绘图功能中讲解过，表示抗锯齿线型。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_hough_lines_p_function.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_hough_lines_p_function.jpg" alt=""></picture></p><h3 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h3><p>霍夫圆变换跟直线变换类似，只不过线是用(r,θ)表示，圆是用(x_center,y_center,r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：<a href="https://en.wikipedia.org/wiki/Circle_Hough_Transform" target="_blank" rel="noopener">Circle Hough Transform</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drawing = np.zeros(img.shape[:], dtype=np.uint8)</span><br><span class="line"><span class="comment"># 2.霍夫圆变换</span></span><br><span class="line">circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">20</span>, param2=<span class="number">30</span>)</span><br><span class="line">circles = np.int0(np.around(circles))</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>参数2：变换方法，一般使用霍夫梯度法，详情：<a href="https://docs.opencv.org/3.3.1/d7/dbd/group__imgproc.html#ga073687a5b96ac7a3ab5802eb5510fe65" target="_blank" rel="noopener">HoughModes</a></li><li>参数3 dp=1：表示霍夫梯度法中累加器图像的分辨率与原图一致</li><li>参数4：两个不同圆圆心的最短距离</li><li>参数5：param2跟霍夫直线变换中的累加数阈值一样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将检测的圆画出来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</span><br><span class="line">    cv2.circle(drawing, (i[<span class="number">0</span>], i[<span class="number">1</span>]), i[<span class="number">2</span>], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)  <span class="comment"># 画出外圆</span></span><br><span class="line">    cv2.circle(drawing, (i[<span class="number">0</span>], i[<span class="number">1</span>]), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>)  <span class="comment"># 画出圆心</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_hough_circles_function.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_hough_circles_function.jpg" alt=""></picture></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>霍夫变换用来提取图像中的直线和圆等几何形状。</li><li>霍夫直线变换：<code>cv2.HoughLines()</code>（整条直线）, <code>cv2.HoughLinesP()</code>。</li><li>霍夫圆变换：<code>cv2.HoughCircles()</code>。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/17.%20%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html" target="_blank" rel="noopener">Hough Line Transform</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghcircles/py_houghcircles.html" target="_blank" rel="noopener">Hough Circle Transform</a></li><li><a href="https://en.wikipedia.org/wiki/Hough_transform" target="_blank" rel="noopener">Hough transform</a></li><li><a href="https://blog.csdn.net/YuYunTan/article/details/80141392" target="_blank" rel="noopener">经典霍夫变换（Hough Transform）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用霍夫变换识别出图像中的直线和圆。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="霍夫变换" scheme="http://www.codec.wang/tags/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程16：模板匹配</title>
    <link href="http://www.codec.wang/opencv-python-template-matching/"/>
    <id>http://www.codec.wang/opencv-python-template-matching/</id>
    <published>2017-12-27T08:45:31.000Z</published>
    <updated>2020-04-07T04:56:15.137Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用模板匹配在图像中寻找物体。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>使用模板匹配在图像中寻找物体</li><li>OpenCV函数：<code>cv2.matchTemplate()</code>, <code>cv2.minMaxLoc()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p><a href="https://baike.baidu.com/item/模板匹配" target="_blank" rel="noopener">模板匹配</a>就是用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_template_matching.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_template_matching.jpg" alt=""></picture></p><p>用<code>cv2.matchTemplate()</code>实现模板匹配。首先我们来读入图片和模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">'face.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]  <span class="comment"># rows-&gt;h, cols-&gt;w</span></span><br></pre></td></tr></table></figure><p>匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。使用<code>cv2.minMaxLoc()</code>函数可以得到最大匹配值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span></span><br><span class="line">res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line"></span><br><span class="line">left_top = max_loc  <span class="comment"># 左上角</span></span><br><span class="line">right_bottom = (left_top[<span class="number">0</span>] + w, left_top[<span class="number">1</span>] + h)  <span class="comment"># 右下角</span></span><br><span class="line">cv2.rectangle(img, left_top, right_bottom, <span class="number">255</span>, <span class="number">2</span>)  <span class="comment"># 画出矩形位置</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_ccoeff_matching_template.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_ccoeff_matching_template.jpg" alt=""></picture></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>这部分可看可不看，不太理解也没关系，还记得前面的方法吗？不懂得就划掉(✿◕‿◕✿)</p></blockquote><p>模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有6种不同的比较方法，详情可参考：<a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="noopener">TemplateMatchModes</a></p><ul><li>平方差匹配CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为0</li><li>归一化平方差匹配CV_TM_SQDIFF_NORMED</li><li>相关匹配CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好</li><li>归一化相关匹配CV_TM_CCORR_NORMED</li><li>相关系数匹配CV_TM_CCOEFF：用两者的相关系数匹配，1表示完美的匹配，-1表示最差的匹配</li><li>归一化相关系数匹配CV_TM_CCOEFF_NORMED</li></ul><p>归一化的意思就是将值统一到0~1，这些方法的对比代码可到<a href="#引用">源码处</a>查看。模板匹配也是应用卷积来实现的：假设原图大小为W×H，模板图大小为w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。</p><h3 id="匹配多个物体"><a href="#匹配多个物体" class="headerlink" title="匹配多个物体"></a>匹配多个物体</h3><p>前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.读入原图和模板</span></span><br><span class="line">img_rgb = cv2.imread(<span class="string">'mario.jpg'</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)</span><br><span class="line">template = cv2.imread(<span class="string">'mario_coin.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.标准相关模板匹配</span></span><br><span class="line">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold = <span class="number">0.8</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.这边是Python/Numpy的知识，后面解释</span></span><br><span class="line">loc = np.where(res &gt;= threshold)  <span class="comment"># 匹配程度大于%80的坐标y,x</span></span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> zip(*loc[::<span class="number">-1</span>]):  <span class="comment"># *号表示可选参数</span></span><br><span class="line">    right_bottom = (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h)</span><br><span class="line">    cv2.rectangle(img_rgb, pt, right_bottom, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_template_matching_multi.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_template_matching_multi.jpg" alt=""></picture></p><p>第3步有几个Python/Numpy的重要知识，来大致看下：</p><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" target="_blank" rel="noopener">np.where()</a>在这里返回res中值大于0.8的所有坐标，如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">print(np.where(x &gt; <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果(先y坐标，再x坐标)：(array([2, 2, 2]), array([0, 1, 2]))</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_np_where_function.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_np_where_function.jpg" alt=""></picture></p><ul><li><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="noopener">zip()</a>函数，功能强大到难以解释，举个简单例子就知道了：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(list(zip(x, y)))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br></pre></td></tr></table></figure><p>这样大家就能理解前面代码的用法了吧：因为loc是先y坐标再x坐标，所以用loc[::-1]翻转一下，然后再用zip函数拼接在一起。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>之前我们有学过形状匹配，不论形状旋转/缩放都可以匹配到。思考一下，图片旋转或缩放的话模板匹配还有作用吗？</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>模板匹配用来在大图中找小图。</li><li><code>cv2.matchTemplate()</code>用来进行模板匹配。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/16.%20%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html" target="_blank" rel="noopener">Template Matching</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/template_matching/template_matching.html#template-matching" target="_blank" rel="noopener">模板匹配</a></li><li><a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="noopener">TemplateMatchModes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用模板匹配在图像中寻找物体。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="模板匹配" scheme="http://www.codec.wang/tags/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程15：直方图</title>
    <link href="http://www.codec.wang/opencv-python-histograms/"/>
    <id>http://www.codec.wang/opencv-python-histograms/</id>
    <published>2017-12-23T09:48:30.000Z</published>
    <updated>2020-04-07T04:56:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>学习计算并绘制直方图，直方图均衡化等。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>计算并绘制直方图</li><li>（自适应）直方图均衡化</li><li>OpenCV函数：<code>cv2.calcHist()</code>, <code>cv2.equalizeHist()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="啥叫直方图"><a href="#啥叫直方图" class="headerlink" title="啥叫直方图"></a>啥叫直方图</h3><p>直方图简单来说就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为0的有多少个，1的有多少个……直方图是一种分析图片的手段：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_histogram.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_histogram.jpg" alt=""></picture></p><p>在计算直方图之前，有几个术语先来了解一下：</p><ul><li>dims：要计算的通道数，对于灰度图dims=1，普通彩色图dims=3</li><li>range：要计算的像素值范围，一般为[0,256)</li><li>bins：子区段数目，如果我们统计0<del>255每个像素值，bins=256；如果划分区间，比如0</del>15, 16<del>31…240</del>255这样16个区间，bins=16</li></ul><h3 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h3><p>OpenCV和Numpy中都提供了计算直方图的函数，我们对比下它们的性能。</p><h4 id="OpenCV中直方图计算"><a href="#OpenCV中直方图计算" class="headerlink" title="OpenCV中直方图计算"></a>OpenCV中直方图计算</h4><p>使用<code>cv2.calcHist(images, channels, mask, histSize, ranges)</code>计算，其中：</p><ul><li>参数1：要计算的原图，以方括号的传入，如：[img]</li><li>参数2：类似前面提到的dims，灰度图写[0]就行，彩色图B/G/R分别传入[0]/[1]/[2]</li><li>参数3：要计算的区域，计算整幅图的话，写None</li><li>参数4：前面提到的bins</li><li>参数5：前面提到的range</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'hist.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.025288 s</span></span><br></pre></td></tr></table></figure><h4 id="Numpy中直方图计算"><a href="#Numpy中直方图计算" class="headerlink" title="Numpy中直方图计算"></a>Numpy中直方图计算</h4><p>也可用Numpy的函数计算，其中<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">ravel()</a>函数将二维矩阵展平变成一维数组，之前有提到过：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist, bins = np.histogram(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])  <span class="comment"># 性能：0.020628 s</span></span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：Numpy中还有一种更高效的方式：（还记得怎么评估性能吗：<a href="/opencv-python-extra-code-optimization/">番外篇：代码性能优化</a>）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist = np.bincount(img.ravel(), minlength=<span class="number">256</span>)  <span class="comment"># 性能：0.003163 s</span></span><br></pre></td></tr></table></figure><p>计算出直方图之后，怎么把它画出来呢？</p><h3 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h3><p>其实Matplotlib自带了一个计算并绘制直方图的功能，不需要用到上面的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>当然，也可以用前面计算出来的结果绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(hist)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_calc_draw_histogram.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_calc_draw_histogram.jpg" alt=""></picture></p><p>从直方图上可以看到图片的大部分区域集中在150偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。</p><blockquote><p>使用OpenCV的画线功能也可以画直方图，不过太麻烦了，有兴趣的可以看下官方示例：<a href="https://github.com/opencv/opencv/blob/master/samples/python/hist.py" target="_blank" rel="noopener">hist.py</a>。</p></blockquote><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96" target="_blank" rel="noopener">维基百科：直方图均衡化</a></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_histogram_equalization.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_histogram_equalization.jpg" alt=""></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br></pre></td></tr></table></figure><p>OpenCV中用<code>cv2.equalizeHist()</code>实现均衡化。我们把两张图片并排显示，对比一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'equalization'</span>, np.hstack((img, equ)))  <span class="comment"># 并排显示</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_before_after_equalization.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_before_after_equalization.jpg" alt=""></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_before_after_equalization_histogram.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_before_after_equalization_histogram.jpg" alt="均衡化前后的直方图对比"></picture></p><p>可以看到均衡化后图片的亮度和对比度效果明显好于原图。</p><h3 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h3><p>不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_adaptive_histogram.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_adaptive_histogram.jpg" alt=""></picture></p><p>很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。</p><p>自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认8×8）进行直方图均衡化。当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：<strong>对比度受限的自适应直方图均衡化</strong>CLAHE(<a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="noopener">Contrast Limited Adaptive Histogram Equalization</a>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自适应均衡化，参数可选</span></span><br><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">cl1 = clahe.apply(img)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_adaptive_histogram.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_adaptive_histogram.jpg" alt=""></picture></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><code>cv2.calcHist()</code>函数中的参数3是指要计算的区域(mask：目标区域白色，其余黑色)，编写一个只计算图片左上角200×200区域直方图的程序。</li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_histogram_mask.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_histogram_mask.jpg" alt=""></picture></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>直方图是一种分析图像的手段。</li><li><code>cv2.calcHist()</code>和<code>numpy.bincount()</code>均可用来计算直方图，使用Matplotlib绘制直方图。</li><li>均衡化用来使图像的直方图分布更加均匀，提升亮度和对比度。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/15.%20%E7%9B%B4%E6%96%B9%E5%9B%BE" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histograms-getting-started" target="_blank" rel="noopener">Histograms - 1 : Find, Plot, Analyze !!!</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization" target="_blank" rel="noopener">Histograms - 2: Histogram Equalization</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96" target="_blank" rel="noopener">维基百科：直方图均衡化</a></li><li><a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="noopener">维基百科：自适应直方图均衡化</a></li><li><a href="http://www.cambridgeincolour.com/tutorials/histograms1.htm" target="_blank" rel="noopener">Cambridge in Color website</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习计算并绘制直方图，直方图均衡化等。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="直方图" scheme="http://www.codec.wang/tags/%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程14：轮廓特征</title>
    <link href="http://www.codec.wang/opencv-python-contour-features/"/>
    <id>http://www.codec.wang/opencv-python-contour-features/</id>
    <published>2017-12-20T10:46:19.000Z</published>
    <updated>2020-04-07T04:57:04.954Z</updated>
    
    <content type="html"><![CDATA[<p>学习计算轮廓特征，如面积、周长、最小外接矩形等。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>计算物体的周长、面积、质心、最小外接矩形等</li><li>OpenCV函数：<code>cv2.contourArea()</code>, <code>cv2.arcLength()</code>, <code>cv2.approxPolyDP()</code> 等</li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>在计算轮廓特征之前，我们先用上一节的代码把轮廓找到：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_31_handwriting_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_31_handwriting_sample.jpg" alt=""></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'handwriting.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以数字3的轮廓为例</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</span><br><span class="line">img_color2 = np.copy(img_color1)</span><br><span class="line">cv2.drawContours(img_color1, [cnt], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)  <span class="comment"># 4386.5</span></span><br></pre></td></tr></table></figure><p>注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p><blockquote><p>如果统计二值图中像素点个数，应尽量避免循环，<strong>可以使用<code>cv2.countNonZero()</code></strong>，更加高效。</p></blockquote><h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt, <span class="literal">True</span>)  <span class="comment"># 585.7</span></span><br></pre></td></tr></table></figure><p>参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p><h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><p>矩可以理解为图像的各类几何特征，详情请参考：[<a href="http://en.wikipedia.org/wiki/Image_moment" target="_blank" rel="noopener">Image Moments</a>]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M = cv2.moments(cnt)</span><br></pre></td></tr></table></figure><p>M中包含了很多轮廓的特征信息，比如M[‘m00’]表示轮廓面积，与前面<code>cv2.contourArea()</code>计算结果是一样的。质心也可以用它来算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx, cy = M[<span class="string">'m10'</span>] / M[<span class="string">'m00'</span>], M[<span class="string">'m01'</span>] / M[<span class="string">'m00'</span>]  <span class="comment"># (205, 281)</span></span><br></pre></td></tr></table></figure><h3 id="外接矩形"><a href="#外接矩形" class="headerlink" title="外接矩形"></a>外接矩形</h3><p>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_min_rect_rect_bounding.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_min_rect_rect_bounding.jpg" alt=""></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)  <span class="comment"># 外接矩形</span></span><br><span class="line">cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rect = cv2.minAreaRect(cnt)  <span class="comment"># 最小外接矩形</span></span><br><span class="line">box = np.int0(cv2.boxPoints(rect))  <span class="comment"># 矩形的四个角点取整</span></span><br><span class="line">cv2.drawContours(img_color1, [box], <span class="number">0</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其中np.int0(x)是把x取整的操作，比如377.93就会变成377，也可以用x.astype(np.int)。</p><h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>外接圆跟外接矩形一样，找到一个能包围物体的最小圆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">(x, y, radius) = np.int0((x, y, radius))  <span class="comment"># 圆心和半径取整</span></span><br><span class="line">cv2.circle(img_color2, (x, y), radius, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_min_enclosing_circle.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_min_enclosing_circle.jpg" alt=""></picture></p><h3 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h3><p>我们可以用得到的轮廓拟合出一个椭圆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span><br><span class="line">cv2.ellipse(img_color2, ellipse, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_fitting_ellipse.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_fitting_ellipse.jpg" alt=""></picture></p><h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回<strong>值越小，越相似</strong>。先读入下面这张图片：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_match_shape_shapes.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_match_shape_shapes.jpg" alt=""></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'shapes.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  <span class="comment"># 用于绘制的彩色图</span></span><br></pre></td></tr></table></figure><p>图中有3条轮廓，我们用A/B/C表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnt_a, cnt_b, cnt_c = contours[<span class="number">0</span>], contours[<span class="number">1</span>], contours[<span class="number">2</span>]</span><br><span class="line">print(cv2.matchShapes(cnt_b, cnt_b, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.0</span></span><br><span class="line">print(cv2.matchShapes(cnt_b, cnt_c, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 2.17e-05</span></span><br><span class="line">print(cv2.matchShapes(cnt_b, cnt_a, <span class="number">1</span>, <span class="number">0.0</span>))  <span class="comment"># 0.418</span></span><br></pre></td></tr></table></figure><p>可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，详情可参考：<a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f" target="_blank" rel="noopener">ShapeMatchModes</a>，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p><p>形状匹配是通过图像的Hu矩来实现的(<code>cv2.HuMoments()</code>)，大家如果感兴趣，可以参考：<a href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments" target="_blank" rel="noopener">Hu-Moments</a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>前面我们是对图片中的数字3进行轮廓特征计算的，大家换成数字1看看。</li><li>（选做）用形状匹配比较两个字母或数字（这相当于很简单的一个<a href="https://baike.baidu.com/item/%E5%85%89%E5%AD%A6%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/4162921?fr=aladdin&fromid=25995&fromtitle=OCR" target="_blank" rel="noopener">OCR</a>噢）。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>常用的轮廓特征：</p><ul><li><code>cv2.contourArea()</code>算面积，<code>cv2.arcLength()</code>算周长，<code>cv2.boundingRect()</code>算外接矩。</li><li><code>cv2.minAreaRect()</code>算最小外接矩，<code>cv2.minEnclosingCircle()</code>算最小外接圆。</li><li><code>cv2.matchShapes()</code>进行形状匹配。</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga2c759ed9f497d4a618048a2f56dc97f1" target="_blank" rel="noopener">cv2.contourArea()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga8d26483c636be6b35c3ec6335798a47c" target="_blank" rel="noopener">cv2.arcLength()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga556a180f43cab22649c23ada36a8a139" target="_blank" rel="noopener">cv2.moments()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga103fcbda2f540f3ef1c042d6a9b35ac7" target="_blank" rel="noopener">cv2.boundingRect()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga3d476a3417130ae5154aea421ca7ead9" target="_blank" rel="noopener">cv2.minAreaRect()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga8ce13c24081bbc7151e9326f412190f1" target="_blank" rel="noopener">cv2.minEnclosingCircle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf259efaad93098103d6c27b9e4900ffa" target="_blank" rel="noopener">cv2.fitEllipse()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaadc90cb16e2362c9bd6e7363e6e4c317" target="_blank" rel="noopener">cv2.matchShapes()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f" target="_blank" rel="noopener">cv2.ShapeMatchModes</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/14.%20%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html" target="_blank" rel="noopener">Contour Features</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html" target="_blank" rel="noopener">Contours : More Functions</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习计算轮廓特征，如面积、周长、最小外接矩形等。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="轮廓" scheme="http://www.codec.wang/tags/%E8%BD%AE%E5%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇11：凸包及更多轮廓特征</title>
    <link href="http://www.codec.wang/opencv-python-extra-convex-hull/"/>
    <id>http://www.codec.wang/opencv-python-extra-convex-hull/</id>
    <published>2017-12-20T05:41:11.000Z</published>
    <updated>2020-04-07T04:52:02.253Z</updated>
    
    <content type="html"><![CDATA[<p>计算凸包及更多轮廓特征。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="多边形逼近"><a href="#多边形逼近" class="headerlink" title="多边形逼近"></a>多边形逼近</h2><p>前面我们学习过最小外接矩和最小外接圆，那么可以用一个最小的多边形包围物体吗？当然可以：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.先找到轮廓</span></span><br><span class="line">img = cv2.imread(<span class="string">'unregular.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进行多边形逼近，得到多边形的角点</span></span><br><span class="line">approx = cv2.approxPolyDP(cnt, <span class="number">3</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.画出多边形</span></span><br><span class="line">image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</span><br><span class="line">cv2.polylines(image, [approx], <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其中<code>cv2.approxPolyDP()</code>的参数2(epsilon)是一个距离值，表示多边形的轮廓接近实际轮廓的程度，值越小，越精确；参数3表示是否闭合。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_approxpoly.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_approxpoly.jpg" alt=""></picture></p><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p><a href="https://baike.baidu.com/item/%E5%87%B8%E5%8C%85/179150?fr=aladdin" target="_blank" rel="noopener">凸包</a>跟多边形逼近很像，只不过它是物体最外层的”凸”多边形：集合A内连接任意两个点的直线都在A的内部，则称集合A是凸形的。如下图，红色的部分为手掌的凸包，双箭头部分表示凸缺陷(Convexity Defects)，凸缺陷常用来进行手势识别等：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_convex.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_convex.jpg" alt=""></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.先找到轮廓</span></span><br><span class="line">img = cv2.imread(<span class="string">'convex.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.寻找凸包，得到凸包的角点</span></span><br><span class="line">hull = cv2.convexHull(cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.绘制凸包</span></span><br><span class="line">image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)</span><br><span class="line">cv2.polylines(image, [hull], <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_convex_hull.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_convex_hull.jpg" alt=""></picture></p><p>其中函数<code>cv2.convexHull()</code>有个可选参数returnPoints，默认是True，代表返回角点的x/y坐标；如果为False的话，表示返回轮廓中是凸包角点的索引，比如说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(hull[<span class="number">0</span>])  <span class="comment"># [[362 184]]（坐标）</span></span><br><span class="line">hull2 = cv2.convexHull(cnt, returnPoints=<span class="literal">False</span>)</span><br><span class="line">print(hull2[<span class="number">0</span>])  <span class="comment"># [510]（cnt中的索引）</span></span><br><span class="line">print(cnt[<span class="number">510</span>])  <span class="comment"># [[362 184]]</span></span><br></pre></td></tr></table></figure><p>当使用<code>cv2.convexityDefects()</code>计算凸包缺陷时，returnPoints需为False，详情可参考：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="noopener">Convexity Defects</a></p><p>另外可以用下面的语句来判断轮廓是否是凸形的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(cv2.isContourConvex(hull))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="点到轮廓距离"><a href="#点到轮廓距离" class="headerlink" title="点到轮廓距离"></a>点到轮廓距离</h2><p><code>cv2.pointPolygonTest()</code>函数计算点到轮廓的最短距离（也就是垂线），又称多边形测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist = cv2.pointPolygonTest(cnt, (<span class="number">100</span>, <span class="number">100</span>), <span class="literal">True</span>)  <span class="comment"># -3.53</span></span><br></pre></td></tr></table></figure><p>其中参数3为True时表示计算距离值：点在轮廓外面值为负，点在轮廓上值为0，点在轮廓里面值为正；参数3为False时，只返回-1/0/1表示点相对轮廓的位置，不计算距离。</p><p>更多轮廓特征，如当量直径、平均强度等，我目前也没用到过，以后用到再写吧，感兴趣的可以参看：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="noopener">Contour Properties</a>、<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="noopener">Contours Hierarchy</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8711.%20%E5%87%B8%E5%8C%85%E5%8F%8A%E6%9B%B4%E5%A4%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="noopener">Convexity Defects</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="noopener">Contour Properties</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="noopener">Contours Hierarchy</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算凸包及更多轮廓特征。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="凸包" scheme="http://www.codec.wang/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇10：轮廓层级</title>
    <link href="http://www.codec.wang/opencv-python-extra-contours-hierarchy/"/>
    <id>http://www.codec.wang/opencv-python-extra-contours-hierarchy/</id>
    <published>2017-12-20T04:41:11.000Z</published>
    <updated>2020-04-07T04:52:22.603Z</updated>
    
    <content type="html"><![CDATA[<p>了解轮廓间的层级关系。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><p>前面我们使用<code>cv2.findContours()</code>寻找轮廓时，参数3表示轮廓的寻找方式(RetrievalModes)，当时我们传入的是cv2.RETR_TREE，它表示什么意思呢？另外，函数返回值hierarchy有什么用途呢？下面我们就来研究下这两个问题。</p><hr><h2 id="理解轮廓层级"><a href="#理解轮廓层级" class="headerlink" title="理解轮廓层级"></a>理解轮廓层级</h2><p>很多情况下，图像中的形状之间是有关联的，比如说下图：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_hierarchy.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_hierarchy.jpg" alt=""></picture></p><p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p><ul><li>轮廓0/1/2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li><li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li><li>同样3是2a的子轮廓，轮廓3处于一个等级：2级</li><li>类似的，3a是3的子轮廓，等等…………</li></ul><p>这里面OpenCV关注的就是两个概念：同一轮廓等级和轮廓间的子属关系。</p><h2 id="OpenCV中轮廓等级的表示"><a href="#OpenCV中轮廓等级的表示" class="headerlink" title="OpenCV中轮廓等级的表示"></a>OpenCV中轮廓等级的表示</h2><p>如果我们打印出<code>cv2.findContours()</code>函数的返回值hierarchy，会发现它是一个包含4个值的数组：<strong>[Next, Previous, First Child, Parent]</strong></p><ul><li><em>Next：与当前轮廓处于同一层级的下一条轮廓</em></li></ul><p>举例来说，前面图中跟0处于同一层级的下一条轮廓是1，所以Next=1；同理，对轮廓1来说，Next=2；那么对于轮廓2呢？没有与它同一层级的下一条轮廓了，此时Next=-1。</p><ul><li><em>Previous：与当前轮廓处于同一层级的上一条轮廓</em></li></ul><p>跟前面一样，对于轮廓1来说，Previous=0；对于轮廓2，Previous=1；对于轮廓1，没有上一条轮廓了，所以Previous=-1。</p><ul><li><em>First Child：当前轮廓的第一条子轮廓</em></li></ul><p>比如对于轮廓2，第一条子轮廓就是轮廓2a，所以First Child=2a；对轮廓3a，First Child=4。</p><ul><li><em>Parent：当前轮廓的父轮廓</em></li></ul><p>比如2a的父轮廓是2，Parent=2；轮廓2没有父轮廓，所以Parent=-1。</p><p>下面我们通过代码验证一下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.读入图片</span></span><br><span class="line">img = cv2.imread(<span class="string">'hierarchy.jpg'</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">_, thresh = cv2.threshold(img_gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.寻找轮廓</span></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.绘制轮廓</span></span><br><span class="line">print(len(contours),hierarchy)  <span class="comment"># 8条</span></span><br><span class="line">cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：OpenCV中找到的轮廓序号跟前面讲的不同噢，如下图：</p></blockquote><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_hierarchy_RETR_TREE.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_hierarchy_RETR_TREE.jpg" alt=""></picture></p><p>现在既然我们了解了层级的概念，那么类似cv2.RETR_TREE的轮廓寻找方式又是啥意思呢？</p><h2 id="轮廓寻找方式"><a href="#轮廓寻找方式" class="headerlink" title="轮廓寻找方式"></a>轮廓寻找方式</h2><p>OpenCV中有四种轮廓寻找方式<a href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="noopener">RetrievalModes</a>，下面分别来看下：</p><h3 id="1-RETR-LIST"><a href="#1-RETR-LIST" class="headerlink" title="1. RETR_LIST"></a>1. RETR_LIST</h3><p>这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。这样，hierarchy中的后两个值[First Child, Parent]都为-1。比如同样的图，我们使用cv2.RETR_LIST来寻找轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_, _, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, <span class="number">2</span>)</span><br><span class="line">print(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">3</span>  <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">2</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">5</span>  <span class="number">3</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">4</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">5</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [<span class="number">-1</span>  <span class="number">6</span> <span class="number">-1</span> <span class="number">-1</span>]]]</span><br></pre></td></tr></table></figure><p>因为没有从属关系，所以轮廓0的下一条是1，1的下一条是2……</p><blockquote><p>经验之谈：如果你不需要轮廓层级信息的话，cv2.RETR_LIST更推荐使用，因为性能更好。</p></blockquote><h3 id="2-RETR-TREE"><a href="#2-RETR-TREE" class="headerlink" title="2. RETR_TREE"></a>2. RETR_TREE</h3><p>cv2.RETR_TREE就是之前我们一直在使用的方式，它会完整建立轮廓的层级从属关系，前面已经详细说明过了。</p><h3 id="3-RETR-EXTERNAL"><a href="#3-RETR-EXTERNAL" class="headerlink" title="3. RETR_EXTERNAL"></a>3. RETR_EXTERNAL</h3><p>这种方式只寻找最高层级的轮廓，也就是它只会找到前面我们所说的3条0级轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, <span class="number">2</span>)</span><br><span class="line">print(len(contours), hierarchy, sep=<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[[[ <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [<span class="number">-1</span>  <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span>]]]</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_hierarchy_RETR_EXTERNAL.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_hierarchy_RETR_EXTERNAL.jpg" alt=""></picture></p><h3 id="4-RETR-CCOMP"><a href="#4-RETR-CCOMP" class="headerlink" title="4. RETR_CCOMP"></a>4. RETR_CCOMP</h3><p>相比之下cv2.RETR_CCOMP比较难理解，但其实也很简单：它把所有的轮廓只分为2个层级，不是外层的就是里层的。结合代码和图片，我们来理解下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, <span class="number">2</span>)</span><br><span class="line">print(hierarchy)</span><br><span class="line"><span class="comment"># 结果如下</span></span><br><span class="line">[[[ <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">1</span>  <span class="number">3</span> <span class="number">-1</span>]</span><br><span class="line">  [<span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>  <span class="number">2</span>]</span><br><span class="line">  [ <span class="number">6</span>  <span class="number">2</span>  <span class="number">5</span> <span class="number">-1</span>]</span><br><span class="line">  [<span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span>  <span class="number">4</span>]</span><br><span class="line">  [ <span class="number">7</span>  <span class="number">4</span> <span class="number">-1</span> <span class="number">-1</span>]</span><br><span class="line">  [<span class="number">-1</span>  <span class="number">6</span> <span class="number">-1</span> <span class="number">-1</span>]]]</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_hierarchy_RETR_CCOMP.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_hierarchy_RETR_CCOMP.jpg" alt=""></picture></p><blockquote><p>注意：使用这个参数找到的轮廓序号与之前不同。</p></blockquote><p>图中括号里面1代表外层轮廓，2代表里层轮廓。比如说对于轮廓2，Next就是4，Previous是1，它有里层的轮廓3，所以First Child=3，但因为只有两个层级，它本身就是外层轮廓，所以Parent=-1。大家可以针对其他的轮廓自己验证一下。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>如下图，找到3个圆环的内环，然后填充成(180,215,215)这种颜色：</li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_hierarchy_fill_holes.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_hierarchy_fill_holes.jpg" alt=""></picture></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8710.%20%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html#contours-hierarchy" target="_blank" rel="noopener">Contours Hierarchy</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解轮廓间的层级关系。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="轮廓层级" scheme="http://www.codec.wang/tags/%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程13：轮廓</title>
    <link href="http://www.codec.wang/opencv-python-contours/"/>
    <id>http://www.codec.wang/opencv-python-contours/</id>
    <published>2017-12-20T01:44:23.000Z</published>
    <updated>2020-04-07T04:57:19.085Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何寻找并绘制轮廓。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>了解轮廓概念</li><li>寻找并绘制轮廓</li><li>OpenCV函数：<code>cv2.findContours()</code>, <code>cv2.drawContours()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="啥叫轮廓"><a href="#啥叫轮廓" class="headerlink" title="啥叫轮廓"></a>啥叫轮廓</h3><p>轮廓是一系列相连的点组成的曲线，代表了物体的基本外形。</p><p>谈起轮廓不免想到边缘，它们确实很像。简单的说，<strong>轮廓是连续的，边缘并不全都连续</strong>（下图）。其实边缘主要是作为图像的特征使用，比如可以用边缘特征可以区分脸和手，而轮廓主要用来分析物体的形态，比如物体的周长和面积等，可以说边缘包括轮廓。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_contours.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_contours.jpg" alt="边缘和轮廓的区别"></picture></p><p>寻找轮廓的操作一般用于二值化图，所以通常会使用阈值分割或Canny边缘检测先得到二值图。</p><blockquote><p>经验之谈：<strong>寻找轮廓是针对白色物体的</strong>，一定要保证物体是白色，而背景是黑色，<strong>不然很多人在寻找轮廓时会找到图片最外面的一个框</strong>。</p></blockquote><h3 id="寻找轮廓"><a href="#寻找轮廓" class="headerlink" title="寻找轮廓"></a>寻找轮廓</h3><p>使用<code>cv2.findContours()</code>寻找轮廓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'handwriting.jpg'</span>)</span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(img_gray, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找二值化图中的轮廓</span></span><br><span class="line">image, contours, hierarchy = cv2.findContours(</span><br><span class="line">    thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">print(len(contours))  <span class="comment"># 结果应该为2</span></span><br></pre></td></tr></table></figure><ul><li>参数2：轮廓的查找方式，一般使用cv2.RETR_TREE，表示提取所有的轮廓并建立轮廓间的层级。更多请参考：<a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="noopener">RetrievalModes</a></li><li>参数3：轮廓的近似方法。比如对于一条直线，我们可以存储该直线的所有像素点，也可以只存储起点和终点。使用cv2.CHAIN_APPROX_SIMPLE就表示用尽可能少的像素点表示轮廓。更多请参考：<a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga4303f45752694956374734a03c54d5ff" target="_blank" rel="noopener">ContourApproximationModes</a></li><li>简便起见，这两个参数也可以直接用真值3和2表示。</li></ul><p>函数有3个返回值，image还是原来的二值化图片，hierarchy是轮廓间的层级关系（<a href="/opencv-python-extra-contours-hierarchy/">番外篇：轮廓层级</a>），这两个暂时不用理会。我们主要看contours，它就是找到的轮廓了，以数组形式存储，记录了每条轮廓的所有像素点的坐标(x,y)。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_find_contours_contours.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_find_contours_contours.jpg" alt=""></picture></p><h3 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h3><p>轮廓找出来后，为了方便观看，可以像前面图中那样用红色画出来：<code>cv2.drawContours()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其中参数2就是得到的contours，参数3表示要绘制哪一条轮廓，-1表示绘制所有轮廓，参数4是颜色（B/G/R通道，所以(0,0,255)表示红色），参数5是线宽，之前在绘制图形中介绍过。</p><blockquote><p>经验之谈：很多人画图时明明用了彩色，但没有效果，请检查你是在哪个图上画，画在灰度图和二值图上显然是没有彩色的(⊙o⊙)。</p></blockquote><p>一般情况下，我们会首先获得要操作的轮廓，再进行轮廓绘制及分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">1</span>]</span><br><span class="line">cv2.drawContours(img, [cnt], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>轮廓特征非常有用，使用<code>cv2.findContours()</code>寻找轮廓，<code>cv2.drawContours()</code>绘制轮廓。</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gadf1ad6a0b82947fa1fe3c3d497f260e0" target="_blank" rel="noopener">cv2.findContours()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="noopener">cv2.RetrievalModes</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga4303f45752694956374734a03c54d5ff" target="_blank" rel="noopener">cv2.ContourApproximationModes</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga746c0625f1781f1ffc9056259103edbc" target="_blank" rel="noopener">cv2.drawContours()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/13.%20%E8%BD%AE%E5%BB%93" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_begin/py_contours_begin.html" target="_blank" rel="noopener">Contours : Getting Started</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何寻找并绘制轮廓。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="轮廓" scheme="http://www.codec.wang/tags/%E8%BD%AE%E5%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程12：腐蚀与膨胀</title>
    <link href="http://www.codec.wang/opencv-python-erode-and-dilate/"/>
    <id>http://www.codec.wang/opencv-python-erode-and-dilate/</id>
    <published>2017-12-19T12:52:23.000Z</published>
    <updated>2020-04-07T04:57:33.752Z</updated>
    
    <content type="html"><![CDATA[<p>学习常用形态学操作：腐蚀膨胀，开运算和闭运算。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>了解形态学操作的概念</li><li>学习膨胀、腐蚀、开运算和闭运算等形态学操作</li><li>OpenCV函数：<code>cv2.erode()</code>, <code>cv2.dilate()</code>, <code>cv2.morphologyEx()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="啥叫形态学操作"><a href="#啥叫形态学操作" class="headerlink" title="啥叫形态学操作"></a>啥叫形态学操作</h3><p>形态学操作其实就是<strong>改变物体的形状</strong>，比如腐蚀就是”变瘦”，膨胀就是”变胖”，看下图就明白了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_morphological.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_morphological.jpg" alt=""></picture></p><blockquote><p>经验之谈：形态学操作一般作用于二值化图，来连接相邻的元素或分离成独立的元素。<strong>腐蚀和膨胀是针对图片中的白色部分！</strong></p></blockquote><h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p>腐蚀的效果是把图片”变瘦”，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有0和255，所以小区域内有一个是0该像素点就为0：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_erosion.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_erosion.jpg" alt=""></picture></p><p>这样原图中边缘地方就会变成0，达到了瘦身目的（小胖福利(●ˇ∀ˇ●)）</p><p>OpenCV中用<code>cv2.erode()</code>函数进行腐蚀，只需要指定核的大小就行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j.bmp'</span>, <span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">erosion = cv2.erode(img, kernel)  <span class="comment"># 腐蚀</span></span><br></pre></td></tr></table></figure><blockquote><p>这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的。结构元素可以是矩形/椭圆/十字形，可以用<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素，比如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 矩形结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 椭圆结构</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 十字形结构</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_morphological_struct_element.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_morphological_struct_element.jpg" alt=""></picture></p><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀与腐蚀相反，取的是局部最大值，效果是把图片”变胖”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dilation = cv2.dilate(img, kernel)  <span class="comment"># 膨胀</span></span><br></pre></td></tr></table></figure><h3 id="开-闭运算"><a href="#开-闭运算" class="headerlink" title="开/闭运算"></a>开/闭运算</h3><p>先腐蚀后膨胀叫开运算（因为先腐蚀会分开物体，这样容易记住），其作用是：分离物体，消除小区域。这类形态学操作用<code>cv2.morphologyEx()</code>函数实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 定义结构元素</span></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'j_noise_out.bmp'</span>, <span class="number">0</span>)</span><br><span class="line">opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  <span class="comment"># 开运算</span></span><br></pre></td></tr></table></figure><p>闭运算则相反：先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除/“闭合”物体里面的小黑洞，所以叫闭运算）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'j_noise_in.bmp'</span>, <span class="number">0</span>)</span><br><span class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  <span class="comment"># 闭运算</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_morphological_opening_closing.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_morphological_opening_closing.jpg" alt=""></picture></p><blockquote><p>经验之谈：很多人对开闭运算的作用不是很清楚（好吧，其实是比较容易混◑﹏◐），但看上图↑，不用怕：如果我们的目标物体外面有很多无关的小区域，就用开运算去除掉；如果物体内部有很多小黑洞，就用闭运算填充掉。</p></blockquote><p>接下来的3种形态学操作并不常用，大家有兴趣可以看看（因为较短，没有做成番外篇）：</p><h3 id="其他形态学操作"><a href="#其他形态学操作" class="headerlink" title="其他形态学操作"></a>其他形态学操作</h3><ul><li>形态学梯度：膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'school.bmp'</span>, <span class="number">0</span>)</span><br><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_morphological_gradient.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_morphological_gradient.jpg" alt=""></picture></p><ul><li>顶帽：原图减去开运算后的图：<code>src - opening</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)</span><br></pre></td></tr></table></figure><ul><li>黑帽：闭运算后的图减去原图：<code>closing - src</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>形态学操作就是改变物体的形状，如腐蚀使物体”变瘦”，膨胀使物体”变胖”。</li><li>先腐蚀后膨胀会分离物体，所以叫开运算，常用来去除小区域物体。</li><li>先膨胀后腐蚀会消除物体内的小洞，所以叫闭运算。开/闭理解了之后很容易记忆噢(⊙o⊙)。</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb" target="_blank" rel="noopener">cv2.erode()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc" target="_blank" rel="noopener">cv2.getStructuringElement()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c" target="_blank" rel="noopener">cv2.dilate()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac2db39b56866583a95a5680313c314ad" target="_blank" rel="noopener">cv2.MorphShapes</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f" target="_blank" rel="noopener">cv2.morphologyEx()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga7be549266bad7b2e6a04db49827f9f32" target="_blank" rel="noopener">cv2.MorphTypes</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/12.%20%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm" target="_blank" rel="noopener">Morphological Operations</a></li><li><a href="http://szeliski.org/Book/" target="_blank" rel="noopener">Computer Vision: Algorithms and Applications</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习常用形态学操作：腐蚀膨胀，开运算和闭运算。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="腐蚀" scheme="http://www.codec.wang/tags/%E8%85%90%E8%9A%80/"/>
    
      <category term="膨胀" scheme="http://www.codec.wang/tags/%E8%86%A8%E8%83%80/"/>
    
      <category term="形态学" scheme="http://www.codec.wang/tags/%E5%BD%A2%E6%80%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程11：边缘检测</title>
    <link href="http://www.codec.wang/opencv-python-edge-detection/"/>
    <id>http://www.codec.wang/opencv-python-edge-detection/</id>
    <published>2017-12-18T09:11:48.000Z</published>
    <updated>2020-04-07T04:57:49.806Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用Canny获取图像的边缘。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><blockquote><p><a href="https://www.computer.org/cms/Computer.org/Transactions%20Home%20Pages/TPAMI/PDFs/top_ten_6.pdf" target="_blank" rel="noopener">Canny J . A Computational Approach To Edge Detection[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698.</a></p></blockquote><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>Canny边缘检测的简单概念</li><li>OpenCV函数：<code>cv2.Canny()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>Canny边缘检测方法常被誉为边缘检测的最优方法，废话不多说，先看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'handwriting.jpg'</span>, <span class="number">0</span>)</span><br><span class="line">edges = cv2.Canny(img, <span class="number">30</span>, <span class="number">70</span>)  <span class="comment"># canny边缘检测</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'canny'</span>, np.hstack((img, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_canny_edge_detection.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_canny_edge_detection.jpg" alt=""></picture></p><p><code>cv2.Canny()</code>进行边缘检测，参数2、3表示最低、高阈值，下面来解释下具体原理。</p><blockquote><p>经验之谈：之前我们用低通滤波的方式模糊了图片，那反过来，想得到物体的边缘，就需要用到高通滤波。推荐先阅读：<a href="/opencv-python-extra-image-gradients/">番外篇：图像梯度</a>。</p></blockquote><h3 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h3><p>Canny边缘提取的具体步骤如下：</p><p>1，使用5×5高斯滤波消除噪声：</p><p>边缘检测本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理。高斯滤波的具体内容参考前一篇：<a href="/opencv-python-smoothing-images/">平滑图像</a><br>$$<br>K=\frac{1}{256}\left[<br> \begin{matrix}<br>   1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \newline<br>   4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \newline<br>   6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \newline<br>   4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \newline<br>   1 &amp; 4 &amp; 6 &amp; 4 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$<br>2，计算图像梯度的方向：</p><p>首先使用Sobel算子计算两个方向上的梯度$ G_x $和$ G_y $，然后算出梯度的方向：<br>$$<br>\theta=\arctan(\frac{G_y}{G_x})<br>$$<br>保留这四个方向的梯度：0°/45°/90°/135°，有什么用呢？我们接着看。</p><p>3，取局部极大值：</p><p>梯度其实已经表示了轮廓，但为了进一步筛选，可以在上面的四个角度方向上再取局部极大值：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_canny_direction.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_canny_direction.jpg" alt=""></picture></p><p>比如，A点在45°方向上大于B/C点，那就保留它，把B/C设置为0。</p><p>4，滞后阈值：</p><p>经过前面三步，就只剩下0和可能的边缘梯度值了，为了最终确定下来，需要设定高低阈值：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_canny_max_min_val.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_canny_max_min_val.jpg" alt=""></picture></p><ul><li>像素点的值大于最高阈值，那肯定是边缘（上图A）</li><li>同理像素值小于最低阈值，那肯定不是边缘</li><li>像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘，所以上图中C算，B不算</li></ul><p>Canny推荐的高低阈值比在2:1到3:1之间。</p><h3 id="先阈值分割后检测"><a href="#先阈值分割后检测" class="headerlink" title="先阈值分割后检测"></a>先阈值分割后检测</h3><p>其实很多情况下，阈值分割后再检测边缘，效果会更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, thresh = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">edges = cv2.Canny(thresh, <span class="number">30</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'canny'</span>, np.hstack((img, thresh, edges)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>代码中我用了<a href="/opencv-python-extra-otsu-thresholding/">番外篇：Otsu阈值法</a>中的自动阈值分割，如果你不太了解，大可以使用传统的方法，不过如果是下面这种图片，推荐用Otsu阈值法。另外Python中某个值不用的话，就写个下划线’_’。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_canny_edge_detection_threshold.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_canny_edge_detection_threshold.jpg" alt=""></picture></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>（选做）如果你不太理解高低阈值的效果，创建两个滑动条来调节它们的值看看：</li></ol><p><img src="http://blog.codec.wang/cv2_trackbar_maxval_minval_canny.gif" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Canny是用的最多的边缘检测算法，用<code>cv2.Canny()</code>实现。</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de" target="_blank" rel="noopener">cv2.Canny()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/11.%20%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" target="_blank" rel="noopener">Canny Edge Detection</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html" target="_blank" rel="noopener">Canny 边缘检测</a></li><li><a href="https://www.computer.org/cms/Computer.org/Transactions%20Home%20Pages/TPAMI/PDFs/top_ten_6.pdf" target="_blank" rel="noopener">Canny J . A Computational Approach To Edge Detection[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698.</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用Canny获取图像的边缘。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="边缘" scheme="http://www.codec.wang/tags/%E8%BE%B9%E7%BC%98/"/>
    
      <category term="Canny" scheme="http://www.codec.wang/tags/Canny/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇9：图像梯度</title>
    <link href="http://www.codec.wang/opencv-python-extra-image-gradients/"/>
    <id>http://www.codec.wang/opencv-python-extra-image-gradients/</id>
    <published>2017-12-18T02:51:43.000Z</published>
    <updated>2020-04-07T04:52:40.918Z</updated>
    
    <content type="html"><![CDATA[<p>了解图像梯度和边缘检测的相关概念。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><p>还记得前面<a href="/opencv-python-smoothing-images/">平滑图像</a>中提到的滤波与模糊的区别吗？我们说低通滤波器是模糊，高通滤波器是锐化，这节我们就来看看高通滤波器。</p><hr><h2 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a><a href="https://baike.baidu.com/item/图像梯度/8528837?fr=aladdin" target="_blank" rel="noopener">图像梯度</a></h2><p>如果你还记得高数中用一阶导数来求极值的话，就很容易理解了：把图片想象成连续函数，因为边缘部分的像素值是与旁边像素明显有区别的，所以对图片局部求极值，就可以得到整幅图片的边缘信息了。不过图片是二维的离散函数，导数就变成了差分，这个差分就称为图像的梯度。</p><p>当然，大部分人应该是早忘记高数了(￣▽￣)”，所以看不懂的话，就把上面的解释划掉，我们重新从卷积的角度来看看。</p><h3 id="垂直边缘提取"><a href="#垂直边缘提取" class="headerlink" title="垂直边缘提取"></a>垂直边缘提取</h3><p>滤波是应用卷积来实现的，卷积的关键就是卷积核，我们来考察下面这个卷积核：</p><p>$$<br>k1 = \left[<br> \begin{matrix}<br>   -1 &amp; 0 &amp; 1 \newline<br>   -2 &amp; 0 &amp; 2 \newline<br>   -1 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><p>这个核是用来提取图片中的垂直边缘的，怎么做到的呢？看下图：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_sobel_edge_detection.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_sobel_edge_detection.jpg" alt=""></picture></p><p>当前列左右两侧的元素进行差分，由于边缘的值明显小于（或大于）周边像素，所以边缘的差分结果会明显不同，这样就提取出了垂直边缘。同理，把上面那个矩阵转置一下，就是提取水平边缘。这种差分操作就称为图像的梯度计算：</p><p>$$<br>k2 = \left[<br> \begin{matrix}<br>   -1 &amp; -2 &amp; -1 \newline<br>   0 &amp; 0 &amp; 0 \newline<br>   1 &amp; 2 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_horizen_vertical_edge_detection.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_horizen_vertical_edge_detection.jpg" alt="垂直和水平边缘提取"></picture></p><blockquote><p>还记得滤波函数<code>cv2.filter2D()</code>吗？（<a href="/opencv-python-extra-padding-and-convolution/">番外篇：卷积基础</a>）我们来手动实现上面的功能：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'sudoku.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己进行垂直边缘提取</span></span><br><span class="line">kernel = np.array([[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">                   [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]], dtype=np.float32)</span><br><span class="line">dst_v = cv2.filter2D(img, <span class="number">-1</span>, kernel)</span><br><span class="line"><span class="comment"># 自己进行水平边缘提取</span></span><br><span class="line">dst_h = cv2.filter2D(img, <span class="number">-1</span>, kernel.T)</span><br><span class="line"><span class="comment"># 横向并排对比显示</span></span><br><span class="line">cv2.imshow(<span class="string">'edge'</span>, np.hstack((img, dst_v, dst_h)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>上面的这种差分方法就叫<a href="https://baike.baidu.com/item/Sobel%E7%AE%97%E5%AD%90/11000092?fr=aladdin" target="_blank" rel="noopener">Sobel算子</a>，它先在垂直方向计算梯度$ G_x=k_1×src $，再在水平方向计算梯度$ G_y=k_2×src $，最后求出总梯度：\(G=\sqrt{Gx^2+Gy^2}\)</p><p>我们可以把前面的代码用Sobel算子更简单地实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sobelx = cv2.Sobel(img, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算x方向</span></span><br><span class="line">sobely = cv2.Sobel(img, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)  <span class="comment"># 只计算y方向</span></span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：很多人疑问，Sobel算子的卷积核这几个值是怎么来的呢？事实上，并没有规定，你可以用你自己的。</p></blockquote><p>比如，最初只利用领域间的原始差值来检测边缘的<a href="https://baike.baidu.com/item/Prewitt%E7%AE%97%E5%AD%90/8415245?fr=aladdin" target="_blank" rel="noopener">Prewitt算子</a>：</p><p>$$<br>K = \left[<br> \begin{matrix}<br>   -1 &amp; 0 &amp; 1 \newline<br>   -1 &amp; 0 &amp; 1 \newline<br>   -1 &amp; 0 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><p>还有比Sobel更好用的<strong>Scharr算子</strong>，大家可以了解下：</p><p>$$<br>K = \left[<br> \begin{matrix}<br>   -3 &amp; 0 &amp; 3 \newline<br>   -10 &amp; 0 &amp; 10 \newline<br>   -3 &amp; 0 &amp; 3<br>  \end{matrix}<br>  \right]<br>$$</p><p>这些算法都是一阶边缘检测的代表，网上也有算子之间的对比资料，有兴趣的可参考<a href="#引用">引用</a>。</p><h3 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a><a href="(https://baike.baidu.com/item/Laplacian%E7%AE%97%E5%AD%90">Laplacian算子</a></h3><p>高数中用一阶导数求极值，在这些极值的地方，二阶导数为0，所以也可以通过求二阶导计算梯度：$ dst=\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2} $</p><p>一维的一阶和二阶差分公式分别为：<br>$$<br>\frac{\partial f}{\partial x}=f(x+1)-f(x)<br>$$</p><p>$$<br>\frac{\partial^2 f}{\partial x^2}=f(x+1)+f(x-1)-2f(x)<br>$$</p><p>提取前面的系数，那么一维的Laplacian滤波核是：<br>$$<br>K=\left[<br> \begin{matrix}<br>   1 &amp; -2 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$<br>而对于二维函数f(x,y)，两个方向的二阶差分分别是：</p><p>$$<br>\frac{\partial^2 f}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y)<br>$$</p><p>$$<br>\frac{\partial^2 f}{\partial y^2}=f(x,y+1)+f(x,y-1)-2f(x,y)<br>$$</p><p>合在一起就是：</p><p>$$<br>\triangledown^2 f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)<br>$$</p><p>同样提取前面的系数，那么二维的Laplacian滤波核就是：</p><p>$$<br>K = \left[<br> \begin{matrix}<br>   0 &amp; 1 &amp; 0 \newline<br>   1 &amp; -4 &amp; 1 \newline<br>   0 &amp; 1 &amp; 0<br>  \end{matrix}<br>  \right]<br>$$</p><p>这就是Laplacian算子的图像卷积模板，有些资料中在此基础上考虑斜对角情况，将卷积核拓展为：</p><p>$$<br>K = \left[<br> \begin{matrix}<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; -8 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><p>OpenCV中直接使用<code>cv2.Laplacian()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img, <span class="number">-1</span>)  <span class="comment"># 使用Laplacian算子</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_laplacian.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_laplacian.jpg" alt=""></picture></p><p>Laplacian算子是二阶边缘检测的典型代表，一/二阶边缘检测各有优缺点，大家可自行了解。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>（选做）同志们有空补补高数<del>姿势</del>（知识）呗！(✿◕‿◕✿)</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8709.%20%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_gradients/py_gradients.html" target="_blank" rel="noopener">Image Gradients</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/sobel_derivatives/sobel_derivatives.html#sobel-derivatives" target="_blank" rel="noopener">Sobel导数</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">维基百科：边缘检测</a></li><li><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解图像梯度和边缘检测的相关概念。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="梯度" scheme="http://www.codec.wang/tags/%E6%A2%AF%E5%BA%A6/"/>
    
      <category term="Sobel" scheme="http://www.codec.wang/tags/Sobel/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程10：平滑图像</title>
    <link href="http://www.codec.wang/opencv-python-smoothing-images/"/>
    <id>http://www.codec.wang/opencv-python-smoothing-images/</id>
    <published>2017-12-15T01:44:24.000Z</published>
    <updated>2020-04-07T04:45:13.352Z</updated>
    
    <content type="html"><![CDATA[<p>学习模糊/平滑图像，消除噪点。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>模糊/平滑图片来消除图片噪声</li><li>OpenCV函数：<code>cv2.blur()</code>, <code>cv2.GaussianBlur()</code>, <code>cv2.medianBlur()</code>, <code>cv2.bilateralFilter()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="滤波与模糊"><a href="#滤波与模糊" class="headerlink" title="滤波与模糊"></a>滤波与模糊</h3><blockquote><p>推荐大家先阅读：<a href="/opencv-python-extra-padding-and-convolution/">番外篇：卷积基础(图片边框)</a>，有助于理解卷积和滤波的概念。</p></blockquote><p>关于滤波和模糊，很多人分不清，我来给大家理理（虽说如此，我后面也会混着用,,ԾㅂԾ,,）：</p><ul><li>它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言）</li><li>低通滤波器是模糊，高通滤波器是锐化</li></ul><p>低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。</p><blockquote><p>常见噪声有<a href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958?fr=aladdin" target="_blank" rel="noopener">椒盐噪声</a>和<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0" target="_blank" rel="noopener">高斯噪声</a>，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。</p></blockquote><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p><p>$$<br> kernel = \frac{1}{9}\left[<br> \begin{matrix}<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line">blur = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))  <span class="comment"># 均值模糊</span></span><br></pre></td></tr></table></figure><blockquote><p>所有的滤波函数都有一个可选参数borderType，这个参数就是<a href="/opencv-python-extra-padding-and-convolution/">番外篇：卷积基础(图片边框)</a>中所说的边框填充方式。</p></blockquote><h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p><p>$$<br>k = a\left[<br> \begin{matrix}<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><p>用<code>cv2.boxFilter()</code>函数实现，当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1/9；normalize为False的时候，a=1，相当于求区域内的像素和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span></span><br><span class="line">blur = cv2.boxFilter(img, <span class="number">-1</span>, (<span class="number">3</span>, <span class="number">3</span>), normalize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，来，数学时间( ╯□╰ )，还记得标准正态分布的曲线吗？</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_gaussian_kernel_function_theory.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_gaussian_kernel_function_theory.jpg" alt=""></picture></p><p>显然这种处理元素间权值的方式更加合理一些。图像是2维的，所以我们需要使用<a href="https://en.wikipedia.org/wiki/Gaussian_filter" target="_blank" rel="noopener">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的<a href="#番外小篇：高斯滤波卷积核">番外小篇</a>）：</p><p>$$<br>k = \left[<br> \begin{matrix}<br>   0.0625 &amp; 0.125 &amp; 0.0625 \newline<br>   0.125 &amp; 0.25 &amp; 0.125 \newline<br>   0.0625 &amp; 0.125 &amp; 0.0625<br>  \end{matrix}<br>  \right]<br>$$<br>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'gaussian_noise.bmp'</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs高斯滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">gaussian = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">1</span>)  <span class="comment"># 高斯滤波</span></span><br></pre></td></tr></table></figure><p>参数3 σx值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_gaussian_vs_average.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_gaussian_vs_average.jpg" alt=""></picture></p><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%80%BC" target="_blank" rel="noopener">中值</a>又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，适用于去除椒盐噪声和斑点噪声。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p><p>比如下面这张斑点噪声图，用中值滤波显然更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'salt_noise.bmp'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 均值滤波vs中值滤波</span></span><br><span class="line">blur = cv2.blur(img, (<span class="number">5</span>, <span class="number">5</span>))  <span class="comment"># 均值滤波</span></span><br><span class="line">median = cv2.medianBlur(img, <span class="number">5</span>)  <span class="comment"># 中值滤波</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_median_vs_average.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_median_vs_average.jpg" alt=""></picture></p><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a href="https://baike.baidu.com/item/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2" target="_blank" rel="noopener">双边滤波</a>。用<code>cv2.bilateralFilter()</code>函数实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line"><span class="comment"># 双边滤波vs高斯滤波</span></span><br><span class="line">gau = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)  <span class="comment"># 高斯滤波</span></span><br><span class="line">blur = cv2.bilateralFilter(img, <span class="number">9</span>, <span class="number">75</span>, <span class="number">75</span>)  <span class="comment"># 双边滤波</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_bilateral_vs_gaussian.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_bilateral_vs_gaussian.jpg" alt=""></picture></p><p>可以看到，双边滤波明显保留了更多边缘信息。</p><h2 id="番外小篇：高斯滤波卷积核"><a href="#番外小篇：高斯滤波卷积核" class="headerlink" title="番外小篇：高斯滤波卷积核"></a>番外小篇：高斯滤波卷积核</h2><p>要解释高斯滤波卷积核是如何生成的，需要先复习下概率论的知识（What？？又是数学( ╯□╰ )）</p><p>一维的高斯函数/正态分布$ X\sim N(\mu, \sigma^2) $：<br>$$<br>G(x)=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x-\mu)^2}{2\sigma^2})<br>$$<br>当$ \mu=0, \sigma^2=1 $时，称为标准正态分布$ X\sim N(0, 1) $：<br>$$<br>G(x)=\frac{1}{\sqrt{2\pi}}exp(-\frac{x^2}{2})<br>$$<br>二维X/Y相互独立的高斯函数：<br>$$<br>G(x,y)=\frac{1}{2\pi\sigma_x\sigma_y}exp(-\frac{(x-\mu_x)^2+(y-\mu_y)^2}{2\sigma_x\sigma_y})=G(x)G(y)<br>$$</p><p>由上可知，<strong>二维高斯函数具有可分离性</strong>，所以OpenCV分两步计算二维高斯卷积，先水平再垂直，每个方向上都是一维的卷积。OpenCV中这个一维卷积的计算公式类似于上面的一维高斯函数：<br>$$<br>G(i)=\alpha *exp(-\frac{(i-\frac{ksize-1}{2})^2}{2\sigma^2})<br>$$<br>其中i=0…ksize-1，α是一个常数，也称为缩放因子，它使得\(\sum{G(i)}=1\)</p><p>比如我们可以用<a href="https://docs.opencv.org/3.3.1/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" target="_blank" rel="noopener"><code>cv2.getGaussianKernel(ksize,sigma)</code></a>来生成一维卷积核：</p><ul><li>sigma&lt;=0时，<code>sigma=0.3*((ksize-1)*0.5 - 1) + 0.8</code></li><li>sigma&gt;0时，sigma=sigma</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(cv2.getGaussianKernel(<span class="number">3</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 结果：[[0.25][0.5][0.25]]</span></span><br></pre></td></tr></table></figure><p>生成之后，先进行三次的水平卷积：<br>$$<br>I×\left[<br> \begin{matrix}<br>   0.25 &amp; 0.5 &amp; 0.25 \newline<br>    0.25 &amp; 0.5 &amp; 0.25 \newline<br>   0.25 &amp; 0.5 &amp; 0.25<br>  \end{matrix}<br>  \right]<br>$$<br>然后再进行垂直的三次卷积：<br>$$<br>I×\left[<br> \begin{matrix}<br>   0.25 &amp; 0.5 &amp; 0.25 \newline<br>    0.25 &amp; 0.5 &amp; 0.25 \newline<br>   0.25 &amp; 0.5 &amp; 0.25<br>  \end{matrix}<br>  \right]×\left[<br> \begin{matrix}<br>   0.25 &amp; 0.25 &amp; 0.25 \newline<br>    0.5 &amp; 0.5 &amp; 0.5 \newline<br>   0.25 &amp; 0.25 &amp; 0.25<br>  \end{matrix}<br>  \right] =I×\left[<br> \begin{matrix}<br>   0.0625 &amp; 0.125 &amp; 0.0625 \newline<br>   0.125 &amp; 0.25 &amp; 0.125 \newline<br>   0.0625 &amp; 0.125 &amp; 0.0625<br>  \end{matrix}<br>  \right]<br>$$<br>这就是OpenCV中高斯卷积核的生成方式。其实，OpenCV源码中对小于7×7的核是直接计算好放在数组里面的，这样计算速度会快一点，感兴趣的可以看下源码：<a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/blob/master/10.%20%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/cv2_source_code_getGaussianKernel.cpp" target="_blank" rel="noopener">getGaussianKernel()</a></p><p>上面矩阵也可以写成：<br>$$<br>\frac{1}{16}\left[<br> \begin{matrix}<br>   1&amp; 2 &amp; 1 \newline<br>   2 &amp; 4 &amp; 2 \newline<br>   1 &amp; 2 &amp; 1<br>  \end{matrix}<br>  \right]<br>$$</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li><li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li><li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li><li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li><li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37" target="_blank" rel="noopener">cv2.blur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3" target="_blank" rel="noopener">cv2.boxFilter()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv2.GaussianBlur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" target="_blank" rel="noopener">cv2.getGaussianKernel()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9" target="_blank" rel="noopener">cv2.medianBlur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed" target="_blank" rel="noopener">cv2.bilateralFilter()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/10.%20%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html" target="_blank" rel="noopener">Smoothing Images</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">图像平滑处理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习模糊/平滑图像，消除噪点。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="模糊" scheme="http://www.codec.wang/tags/%E6%A8%A1%E7%B3%8A/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇8：卷积基础(图片边框)</title>
    <link href="http://www.codec.wang/opencv-python-extra-padding-and-convolution/"/>
    <id>http://www.codec.wang/opencv-python-extra-padding-and-convolution/</id>
    <published>2017-12-14T08:27:45.000Z</published>
    <updated>2020-04-07T04:53:04.946Z</updated>
    
    <content type="html"><![CDATA[<p>了解卷积/滤波的基础知识，给图片添加边框。<a id="more"></a>如果你已了解相关理论，请直接跳到<a href="#添加边框">添加边框</a>部分。</p><p>卷积的概念其实很好理解，下面我就给大家做个最简单的解释，绝对轻松加愉快的辣o(<em>￣▽￣</em>)o</p><hr><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>什么是二维卷积呢？看下面一张图就一目了然：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_convolution.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_convolution.jpg" alt=""></picture></p><p>卷积就是循环对<strong>图像跟一个核逐个元素相乘再求和得到另外一副图像的操作</strong>，比如结果图中第一个元素5是怎么算的呢？原图中3×3的区域与3×3的核逐个元素相乘再相加：<br>$$<br>5=1\times1+2\times0+1\times0+0\times0+1\times0+1\times0+3\times0+0\times0+2\times2<br>$$<br>算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积：</p><p><img src="http://blog.codec.wang/cv2_understand_cnn.gif" alt=""></p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p><blockquote><p>事实上，原图为n×n，卷积核为f×f，最终结果图大小为(n-f+1) × (n-f+1)。</p></blockquote><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_padding.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_padding.jpg" alt=""></picture></p><p>那么扩展的这一层应该填充什么值呢？OpenCV中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现，一起来看看。</p><h2 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h2><p><code>cv2.copyMakeBorder()</code>用来给图片添加边框，它有下面几个参数：</p><ul><li>src：要处理的原图</li><li>top, bottom, left, right：上下左右要扩展的像素数</li><li><strong>borderType</strong>：边框类型，这个就是需要关注的填充方式，详情请参考：<a href="https://docs.opencv.org/3.3.1/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5" target="_blank" rel="noopener">BorderTypes</a></li></ul><p>其中默认方式和固定值方式最常用，我们详细说明一下：</p><h3 id="固定值填充"><a href="#固定值填充" class="headerlink" title="固定值填充"></a>固定值填充</h3><p>顾名思义，<code>cv2.BORDER_CONSTANT</code>这种方式就是边框都填充成一个固定的值，比如下面的程序都填充0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'6_by_6.bmp'</span>, <span class="number">0</span>)</span><br><span class="line">print(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定值边框，统一都填充0也称为zero padding</span></span><br><span class="line">cons = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_CONSTANT, value=<span class="number">0</span>)</span><br><span class="line">print(cons)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_zero_padding_output.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_zero_padding_output.jpg" alt=""></picture></p><h3 id="默认边框类型"><a href="#默认边框类型" class="headerlink" title="默认边框类型"></a>默认边框类型</h3><p>默认边框<code>cv2.BORDER_DEFAULT</code>其实是取镜像对称的像素填充，比较拗口，一步步解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default = cv2.copyMakeBorder(img, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, cv2.BORDER_DEFAULT)</span><br><span class="line">print(default)</span><br></pre></td></tr></table></figure><p>首先进行上下填充，填充成与原图像边界对称的值，如下图：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_up_down_padding_first.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_up_down_padding_first.jpg" alt=""></picture></p><p>同理再进行左右两边的填充，最后把四个顶点补充上就好了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_right_left_padding_second2.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_right_left_padding_second2.jpg" alt=""></picture></p><blockquote><p>经验之谈：一般情况下默认方式更加合理，因为边界的像素值更加接近。具体应视场合而定。</p></blockquote><h2 id="OpenCV进行卷积"><a href="#OpenCV进行卷积" class="headerlink" title="OpenCV进行卷积"></a>OpenCV进行卷积</h2><p>OpenCV中用<code>cv2.filter2D()</code>实现卷积操作，比如我们的核是下面这样（3×3区域像素的和除以10）：</p><p>$$<br>M = \frac{1}{10}\left[<br> \begin{matrix}<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1 \newline<br>   1 &amp; 1 &amp; 1<br>  \end{matrix}<br>  \right] \tag{3}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line"><span class="comment"># 定义卷积核</span></span><br><span class="line">kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.float32) / <span class="number">10</span></span><br><span class="line"><span class="comment"># 卷积操作，-1表示通道数与原图相同</span></span><br><span class="line">dst = cv2.filter2D(img, <span class="number">-1</span>, kernel)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_convolution_kernel_3_3.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_convolution_kernel_3_3.jpg" alt=""></picture></p><p>可以看到这个核对图像进行了模糊处理，这是卷积的众多功能之一。当然卷积还有很多知识没有学到，后面我们再继续深入。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>尝试给”lena.jpg”添加几种不同的边框类型，对比下效果。</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8708.%20%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80(%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html" target="_blank" rel="noopener">Basic Operations on Images</a></li><li><a href="http://blog.csdn.net/zouxy09/article/details/49080029" target="_blank" rel="noopener">图像卷积与滤波的一些知识点</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解卷积/滤波的基础知识，给图片添加边框。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="卷积" scheme="http://www.codec.wang/tags/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程9：图像混合</title>
    <link href="http://www.codec.wang/opencv-python-image-blending/"/>
    <id>http://www.codec.wang/opencv-python-image-blending/</id>
    <published>2017-12-10T06:13:10.000Z</published>
    <updated>2020-04-07T04:44:48.367Z</updated>
    
    <content type="html"><![CDATA[<p>学习图片间的数学运算，图像混合。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>图片间的数学运算，如相加、按位运算等</li><li>OpenCV函数：<code>cv2.add()</code>, <code>cv2.addWeighted()</code>, <code>cv2.bitwise_and()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><blockquote><p>首先恭喜你已经完成了入门篇的学习噢，接下来我们学习一些OpenCV的基础内容，加油(ง •_•)ง</p></blockquote><h3 id="图片相加"><a href="#图片相加" class="headerlink" title="图片相加"></a>图片相加</h3><p>要叠加两张图片，可以用<code>cv2.add()</code>函数，相加两幅图片的形状（高度/宽度/通道数）必须相同。numpy中可以直接用res = img + img1相加，但这两者的结果并不相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.uint8([<span class="number">250</span>])</span><br><span class="line">y = np.uint8([<span class="number">10</span>])</span><br><span class="line">print(cv2.add(x, y))  <span class="comment"># 250+10 = 260 =&gt; 255</span></span><br><span class="line">print(x + y)  <span class="comment"># 250+10 = 260 % 256 = 4</span></span><br></pre></td></tr></table></figure><p>如果是二值化图片（只有0和255两种值），两者结果是一样的（用numpy的方式更简便一些）。</p><h3 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h3><p>图像混合<code>cv2.addWeighted()</code>也是一种图片相加的操作，只不过两幅图片的权重不一样，γ相当于一个修正值：</p><p>$$<br>dst = \alpha\times img1+\beta\times img2 + \gamma<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">'lena_small.jpg'</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">'opencv-logo-white.png'</span>)</span><br><span class="line">res = cv2.addWeighted(img1, <span class="number">0.6</span>, img2, <span class="number">0.4</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_image_blending_6_4.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_image_blending_6_4.jpg" alt="图像混合"></picture></p><blockquote><p>经验之谈：α和β都等于1时，就相当于图片相加。</p></blockquote><h3 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h3><p>按位操作包括按位与/或/非/异或操作，有什么用途呢？比如说我们要实现下图的效果：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_bitwise_operations_demo.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_bitwise_operations_demo.jpg" alt=""></picture></p><p>如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作。首先来了解一下<a href="https://baike.baidu.com/item/%E6%8E%A9%E8%86%9C/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a>（mask）的概念：掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡，看下图就一目了然了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_understand_mask.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_understand_mask.jpg" alt="掩膜概念"></picture></p><p>所以我们的思路就是把原图中要放logo的区域抠出来，再把logo放进去就行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">'opencv-logo-white.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把logo放在左上角，所以我们只关心这一块区域</span></span><br><span class="line">rows, cols = img2.shape[:<span class="number">2</span>]</span><br><span class="line">roi = img1[:rows, :cols]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建掩膜</span></span><br><span class="line">img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, mask = cv2.threshold(img2gray, <span class="number">10</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">mask_inv = cv2.bitwise_not(mask)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留除logo外的背景</span></span><br><span class="line">img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)</span><br><span class="line">dst = cv2.add(img1_bg, img2)  <span class="comment"># 进行融合</span></span><br><span class="line">img1[:rows, :cols] = dst  <span class="comment"># 融合后放在原图上</span></span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：掩膜的概念在图像混合/叠加的场景下使用较多，可以多多练习噢！</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>cv2.add()</code>用来叠加两幅图片，<code>cv2.addWeighted()</code>也是叠加两幅图片，但两幅图片的权重不一样。</li><li><code>cv2.bitwise_and()</code>, <code>cv2.bitwise_not()</code>, <code>cv2.bitwise_or()</code>, <code>cv2.bitwise_xor()</code>分别执行按位与/或/非/异或运算。掩膜就是用来对图片进行全局或局部的遮挡。</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6" target="_blank" rel="noopener">cv2.add()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19" target="_blank" rel="noopener">cv2.addWeighted()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14" target="_blank" rel="noopener">cv2.bitwise_and()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga0002cf8b418479f4cb49a75442baee2f" target="_blank" rel="noopener">cv2.bitwise_not()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/09.%20%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://baike.baidu.com/item/%E6%8E%A9%E8%86%9C/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html" target="_blank" rel="noopener">Arithmetic Operations on Images</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习图片间的数学运算，图像混合。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="图像混合" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇7：亮度与对比度</title>
    <link href="http://www.codec.wang/opencv-python-extra-contrast-brightness/"/>
    <id>http://www.codec.wang/opencv-python-extra-contrast-brightness/</id>
    <published>2017-12-10T06:05:10.000Z</published>
    <updated>2020-04-07T04:53:18.632Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何调整图片的亮度和对比度。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="亮度与对比度"><a href="#亮度与对比度" class="headerlink" title="亮度与对比度"></a>亮度与对比度</h2><p>亮度调整是将图像像素的强度整体变大/变小，对比度调整指的是图像暗处的像素强度变低，亮出的变高，从而拓宽某个区域内的显示精度。</p><p>OpenCV中亮度和对比度应用这个公式来计算：$ g(x)=\alpha f(x)+\beta $，其中：α(&gt;0)、β常称为增益与偏置值，分别控制图片的对比度和亮度。</p><blockquote><p>经验之谈：此处对α/β控制对比度和亮度有争议，具体请参考：<a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">OpenCV关于对比度和亮度的误解</a>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line"><span class="comment"># 此处需注意，请参考后面的解释</span></span><br><span class="line">res = np.uint8(np.clip((<span class="number">1.5</span> * img + <span class="number">10</span>), <span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">tmp = np.hstack((img, res))  <span class="comment"># 两张图片横向合并（便于对比显示）</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'image'</span>, tmp)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>还记得图像混合那一节中numpy对数据溢出的取模处理吗？<code>250+10 = 260 =&gt; 260%256=4</code>，它并不适用于我们的图像处理，所以用<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener">np.clip()</a>函数将数据限定：<code>a&lt;0 =&gt; a=0, a&gt;255 =&gt; a=255</code>。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_contrast_brightness.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_contrast_brightness.jpg" alt="亮度与对比度调整"></picture></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><p>创建两个滑动条分别调整对比度和亮度（对比度范围：0<del>0.3，亮度：0</del>100）。提示：因为滑动条没有小数，所以可以设置为0~300，然后乘以0.01。</p></li><li><p>亮度/对比度用C++实现也很有趣，推荐阅读：<a href="http://blog.csdn.net/u013139259/article/details/52145377" target="_blank" rel="noopener">OpenCV改变图像亮度和对比度以及优化</a>。</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8707.%20%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener">numpy.clip()</a></li><li><a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">OpenCV关于对比度和亮度的误解</a></li><li><a href="http://blog.csdn.net/u013139259/article/details/52145377" target="_blank" rel="noopener">OpenCV改变图像亮度和对比度以及优化</a></li><li><a href="https://docs.opencv.org/3.1.0/d3/d63/classcv_1_1Mat.html#a3f356665bb0ca452e7d7723ccac9a810" target="_blank" rel="noopener">Mat::convertTo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何调整图片的亮度和对比度。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="亮度" scheme="http://www.codec.wang/tags/%E4%BA%AE%E5%BA%A6/"/>
    
      <category term="对比度" scheme="http://www.codec.wang/tags/%E5%AF%B9%E6%AF%94%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程拓展挑战：PyQt编写GUI界面</title>
    <link href="http://www.codec.wang/opencv-python-using-pyqt5-create-gui/"/>
    <id>http://www.codec.wang/opencv-python-using-pyqt5-create-gui/</id>
    <published>2017-12-09T09:30:34.000Z</published>
    <updated>2020-04-07T04:51:01.399Z</updated>
    
    <content type="html"><![CDATA[<p>拓展挑战：编写GUI图像处理应用程序。<a id="more"></a></p><hr><h2 id="挑战内容"><a href="#挑战内容" class="headerlink" title="挑战内容"></a>挑战内容</h2><p>前面我们学习的OpenCV内容都是运行在命令行中的，没有界面，所以本次的拓展挑战内容便是：</p><blockquote><p><strong>了解Python编写<a href="https://baike.baidu.com/item/GUI" target="_blank" rel="noopener">GUI</a>界面的方法，使用PyQt5编写如下的图像处理应用程序，实现打开摄像头、捕获图片、读取本地图片、灰度化和Otsu自动阈值分割的功能。</strong></p></blockquote><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt_gui_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt_gui_sample.jpg" alt=""></picture></p><p><strong>挑战题不会做也木有关系，但请务必在自行尝试后，再看下面的解答噢，</strong>不然…我也没办法(￣▽￣)”</p><hr><h2 id="挑战解答"><a href="#挑战解答" class="headerlink" title="挑战解答"></a>挑战解答</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>目前我们学的内容都是跑在命令行中的，并没有界面，那么”脚本语言”Python如何搭建GUI界面呢？</p></blockquote><p>其实Python支持多种图形界面库，如<a href="https://wiki.python.org/moin/TkInter" target="_blank" rel="noopener">Tk(Tkinter)</a>、<a href="https://www.wxpython.org/" target="_blank" rel="noopener">wxPython</a>、<a href="https://wiki.python.org/moin/PyQt" target="_blank" rel="noopener">PyQt</a>等，虽然Python自带Tkinter，无需额外安装包，但我更推荐使用PyQt，一是因为它完全基于Qt，跨平台，功能强大，有助于了解Qt的语法，二是Qt提供了Designer设计工具，界面设计上可以拖控件搞定，非常方便，大大节省时间。</p><ul><li>最新版本：PyQt 5.x</li><li>官网（可能需要翻墙）：<a href="https://www.riverbankcomputing.com/software/pyqt/" target="_blank" rel="noopener">https://www.riverbankcomputing.com/software/pyqt/</a></li></ul><p>大家感兴趣的话，除去官网，下面是一些可参考的资源：</p><ul><li><a href="https://wiki.python.org/moin/PyQt" target="_blank" rel="noopener">Python Wiki: PyQt</a></li><li><a href="https://wiki.python.org/moin/PyQt/Tutorials" target="_blank" rel="noopener">PyQt/Tutorials</a></li><li>PyQt5 tutorial：<a href="http://zetcode.com/gui/pyqt5/" target="_blank" rel="noopener">英文原版</a></li><li>PyQt4 tutorial：<a href="http://www.qaulau.com/books/PyQt4_Tutorial/index.html" target="_blank" rel="noopener">中文版</a>、<a href="http://zetcode.com/gui/pyqt4/" target="_blank" rel="noopener">英文原版</a></li><li><a href="https://doc.qt.io/qt-5/" target="_blank" rel="noopener">Qt5 Documentation</a></li><li>中文参考书：<a href="https://www.amazon.cn/dp/B075VWFYFH/ref=sr_1_1?ie=UTF8&qid=1543407852&sr=8-1&keywords=PyQt5%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%9E%E6%88%98" target="_blank" rel="noopener">PyQt5快速开发与实战</a></li><li><a href="http://eric-ide.python-projects.org/" target="_blank" rel="noopener">基于Qt的Python IDE Eric</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5</span><br></pre></td></tr></table></figure><p>下载速度慢的话，可以到<a href="https://pypi.org/project/PyQt5/#files" target="_blank" rel="noopener">PyPI</a>上下载离线版安装。另外我推荐使用Qt Designer来设计界面，如果你装的是Anaconda的话，就已经自带了designer.exe，例如我的是在：D:\ProgramData\Anaconda3\Library\bin\，如果是普通的Python环境，则需要自行安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure><p>安装完成后，designer.exe应该在Python安装目录下：xxx\Lib\site-packages\pyqt5_tools\。</p><p>可以使用下面的代码生成一个简单的界面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line"></span><br><span class="line">    window = QWidget()</span><br><span class="line">    window.setWindowTitle(<span class="string">'Hello World!'</span>)</span><br><span class="line">    window.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt5_hello_world_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt5_hello_world_sample.jpg" alt=""></picture></p><h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><p>根据我们的挑战内容，解决思路是使用Qt Designer来设计界面，使用Python完成代码逻辑。打开designer.exe，会弹出创建新窗体的窗口，我们直接点击“create”：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt5_designer_main_ui.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt5_designer_main_ui.jpg" alt=""></picture></p><p>界面的左侧是Qt的常用控件”Widget Box”，右侧有一个控件属性窗口”Property Editor”，其余暂时用不到。本例中我们只用到了”Push Button”控件和”Label”控件：最上面的三个Label控件用于显示图片，可以在属性窗口调整它的大小，我们统一调整到150×150：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt5_main_ui_rough.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt5_main_ui_rough.jpg" alt=""></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt5_designer_property_windows.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt5_designer_property_windows.jpg" alt=""></picture></p><p>另外，控件上显示的文字”text”属性和控件的名字”objectName”属性需要修改，便于显示和代码调用。可以按照下面我推荐的命名：</p><table><thead><tr><th align="center">控件</th><th align="center">显示内容text</th><th align="center">控件名objectName</th></tr></thead><tbody><tr><td align="center">PushButton</td><td align="center">打开摄像头</td><td align="center">btnOpenCamera</td></tr><tr><td align="center">PushButton</td><td align="center">捕获图片</td><td align="center">btnCapture</td></tr><tr><td align="center">PushButton</td><td align="center">打开图片</td><td align="center">btnReadImage</td></tr><tr><td align="center">PushButton</td><td align="center">灰度化</td><td align="center">btnGray</td></tr><tr><td align="center">PushButton</td><td align="center">阈值分割(Otsu)</td><td align="center">btnThreshold</td></tr><tr><td align="center">Label</td><td align="center">摄像头</td><td align="center">labelCamera</td></tr><tr><td align="center">Label</td><td align="center">捕获图</td><td align="center">labelCapture</td></tr><tr><td align="center">Label</td><td align="center">结果图</td><td align="center">labelResult</td></tr></tbody></table><p>这样大致界面就出来了，很简单：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt5_main_ui_word.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt5_main_ui_word.jpg" alt=""></picture></p><h3 id="按钮事件"><a href="#按钮事件" class="headerlink" title="按钮事件"></a>按钮事件</h3><p>如果你之前有过一些GUI开发经验，比如MFC，WinForm等，就知道GUI是通过事件驱动的，什么意思呢？比如前面我们已经设计好了界面，接下来就需要实现”打开摄像头”到”阈值分割”这5个按钮的功能，也就是给每个按钮指定一个”函数”，逻辑代码写在这个函数里面。这种函数就称为事件，Qt中称为槽连接。</p><p>点击Designer工具栏的”Edit Signals/Slots”按钮，进入槽函数编辑界面，点击旁边的”Edit Widgets”可以恢复正常视图：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt5_designer_edit_singals_slots.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt5_designer_edit_singals_slots.jpg" alt=""></picture></p><p>然后点击按钮并拖动，当产生类似于电路中的接地符号时释放鼠标，参看下面动图：</p><p><img src="http://blog.codec.wang/cv2_pyqt5_how_to_create_slots.gif" alt=""></p><p>在弹出的配置窗口中，可以看到左侧是按钮的常用事件，我们选择点击事件”clicked()”，然后添加一个名为”btnOpenCamera_Clicked()”的槽函数：</p><p><img src="http://blog.codec.wang/cv2_pyqt5_how_to_create_slots2.gif" alt=""></p><p>重复上面的步骤，给五个按钮添加五个槽函数，最终结果如下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt5_main_click_event.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt5_main_click_event.jpg" alt=""></picture></p><p>到此，我们就完成了界面设计的所有工作，按下Ctrl+S保存当前窗口为.ui文件。.ui文件其实是按照XML格式标记的内容，可以用文本编辑器将.ui文件打开看看。</p><h3 id="ui文件转py代码"><a href="#ui文件转py代码" class="headerlink" title="ui文件转py代码"></a>ui文件转py代码</h3><p>因为我们是用Designer工具设计出的界面，并不是用Python代码敲出来的，所以要想真正运行，需要使用pyuic5将ui文件转成py文件。pyuic5.exe默认在%\Scripts\下，比如我的是在：D:\ProgramData\Anaconda3\Scripts\。</p><p>打开cmd命令行，切换到ui文件的保存目录。Windows下有个小技巧，可以在目录的地址栏输入cmd，一步切换到当前目录：</p><p><img src="http://blog.codec.wang/cv2_pyqt5_pyuic_quick_cmd.gif" alt=""></p><p>然后执行这条指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 -o mainForm.py using_pyqt_create_ui.ui</span><br></pre></td></tr></table></figure><p>如果出现pyuic5不是内部命令的错误，说明pyuic5的路径没有在环境变量里，添加下就好了。执行正常的话，就会生成mainForm.py文件，里面应该包含一个名为”Ui_MainWindow”的类。</p><h3 id="编写逻辑代码"><a href="#编写逻辑代码" class="headerlink" title="编写逻辑代码"></a>编写逻辑代码</h3><blockquote><p>经验之谈：mainForm.py文件是根据ui文件生成的，也就是说<strong>重新生成会覆盖掉</strong>。所以为了使界面与逻辑分离，我们需要新建一个逻辑文件。</p></blockquote><p>在同一工作目录下新建一个”mainEntry.py”的文件，存放逻辑代码。代码中的每部分我都写得比较独立，没有封装成函数，便于理解。代码看上去很长，但很简单，可以每个模块单独看，有几个需要注意的地方我做了注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtGui, QtWidgets</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QFileDialog, QMainWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mainForm <span class="keyword">import</span> Ui_MainWindow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyQtMainEntry</span><span class="params">(QMainWindow, Ui_MainWindow)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line">        self.camera = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">        self.is_camera_opened = <span class="literal">False</span>  <span class="comment"># 摄像头有没有打开标记</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定时器：30ms捕获一帧</span></span><br><span class="line">        self._timer = QtCore.QTimer(self)</span><br><span class="line">        self._timer.timeout.connect(self._queryFrame)</span><br><span class="line">        self._timer.setInterval(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btnOpenCamera_Clicked</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        打开和关闭摄像头</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.is_camera_opened = ~self.is_camera_opened</span><br><span class="line">        <span class="keyword">if</span> self.is_camera_opened:</span><br><span class="line">            self.btnOpenCamera.setText(<span class="string">"关闭摄像头"</span>)</span><br><span class="line">            self._timer.start()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.btnOpenCamera.setText(<span class="string">"打开摄像头"</span>)</span><br><span class="line">            self._timer.stop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btnCapture_Clicked</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        捕获图片</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 摄像头未打开，不执行任何操作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_camera_opened:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.captured = self.frame</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 后面这几行代码几乎都一样，可以尝试封装成一个函数</span></span><br><span class="line">        rows, cols, channels = self.captured.shape</span><br><span class="line">        bytesPerLine = channels * cols</span><br><span class="line">        <span class="comment"># Qt显示图片时，需要先转换成QImgage类型</span></span><br><span class="line">        QImg = QImage(self.captured.data, cols, rows, bytesPerLine, QImage.Format_RGB888)</span><br><span class="line">        self.labelCapture.setPixmap(QPixmap.fromImage(QImg).scaled(</span><br><span class="line">            self.labelCapture.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btnReadImage_Clicked</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        从本地读取图片</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 打开文件选取对话框</span></span><br><span class="line">        filename,  _ = QFileDialog.getOpenFileName(self, <span class="string">'打开图片'</span>)</span><br><span class="line">        <span class="keyword">if</span> filename:</span><br><span class="line">            self.captured = cv2.imread(str(filename))</span><br><span class="line">            <span class="comment"># OpenCV图像以BGR通道存储，显示时需要从BGR转到RGB</span></span><br><span class="line">            self.captured = cv2.cvtColor(self.captured, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">            rows, cols, channels = self.captured.shape</span><br><span class="line">            bytesPerLine = channels * cols</span><br><span class="line">            QImg = QImage(self.captured.data, cols, rows, bytesPerLine, QImage.Format_RGB888)</span><br><span class="line">            self.labelCapture.setPixmap(QPixmap.fromImage(QImg).scaled(</span><br><span class="line">                self.labelCapture.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btnGray_Clicked</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        灰度化</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 如果没有捕获图片，则不执行操作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">"captured"</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.cpatured = cv2.cvtColor(self.captured, cv2.COLOR_RGB2GRAY)</span><br><span class="line"></span><br><span class="line">        rows, columns = self.cpatured.shape</span><br><span class="line">        bytesPerLine = columns</span><br><span class="line">        <span class="comment"># 灰度图是单通道，所以需要用Format_Indexed8</span></span><br><span class="line">        QImg = QImage(self.cpatured.data, columns, rows, bytesPerLine, QImage.Format_Indexed8)</span><br><span class="line">        self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled(</span><br><span class="line">            self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btnThreshold_Clicked</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Otsu自动阈值分割</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">"captured"</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        _, self.cpatured = cv2.threshold(</span><br><span class="line">            self.cpatured, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line">        rows, columns = self.cpatured.shape</span><br><span class="line">        bytesPerLine = columns</span><br><span class="line">        <span class="comment"># 阈值分割图也是单通道，也需要用Format_Indexed8</span></span><br><span class="line">        QImg = QImage(self.cpatured.data, columns, rows, bytesPerLine, QImage.Format_Indexed8)</span><br><span class="line">        self.labelResult.setPixmap(QPixmap.fromImage(QImg).scaled(</span><br><span class="line">            self.labelResult.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @QtCore.pyqtSlot()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_queryFrame</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        循环捕获图片</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        ret, self.frame = self.camera.read()</span><br><span class="line"></span><br><span class="line">        img_rows, img_cols, channels = self.frame.shape</span><br><span class="line">        bytesPerLine = channels * img_cols</span><br><span class="line"></span><br><span class="line">        cv2.cvtColor(self.frame, cv2.COLOR_BGR2RGB, self.frame)</span><br><span class="line">        QImg = QImage(self.frame.data, img_cols, img_rows, bytesPerLine, QImage.Format_RGB888)</span><br><span class="line">        self.labelCamera.setPixmap(QPixmap.fromImage(QImg).scaled(</span><br><span class="line">            self.labelCamera.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QtWidgets.QApplication(sys.argv)</span><br><span class="line">    window = PyQtMainEntry()</span><br><span class="line">    window.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_pyqt_gui_sample2.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_pyqt_gui_sample2.jpg" alt=""></picture></p><p>本文只是抛砖引玉，介绍了PyQt5的简单使用，想要深入学习，可以参考本文开头的参考资料噢(●ˇ∀ˇ●)</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A12%EF%BC%9APyQt5%E7%BC%96%E5%86%99GUI%E7%95%8C%E9%9D%A2" target="_blank" rel="noopener">本节源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拓展挑战：编写GUI图像处理应用程序。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="PyQt" scheme="http://www.codec.wang/tags/PyQt/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程挑战任务：画动态时钟</title>
    <link href="http://www.codec.wang/opencv-python-clock-drawing/"/>
    <id>http://www.codec.wang/opencv-python-clock-drawing/</id>
    <published>2017-12-09T09:29:34.000Z</published>
    <updated>2020-04-07T04:51:38.853Z</updated>
    
    <content type="html"><![CDATA[<p>挑战任务：使用OpenCV绘制一个随系统时间动态变化的时钟。<a id="more"></a></p><hr><h2 id="挑战内容"><a href="#挑战内容" class="headerlink" title="挑战内容"></a>挑战内容</h2><blockquote><p><strong>完成如下图所展示的动态时钟，时钟需随系统时间变化，中间显示当前日期。</strong></p></blockquote><p><img src="http://blog.codec.wang/cv2_draw_clock_dynamic_sample.gif" alt=""></p><p>其实本次任务涉及的OpenCV知识并不多，但有助于提升大家的编程实践能力。</p><p><strong>挑战题不会做也木有关系，但请务必在自行尝试后，再看下面的解答噢，</strong>不然…我也没办法(￣▽￣)”</p><hr><h2 id="挑战解答"><a href="#挑战解答" class="headerlink" title="挑战解答"></a>挑战解答</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>本次挑战任务旨在提升大家的动手实践能力，解决实际问题，所以我们得先有个解题思路和方案。观察下常见的时钟表盘：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_clock_actual_clock_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_clock_actual_clock_sample.jpg" alt=""></picture></p><p>整个表盘其实只有3根表针在动，所以可以先画出静态表盘，然后获取系统当前时间，根据时间实时动态绘制3根表针就解决了。</p><h3 id="绘制表盘"><a href="#绘制表盘" class="headerlink" title="绘制表盘"></a>绘制表盘</h3><p>表盘上只有60条分/秒刻线和12条小时刻线，当然还有表盘的外部轮廓圆，也就是重点在如何画72根线。先把简单的圆画出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">margin = <span class="number">5</span>  <span class="comment"># 上下左右边距</span></span><br><span class="line">radius = <span class="number">220</span>  <span class="comment"># 圆的半径</span></span><br><span class="line">center = (center_x, center_y) = (<span class="number">225</span>, <span class="number">225</span>)  <span class="comment"># 圆心</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 新建一个画板并填充成白色</span></span><br><span class="line">img = np.zeros((<span class="number">450</span>, <span class="number">450</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">img[:] = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 画出圆盘</span></span><br><span class="line">cv2.circle(img, center, radius, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_clock_blank_circle.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_clock_blank_circle.jpg" alt=""></picture></p><p>前面我们使用OpenCV画直线的时候，需知道直线的起点和终点坐标，那么画72根线就变成了获取72组坐标。</p><p>在平面坐标系下，已知半径和角度的话，A点的坐标可以表示为：<br>$$<br>\begin{matrix}<br>   x=r\times \cos\alpha \newline<br>   y=r\times \sin\alpha<br>\end{matrix}<br>$$<br><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_clock_center_shift.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_clock_center_shift.jpg" alt=""></picture></p><p>先只考虑将坐标系原点移动到左上角，角度依然是平面坐标系中的逆时针计算，那么新坐标是：</p><p>$$<br>\begin{matrix}<br>   x=r+r\times \cos\alpha \newline<br>   y=r+r\times \sin\alpha<br>\end{matrix}<br>$$</p><p>对于60条分/秒刻线，刻线间的夹角是360°/60=6°，对于小时刻线，角度是360°/12=30°，这样就得到了72组起点坐标，那怎么得到终点坐标呢？其实同样的原理，用一个同心的小圆来计算得到B点：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_clock_a_b_position.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_clock_a_b_position.jpg" alt=""></picture></p><p>通过A/B两点就可以画出直线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pt1 = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 画出60条秒和分钟的刻线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>):</span><br><span class="line">    <span class="comment"># 最外部圆，计算A点</span></span><br><span class="line">    x1 = center_x+(radius-margin)*math.cos(i*<span class="number">6</span>*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    y1 = center_y+(radius-margin)*math.sin(i*<span class="number">6</span>*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    pt1.append((int(x1), int(y1)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同心小圆，计算B点</span></span><br><span class="line">    x2 = center_x+(radius<span class="number">-15</span>)*math.cos(i*<span class="number">6</span>*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    y2 = center_y+(radius<span class="number">-15</span>)*math.sin(i*<span class="number">6</span>*np.pi/<span class="number">180.0</span>)</span><br><span class="line"></span><br><span class="line">    cv2.line(img, pt1[i], (int(x2), int(y2)), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 画出12条小时的刻线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    <span class="comment"># 12条小时刻线应该更长一点</span></span><br><span class="line">    x = center_x+(radius<span class="number">-25</span>)*math.cos(i*<span class="number">30</span>*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    y = center_y+(radius<span class="number">-25</span>)*math.sin(i*<span class="number">30</span>*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    <span class="comment"># 这里用到了前面的pt1</span></span><br><span class="line">    cv2.line(img, pt1[i*<span class="number">5</span>], (int(x), int(y)), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到这里基本的表盘图就已经画出来了</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_clock_blank_clock.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_clock_blank_clock.jpg" alt=""></picture></p><h3 id="角度换算"><a href="#角度换算" class="headerlink" title="角度换算"></a>角度换算</h3><p>接下来算是一个小难点，首先<strong>时钟的起始坐标在正常二维坐标系的90°方向，其次时钟跟图像一样，都是顺时针计算角度的</strong>，所以三者需要统一下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_clock_different_clock_contrast.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_clock_different_clock_contrast.jpg" alt=""></picture></p><p>因为角度是完全对称的，顺逆时针没有影响，所以平面坐标系完全不用理会，放在这里只是便于大家理解。对于时钟坐标和图像坐标，时钟0的0°对应图像的270°，时钟15的90°对应图像的360°，时钟30的180°对应图像的450°（360°+90°）…</p><p>所以两者之间的关系便是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算角度 &#x3D; 时钟角度+270°</span><br><span class="line">计算角度 &#x3D; 计算角度 if 计算角度&lt;&#x3D;360° else 计算角度-360°</span><br></pre></td></tr></table></figure><h3 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><p>Python中如何获取当前时间和添加日期文字都比较简单，看代码就行，我就不解释了。代码中角度计算我换了一种方式，其实是一样的，看你能不能看懂(●ˇ∀ˇ●)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 不断拷贝表盘图，才能更新绘制，不然会重叠在一起</span></span><br><span class="line">    temp = np.copy(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 获取系统时间，画出动态的时-分-秒三条刻线</span></span><br><span class="line">    now_time = datetime.datetime.now()</span><br><span class="line">    hour, minute, second = now_time.hour, now_time.minute, now_time.second</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画秒刻线</span></span><br><span class="line">    <span class="comment"># OpenCV中的角度是顺时针计算的，所以需要转换下</span></span><br><span class="line">    sec_angle = second*<span class="number">6</span>+<span class="number">270</span> <span class="keyword">if</span> second &lt;= <span class="number">15</span> <span class="keyword">else</span> (second<span class="number">-15</span>)*<span class="number">6</span></span><br><span class="line">    sec_x = center_x+(radius-margin)*math.cos(sec_angle*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    sec_y = center_y+(radius-margin)*math.sin(sec_angle*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    cv2.line(temp, center, (int(sec_x), int(sec_y)), (<span class="number">203</span>, <span class="number">222</span>, <span class="number">166</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画分刻线</span></span><br><span class="line">    min_angle = minute*<span class="number">6</span>+<span class="number">270</span> <span class="keyword">if</span> minute &lt;= <span class="number">15</span> <span class="keyword">else</span> (minute<span class="number">-15</span>)*<span class="number">6</span></span><br><span class="line">    min_x = center_x+(radius<span class="number">-35</span>)*math.cos(min_angle*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    min_y = center_y+(radius<span class="number">-35</span>)*math.sin(min_angle*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    cv2.line(temp, center, (int(min_x), int(min_y)), (<span class="number">186</span>, <span class="number">199</span>, <span class="number">137</span>), <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画时刻线</span></span><br><span class="line">    hour_angle = hour*<span class="number">30</span>+<span class="number">270</span> <span class="keyword">if</span> hour &lt;= <span class="number">3</span> <span class="keyword">else</span> (hour<span class="number">-3</span>)*<span class="number">30</span></span><br><span class="line">    hour_x = center_x+(radius<span class="number">-65</span>)*math.cos(hour_angle*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    hour_y = center_y+(radius<span class="number">-65</span>)*math.sin(hour_angle*np.pi/<span class="number">180.0</span>)</span><br><span class="line">    cv2.line(temp, center, (int(hour_x), int(hour_y)), (<span class="number">169</span>, <span class="number">198</span>, <span class="number">26</span>), <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 添加当前日期文字</span></span><br><span class="line">    font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">    time_str = now_time.strftime(<span class="string">"%d/%m/%Y"</span>)</span><br><span class="line">    cv2.putText(img, time_str, (<span class="number">135</span>, <span class="number">275</span>), font, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'clocking'</span>, temp)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:  <span class="comment"># 按下ESC键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_clock_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_clock_sample.jpg" alt=""></picture></p><p>本此挑战旨在锻炼一步步解决实际问题的思路（虽然有点数学知识(￣▽￣)”），大家再接再厉噢！</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A11%EF%BC%9A%E7%94%BB%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F" target="_blank" rel="noopener">本节源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;挑战任务：使用OpenCV绘制一个随系统时间动态变化的时钟。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="PyQt" scheme="http://www.codec.wang/tags/PyQt/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇6：鼠标绘图</title>
    <link href="http://www.codec.wang/opencv-python-extra-drawing-with-mouse/"/>
    <id>http://www.codec.wang/opencv-python-extra-drawing-with-mouse/</id>
    <published>2017-12-09T09:28:34.000Z</published>
    <updated>2020-04-07T04:53:41.991Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何用鼠标实时绘图。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>捕获鼠标事件</li><li>OpenCV函数：<code>cv2.setMouseCallback()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="知道鼠标在哪儿"><a href="#知道鼠标在哪儿" class="headerlink" title="知道鼠标在哪儿"></a>知道鼠标在哪儿</h3><p>OpenCV中，我们需要创建一个鼠标的回调函数来获取鼠标当前的位置、当前的事件如左键按下/左键释放或是右键单击等等，然后执行相应的功能。</p><p>使用<code>cv2.setMouseCallback()</code>来创建鼠标的回调函数，比如我们在左键单击的时候，打印出当前鼠标的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mouse_event</span><span class="params">(event, x, y, flags, param)</span>:</span></span><br><span class="line">    <span class="comment"># 通过event判断具体是什么事件，这里是左键按下</span></span><br><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">        print((x, y))</span><br><span class="line"></span><br><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line"><span class="comment"># 定义鼠标的回调函数</span></span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>, mouse_event)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>, img)</span><br><span class="line">    <span class="comment"># 按下ESC键退出</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">20</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>上面的代码先定义鼠标的回调函数<code>mouse_event()</code>，然后在回调函数中判断是否是左键单击事件 <code>EVENT_LBUTTONDOWN</code>，是的话就打印出坐标。需要注意的是，回调函数的参数格式是固定的，不要随意更改。</p><p>那除了左键单击之外，还有哪些事件呢？可以用下面的代码打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有的事件</span></span><br><span class="line">events = [i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> <span class="string">'EVENT'</span> <span class="keyword">in</span> i]</span><br><span class="line">print(events)</span><br></pre></td></tr></table></figure><h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><p>现在我们来实现一个综合的例子，这个实例会帮助你理解图像交互的一些思想：</p><p>在图像上用鼠标画图，可以画圆或矩形，按m键在两种模式下切换。左键按下时开始画图，移动到哪儿画到哪儿，左键释放时结束画图。听上去很复杂，是吗？一步步来看：</p><ul><li>用鼠标画图：需要定义鼠标的回调函数mouse_event</li><li>画圆或矩形：需要定义一个画图的模式mode</li><li>左键单击、移动、释放：需要捕获三个不同的事件</li><li>开始画图，结束画图：需要定义一个画图的标记位drawing</li></ul><p>好，开始coding吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">drawing = <span class="literal">False</span>  <span class="comment"># 是否开始画图</span></span><br><span class="line">mode = <span class="literal">True</span>  <span class="comment"># True：画矩形，False：画圆</span></span><br><span class="line">start = (<span class="number">-1</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mouse_event</span><span class="params">(event, x, y, flags, param)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> start, drawing, mode</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左键按下：开始画图</span></span><br><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing = <span class="literal">True</span></span><br><span class="line">        start = (x, y)</span><br><span class="line">    <span class="comment"># 鼠标移动，画图</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:</span><br><span class="line">        <span class="keyword">if</span> drawing:</span><br><span class="line">            <span class="keyword">if</span> mode:</span><br><span class="line">                cv2.rectangle(img, start, (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># 左键释放：结束画图</span></span><br><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_LBUTTONUP:</span><br><span class="line">        drawing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> mode:</span><br><span class="line">            cv2.rectangle(img, start, (x, y), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cv2.circle(img, (x, y), <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>, mouse_event)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>, img)</span><br><span class="line">    <span class="comment"># 按下m切换模式</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'m'</span>):</span><br><span class="line">        mode = <span class="keyword">not</span> mode</span><br><span class="line">    <span class="keyword">elif</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>效果应该如下图所示：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_mouse_drawing_rectangle_circle.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_mouse_drawing_rectangle_circle.jpg" alt=""></picture></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>要用鼠标绘图，需要用<code>cv2.setMouseCallback()</code>定义回调函数，然后在回调函数中根据不同的event事件，执行不同的功能。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1.（选做）实现用鼠标画矩形，跟实例差不多，但只实时画一个，类似下面动图：</p><p><img src="http://blog.codec.wang/cv2_live_draw_rectangle.gif" alt="实时画一个矩形"></p><p>2.（选做）做一个在白色面板上绘图的简单程序，可用滑动条调整颜色和笔刷大小。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8706.%20%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_mouse_handling/py_mouse_handling.html" target="_blank" rel="noopener">Mouse as a Paint-Brush</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何用鼠标实时绘图。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="绘图" scheme="http://www.codec.wang/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程8：绘图功能</title>
    <link href="http://www.codec.wang/opencv-python-drawing-function/"/>
    <id>http://www.codec.wang/opencv-python-drawing-function/</id>
    <published>2017-12-09T03:29:48.000Z</published>
    <updated>2020-04-07T04:44:26.210Z</updated>
    
    <content type="html"><![CDATA[<p>学习画线、圆和矩形等多种几何形状，给图片添加文字。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>绘制各种几何形状、添加文字</li><li>OpenCV函数：<code>cv2.line()</code>, <code>cv2.circle()</code>, <code>cv2.rectangle()</code>, <code>cv2.ellipse()</code>, <code>cv2.putText()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>绘制形状的函数有一些共同的参数，提前在此说明一下：</p><ul><li>img：要绘制形状的图片</li><li>color：绘制的颜色<ul><li>彩色图就传入BGR的一组值，如蓝色就是(255,0,0)</li><li>灰度图，传入一个灰度值就行</li></ul></li><li>thickness：线宽，默认为1；<strong>对于矩形/圆之类的封闭形状而言，传入-1表示填充形状</strong></li></ul><p>需要导入的模块和显示图片的通用代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'img'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_drawing_functions.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_drawing_functions.jpg" alt="绘制各种几何形状"></picture></p><p>上图就是本教程绘制的最终效果，下面一步步来看：</p><h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>画直线只需指定起点和终点的坐标就行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一副黑色的图片</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line"><span class="comment"># 画一条线宽为5的蓝色直线，参数2：起点，参数3：终点</span></span><br><span class="line">cv2.line(img, (<span class="number">0</span>, <span class="number">0</span>), (<span class="number">512</span>, <span class="number">512</span>), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：所有绘图函数均会直接影响原图片，这点要注意。</p></blockquote><h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>画矩形需要知道左上角和右下角的坐标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画一个绿色边框的矩形，参数2：左上角坐标，参数3：右下角坐标</span></span><br><span class="line">cv2.rectangle(img, (<span class="number">384</span>, <span class="number">0</span>), (<span class="number">510</span>, <span class="number">128</span>), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p>画圆需要指定圆心和半径，注意下面的例子中线宽=-1代表填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画一个填充红色的圆，参数2：圆心坐标，参数3：半径</span></span><br><span class="line">cv2.circle(img, (<span class="number">447</span>, <span class="number">63</span>), <span class="number">63</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>画椭圆需要的参数比较多，请对照后面的代码理解这几个参数：</p><ul><li>参数2：椭圆中心(x,y)</li><li>参数3：x/y轴的长度</li><li>参数4：angle—椭圆的旋转角度</li><li>参数5：startAngle—椭圆的起始角度</li><li>参数6：endAngle—椭圆的结束角度</li></ul><blockquote><p>经验之谈：OpenCV中原点在左上角，所以这里的角度是以顺时针方向计算的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在图中心画一个填充的半圆</span></span><br><span class="line">cv2.ellipse(img, (<span class="number">256</span>, <span class="number">256</span>), (<span class="number">100</span>, <span class="number">50</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h3 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h3><p>画多边形需要指定一系列多边形的顶点坐标，相当于从第一个点到第二个点画直线，再从第二个点到第三个点画直线….</p><p>OpenCV中需要先将多边形的顶点坐标需要变成顶点数×1×2维的矩阵，再来绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义四个顶点坐标</span></span><br><span class="line">pts = np.array([[<span class="number">10</span>, <span class="number">5</span>],  [<span class="number">50</span>, <span class="number">10</span>], [<span class="number">70</span>, <span class="number">20</span>], [<span class="number">20</span>, <span class="number">30</span>]], np.int32)</span><br><span class="line"><span class="comment"># 顶点个数：4，矩阵变成4*1*2维</span></span><br><span class="line">pts = pts.reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">cv2.polylines(img, [pts], <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure><p><code>cv2.polylines()</code>的参数3如果是False的话，多边形就不闭合。</p><blockquote><p>经验之谈：如果需要绘制多条直线，使用cv2.polylines()要比cv2.line()高效很多，例如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用cv2.polylines()画多条直线</span></span><br><span class="line">line1 = np.array([[<span class="number">100</span>, <span class="number">20</span>],  [<span class="number">300</span>, <span class="number">20</span>]], np.int32).reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">line2 = np.array([[<span class="number">100</span>, <span class="number">60</span>],  [<span class="number">300</span>, <span class="number">60</span>]], np.int32).reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">line3 = np.array([[<span class="number">100</span>, <span class="number">100</span>],  [<span class="number">300</span>, <span class="number">100</span>]], np.int32).reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">cv2.polylines(img, [line1, line2, line3], <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure><h3 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h3><p>使用<code>cv2.putText()</code>添加文字，它的参数也比较多，同样请对照后面的代码理解这几个参数：</p><ul><li>参数2：要添加的文本</li><li>参数3：文字的起始坐标（左下角为起点）</li><li>参数4：字体</li><li>参数5：文字大小（缩放比例）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加文字</span></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv2.putText(img, <span class="string">'ex2tron'</span>, (<span class="number">10</span>, <span class="number">500</span>), font,</span><br><span class="line">            <span class="number">4</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>, lineType=cv2.LINE_AA)</span><br></pre></td></tr></table></figure><p>字体可参考：<a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga0f9314ea6e35f99bb23f29567fc16e11" target="_blank" rel="noopener">HersheyFonts</a>。另外，这里有个线型lineType参数，LINE_AA表示抗锯齿线型，具体可见<a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>cv2.line()</code>画直线，<code>cv2.circle()</code>画圆，<code>cv2.rectangle()</code>画矩形，<code>cv2.ellipse()</code>画椭圆，<code>cv2.polylines()</code>画多边形，<code>cv2.putText()</code>添加文字。</li><li>画多条直线时，<code>cv2.polylines()</code>要比<code>cv2.line()</code>高效很多。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>你能用已学的绘图功能画出OpenCV的logo吗？(提示：椭圆和圆)</li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_draw_opencv_logo.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_draw_opencv_logo.jpg" alt="OpenCV logo"></picture></p><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2" target="_blank" rel="noopener">cv2.line()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670" target="_blank" rel="noopener">cv2.circle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9" target="_blank" rel="noopener">cv2.rectangle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga28b2267d35786f5f890ca167236cbc69" target="_blank" rel="noopener">cv2.ellipse()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576" target="_blank" rel="noopener">cv2.putText()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga1ea127ffbbb7e0bfc4fd6fd2eb64263c" target="_blank" rel="noopener">cv2.polylines()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/08.%20%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_drawing_functions/py_drawing_functions.html" target="_blank" rel="noopener">Drawing Functions in OpenCV</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习画线、圆和矩形等多种几何形状，给图片添加文字。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="绘图" scheme="http://www.codec.wang/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python-OpenCV教程番外篇5：仿射变换与透视变换</title>
    <link href="http://www.codec.wang/opencv-python-extra-warpaffine-warpperspective/"/>
    <id>http://www.codec.wang/opencv-python-extra-warpaffine-warpperspective/</id>
    <published>2017-12-08T07:36:53.000Z</published>
    <updated>2020-04-07T04:54:08.854Z</updated>
    
    <content type="html"><![CDATA[<p>常见的2D图像变换从原理上讲主要包括基于2×3矩阵的<a href="https://baike.baidu.com/item/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">仿射变换</a>和基于3×3矩阵<a href="https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">透视变换</a>。<a id="more"></a></p><hr><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>基本的图像变换就是二维坐标的变换：从一种二维坐标(x,y)到另一种二维坐标(u,v)的线性变换：</p><p>$$<br>\begin{matrix}<br>   u=a_1x+b_1y+c_1 \newline<br>   v=a_2x+b_2y+c_2<br>  \end{matrix}<br>$$<br>如果写成矩阵的形式，就是：<br>$$<br>\left[<br> \begin{matrix}<br>   u \newline<br>   v<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   a_1 &amp; b_1  \newline<br>   a_2 &amp; b_2<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y<br>  \end{matrix}<br>  \right]+\left[<br> \begin{matrix}<br>   c_1 \newline<br>   c_2<br>  \end{matrix}<br>  \right]<br>$$<br>作如下定义：<br>$$<br>R=\left[<br> \begin{matrix}<br>   a_1 &amp; b_1  \newline<br>   a_2 &amp; b_2<br>  \end{matrix}<br>  \right], t=\left[<br> \begin{matrix}<br>   c_1 \newline<br>   c_2<br>  \end{matrix}<br>  \right],T=\left[<br> \begin{matrix}<br>   R &amp; t<br>  \end{matrix}<br>  \right]<br>$$<br>矩阵T(2×3)就称为仿射变换的变换矩阵，R为线性变换矩阵，t为平移矩阵，简单来说，仿射变换就是线性变换+平移。变换后直线依然是直线，平行线依然是平行线，直线间的相对位置关系不变，因此<strong>非共线的三个对应点便可确定唯一的一个仿射变换</strong>，线性变换4个自由度+平移2个自由度→<strong>仿射变换自由度为6</strong>。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_warp_affine_image_sample_introduction2.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_warp_affine_image_sample_introduction2.jpg" alt=""></picture></p><p>来看下OpenCV中如何实现仿射变换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'drawing.jpg'</span>)</span><br><span class="line">rows, cols = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变换前的三个点</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>, <span class="number">65</span>], [<span class="number">150</span>, <span class="number">65</span>], [<span class="number">210</span>, <span class="number">210</span>]])</span><br><span class="line"><span class="comment"># 变换后的三个点</span></span><br><span class="line">pts2 = np.float32([[<span class="number">50</span>, <span class="number">100</span>], [<span class="number">150</span>, <span class="number">65</span>], [<span class="number">100</span>, <span class="number">250</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成变换矩阵</span></span><br><span class="line">M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line">dst = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img), plt.title(<span class="string">'input'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst), plt.title(<span class="string">'output'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>三个点我已经在图中标记了出来。用<code>cv2.getAffineTransform()</code>生成变换矩阵，接下来再用<code>cv2.warpAffine()</code>实现变换。</p><blockquote><p>思考：三个点我标记的是红色，为什么Matplotlib显示出来是下面这种颜色？（<a href="#练习">练习</a>）</p></blockquote><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_affine_transformation_drawing.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_affine_transformation_drawing.jpg" alt="仿射变换前后对比图"></picture></p><p>其实平移、旋转、缩放和翻转等变换就是对应了不同的仿射变换矩阵，下面分别来看下。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_image_transformation_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_image_transformation_sample.jpg" alt=""></picture></p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_warp_affine_shift_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_warp_affine_shift_sample.jpg" alt=""></picture></p><p>平移就是x和y方向上的直接移动，可以上下/左右移动，自由度为2，变换矩阵可以表示为：<br>$$<br>\left[<br> \begin{matrix}<br>   u \newline<br>   v<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   1 &amp; 0  \newline<br>   0 &amp; 1<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y<br>  \end{matrix}<br>  \right]+\left[<br> \begin{matrix}<br>   t_x \newline<br>   t_y<br>  \end{matrix}<br>  \right]<br>$$</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_warp_affine_rotation_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_warp_affine_rotation_sample.jpg" alt=""></picture></p><p>旋转是坐标轴方向饶原点旋转一定的角度θ，自由度为1，不包含平移，如顺时针旋转可以表示为：<br>$$<br>\left[<br> \begin{matrix}<br>   u \newline<br>   v<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   \cos \theta &amp; -\sin \theta \newline<br>   \sin \theta &amp; \cos \theta<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y<br>  \end{matrix}<br>  \right]+\left[<br> \begin{matrix}<br>   0 \newline<br>   0<br>  \end{matrix}<br>  \right]<br>$$</p><blockquote><p>思考：如果不是绕原点，而是可变点，自由度是多少呢？（请看下文刚体变换）</p></blockquote><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>翻转是x或y某个方向或全部方向上取反，自由度为2，比如这里以垂直翻转为例：<br>$$<br>\left[<br> \begin{matrix}<br>   u \newline<br>   v<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   1 &amp; 0 \newline<br>   0 &amp; -1<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y<br>  \end{matrix}<br>  \right]+\left[<br> \begin{matrix}<br>   0 \newline<br>   0<br>  \end{matrix}<br>  \right]<br>$$</p><h3 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h3><p>旋转+平移也称刚体变换（Rigid Transform），就是说如果<strong>图像变换前后两点间的距离仍然保持不变</strong>，那么这种变化就称为刚体变换。刚体变换包括了平移、旋转和翻转，自由度为3。变换矩阵可以表示为：</p><p>$$<br>\left[<br> \begin{matrix}<br>   u \newline<br>   v<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   \cos \theta &amp; -\sin \theta \newline<br>   \sin \theta &amp; \cos \theta<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y<br>  \end{matrix}<br>  \right]+\left[<br> \begin{matrix}<br>   t_x  \newline<br>   t_y<br>  \end{matrix}<br>  \right]<br>$$</p><p>由于只是旋转和平移，刚体变换保持了直线间的长度不变，所以也称欧式变换（变化前后保持欧氏距离）。</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_warp_affine_scale_sampel.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_warp_affine_scale_sampel.jpg" alt=""></picture></p><p>缩放是x和y方向的尺度（倍数）变换，在有些资料上非等比例的缩放也称为拉伸/挤压，等比例缩放自由度为1，非等比例缩放自由度为2，矩阵可以表示为：<br>$$<br>\left[<br> \begin{matrix}<br>   u \newline<br>   v<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   s_x &amp; 0 \newline<br>   0 &amp; s_y<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y<br>  \end{matrix}<br>  \right]+\left[<br> \begin{matrix}<br>   0 \newline<br>   0<br>  \end{matrix}<br>  \right]<br>$$</p><h3 id="相似变换"><a href="#相似变换" class="headerlink" title="相似变换"></a>相似变换</h3><p>相似变换又称缩放旋转，相似变换包含了旋转、等比例缩放和平移等变换，自由度为4。在OpenCV中，旋转就是用相似变换实现的：</p><p>若缩放比例为scale，旋转角度为θ，旋转中心是$ (center_x,center_y) $，则仿射变换可以表示为：</p><p>$$<br>\left[<br> \begin{matrix}<br>   u \newline<br>   v<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   \alpha &amp; \beta \newline<br>   -\beta &amp; \alpha<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y<br>  \end{matrix}<br>  \right]+\left[<br> \begin{matrix}<br>   (1-\alpha)center_x-\beta center_y \newline<br>   \beta center_x+(1-\alpha)center_y<br>  \end{matrix}<br>  \right]<br>$$<br>其中，<br>$$<br>\alpha=scale \cdot \cos \theta,\beta=scale \cdot \sin \theta<br>$$</p><p><strong>相似变换相比刚体变换加了缩放，所以并不会保持欧氏距离不变，但直线间的夹角依然不变。</strong></p><blockquote><p>经验之谈：OpenCV中默认按照逆时针旋转噢~</p></blockquote><p>总结一下（<a href="http://blog.codec.wang/cv2_transformation_matrix_dof_summary.jpg_webp" target="_blank" rel="noopener">原图[#计算机视觉：算法与应用p39]</a>）：</p><table><thead><tr><th align="center">变换</th><th align="center">矩阵</th><th align="center">自由度</th><th align="center">保持性质</th></tr></thead><tbody><tr><td align="center">平移</td><td align="center">[I, t]（2×3）</td><td align="center">2</td><td align="center">方向/长度/夹角/平行性/直线性</td></tr><tr><td align="center">刚体</td><td align="center">[R, t]（2×3）</td><td align="center">3</td><td align="center">长度/夹角/平行性/直线性</td></tr><tr><td align="center">相似</td><td align="center">[sR, t]（2×3）</td><td align="center">4</td><td align="center">夹角/平行性/直线性</td></tr><tr><td align="center">仿射</td><td align="center">[T]（2×3）</td><td align="center">6</td><td align="center">平行性/直线性</td></tr><tr><td align="center">透视</td><td align="center">[T]（3×3）</td><td align="center">8</td><td align="center">直线性</td></tr></tbody></table><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>前面仿射变换后依然是平行四边形，并不能做到任意的变换。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_warp_perspective_image_sample4.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_warp_perspective_image_sample4.jpg" alt=""></picture></p><p><a href="https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">透视变换</a>（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维→三维→二维的一个过程。<br>$$<br>\begin{matrix}<br>   X=a_1 x + b_1 y + c_1 \newline<br>   Y=a_2 x + b_2 y + c_2  \newline<br>   Z=a_3 x + b_3 y + c_3<br>  \end{matrix}<br>$$<br>这次我写成齐次矩阵的形式：<br>$$<br>\left[<br> \begin{matrix}<br>   X \newline<br>   Y \newline<br>   Z<br>  \end{matrix}<br>  \right]  = \left[<br> \begin{matrix}<br>   a_1 &amp; b_1 &amp; c_1  \newline<br>   a_2 &amp; b_2 &amp; c_2  \newline<br>   a_3 &amp; b_3 &amp; c_3<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \newline<br>   y \newline<br>   1<br>  \end{matrix}<br>  \right]<br>$$<br>其中，$ \left[<br> \begin{matrix}<br>   a_1 &amp; b_1   \newline<br>   a_2 &amp; b_2  \newline<br>  \end{matrix}<br>  \right]  $表示线性变换，$ \left[<br> \begin{matrix}<br>   a_3 &amp; b_3<br>  \end{matrix}<br>  \right]  $产生透视变换，其余表示平移变换，因此仿射变换是透视变换的子集。接下来再通过除以Z轴转换成二维坐标：<br>$$<br>x^{’}=\frac{X}{Z}=\frac{a_1x+b_1y+c_1}{a_3x+b_3y+c_3 }<br>$$</p><p>$$<br>y^{’}=\frac{Y}{Z}=\frac{a_2x+b_2y+c_2}{a_3x+b_3y+c_3 }<br>$$</p><p>透视变换相比仿射变换更加灵活，变换后会产生一个新的四边形，但不一定是平行四边形，所以需要<strong>非共线的四个点才能唯一确定</strong>，原图中的直线变换后依然是直线。因为四边形包括了所有的平行四边形，所以透视变换包括了所有的仿射变换。</p><p>OpenCV中首先根据变换前后的四个点用<code>cv2.getPerspectiveTransform()</code>生成3×3的变换矩阵，然后再用<code>cv2.warpPerspective()</code>进行透视变换。实战演练一下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_perspective_transformations_inm.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_perspective_transformations_inm.jpg" alt="矫正一鸣的卡片"></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'card.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原图中卡片的四个角点</span></span><br><span class="line">pts1 = np.float32([[<span class="number">148</span>, <span class="number">80</span>], [<span class="number">437</span>, <span class="number">114</span>], [<span class="number">94</span>, <span class="number">247</span>], [<span class="number">423</span>, <span class="number">288</span>]])</span><br><span class="line"><span class="comment"># 变换后分别在左上、右上、左下、右下四个点</span></span><br><span class="line">pts2 = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">320</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">178</span>], [<span class="number">320</span>, <span class="number">178</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成透视变换矩阵</span></span><br><span class="line">M = cv2.getPerspectiveTransform(pts1, pts2)</span><br><span class="line"><span class="comment"># 进行透视变换，参数3是目标图像大小</span></span><br><span class="line">dst = cv2.warpPerspective(img, M, (<span class="number">320</span>, <span class="number">178</span>))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img[:, :, ::<span class="number">-1</span>]), plt.title(<span class="string">'input'</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(dst[:, :, ::<span class="number">-1</span>]), plt.title(<span class="string">'output'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><p>代码中有个<code>img[:, :, ::-1]</code>还记得吗？忘记的话，请看<a href="#练习">练习</a>。</p></blockquote><p>当然，我们后面学习了特征提取之后，就可以自动识别角点了。透视变换是一项很酷的功能。比如我们经常会用手机去拍身份证和文件，无论你怎么拍，貌似都拍不正或者有边框。如果你使用过手机上面一些扫描类软件，比如”<a href="https://baike.baidu.com/item/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B" target="_blank" rel="noopener">扫描全能王</a>“，”<a href="https://baike.baidu.com/item/Office%20Lens" target="_blank" rel="noopener">Office Lens</a>“，它们能很好地矫正图片，这些软件就是应用透视变换实现的。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>请复习：<a href="/opencv-python-extra-using-matplotlib/">Matplotlib显示图像</a>。</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8705.%20%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E5%92%8C%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://blog.codec.wang/Computer%20Vision%EF%BC%9AAlgorithms%20and%20Applications.pdf" target="_blank" rel="noopener">计算机视觉：算法与应用</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">维基百科：仿射变换</a></li><li><a href="https://www.zhihu.com/question/20666664" target="_blank" rel="noopener">如何通俗地讲解「仿射变换」这个概念？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的2D图像变换从原理上讲主要包括基于2×3矩阵的&lt;a href=&quot;https://baike.baidu.com/item/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仿射变换&lt;/a&gt;和基于3×3矩阵&lt;a href=&quot;https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;透视变换&lt;/a&gt;。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="图像变换" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程7：图像几何变换</title>
    <link href="http://www.codec.wang/opencv-python-image-geometric-transformation/"/>
    <id>http://www.codec.wang/opencv-python-image-geometric-transformation/</id>
    <published>2017-12-08T06:36:53.000Z</published>
    <updated>2020-04-07T04:44:08.412Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何旋转、平移、缩放和翻转图片。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>实现旋转、平移和缩放图片</li><li>OpenCV函数：<code>cv2.resize()</code>, <code>cv2.flip()</code>, <code>cv2.warpAffine()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><blockquote><p>图像的几何变换从原理上看主要包括两种：基于2×3矩阵的仿射变换（平移、缩放、旋转和翻转等）、基于3×3矩阵的透视变换，感兴趣的小伙伴可参考<a href="/opencv-python-extra-warpaffine-warpperspective/">番外篇：仿射变换与透视变换</a>。</p></blockquote><h3 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h3><p>缩放就是调整图片的大小，使用<code>cv2.resize()</code>函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'drawing.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照指定的宽度、高度缩放图片</span></span><br><span class="line">res = cv2.resize(img, (<span class="number">132</span>, <span class="number">150</span>))</span><br><span class="line"><span class="comment"># 按照比例缩放，如x,y轴均放大一倍</span></span><br><span class="line">res2 = cv2.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'shrink'</span>, res), cv2.imshow(<span class="string">'zoom'</span>, res2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>我们也可以指定缩放方法<code>interpolation</code>，更专业点叫插值方法，默认是<code>INTER_LINEAR</code>，全部可以参考：<a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121" target="_blank" rel="noopener">InterpolationFlags</a></p><h3 id="翻转图片"><a href="#翻转图片" class="headerlink" title="翻转图片"></a>翻转图片</h3><p>镜像翻转图片，可以用<code>cv2.flip()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.flip(img, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其中，参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_flip_image_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_flip_image_sample.jpg" alt=""></picture></p><h3 id="平移图片"><a href="#平移图片" class="headerlink" title="平移图片"></a>平移图片</h3><p>要平移图片，我们需要定义下面这样一个矩阵，tx,ty是向x和y方向平移的距离：</p><p>$$<br> M = \left[<br> \begin{matrix}<br>   1 &amp; 0 &amp; t_x \newline<br>   0 &amp; 1 &amp; t_y<br>  \end{matrix}<br>  \right]<br>$$</p><p>平移是用仿射变换函数<code>cv2.warpAffine()</code>实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 平移图片</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">rows, cols = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义平移矩阵，需要是numpy的float32类型</span></span><br><span class="line"><span class="comment"># x轴平移100，y轴平移50</span></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>]])</span><br><span class="line"><span class="comment"># 用仿射变换实现平移</span></span><br><span class="line">dst = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'shift'</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_translation_100_50.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_translation_100_50.jpg" alt=""></picture></p><h3 id="旋转图片"><a href="#旋转图片" class="headerlink" title="旋转图片"></a>旋转图片</h3><p>旋转同平移一样，也是用仿射变换实现的，因此也需要定义一个变换矩阵。OpenCV直接提供了 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p><ul><li>参数1：图片的旋转中心</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5表示缩小一半</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 45°旋转图片并缩小一半</span></span><br><span class="line">M = cv2.getRotationMatrix2D((cols / <span class="number">2</span>, rows / <span class="number">2</span>), <span class="number">45</span>, <span class="number">0.5</span>)</span><br><span class="line">dst = cv2.warpAffine(img, M, (cols, rows))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'rotation'</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_rotation_45_degree.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_rotation_45_degree.jpg" alt="逆时针旋转45°并缩放"></picture></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>cv2.resize()</code>缩放图片，可以按指定大小缩放，也可以按比例缩放。</li><li><code>cv2.flip()</code>翻转图片，可以指定水平/垂直/水平垂直翻转三种方式。</li><li>平移/旋转是靠仿射变换<code>cv2.warpAffine()</code>实现的。</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d" target="_blank" rel="noopener">cv2.resize()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gaca7be533e3dac7feb70fc60635adf441" target="_blank" rel="noopener">cv2.filp()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" target="_blank" rel="noopener">cv2.warpAffine()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326" target="_blank" rel="noopener">cv2.getRotationMatrix2D()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/07.%20%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_geometric_transformations/py_geometric_transformations.html" target="_blank" rel="noopener">Geometric Transformations of Images</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何旋转、平移、缩放和翻转图片。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="几何变换" scheme="http://www.codec.wang/tags/%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇4：Otsu阈值法</title>
    <link href="http://www.codec.wang/opencv-python-extra-otsu-thresholding/"/>
    <id>http://www.codec.wang/opencv-python-extra-otsu-thresholding/</id>
    <published>2017-12-08T04:48:05.000Z</published>
    <updated>2020-04-07T04:54:28.424Z</updated>
    
    <content type="html"><![CDATA[<p>大部分图像处理任务都需要先进行二值化操作，阈值的选取很关键，Otsu阈值法会自动计算阈值。<a id="more"></a></p><p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>（日本人大津展之提出的，也可称大津算法）非常适用于双峰图片，啥意思呢？</p><blockquote><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4310076" target="_blank" rel="noopener">Otsu N. A threshold selection method from gray-level histograms[J]. IEEE transactions on systems, man, and cybernetics, 1979, 9(1): 62-66.</a></p></blockquote><hr><h2 id="什么是双峰图片？"><a href="#什么是双峰图片？" class="headerlink" title="什么是双峰图片？"></a>什么是双峰图片？</h2><p>双峰图片就是指图片的灰度直方图上有两个峰值，直方图就是每个值（0~255）的像素点个数统计，后面会详细介绍。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_bimodal_image_two_peaks.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_bimodal_image_two_peaks.jpg" alt=""></picture></p><p>Otsu算法假设这副图片由前景色和背景色组成，通过统计学方法（最大类间方差）选取一个阈值，将前景和背景尽可能分开，我们先来看下代码，然后详细说明下算法原理。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面这段代码对比了使用固定阈值和Otsu阈值后的不同结果：</p><p>另外，对含噪点的图像，先进行滤波操作效果会更好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'noisy.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定阈值法</span></span><br><span class="line">ret1, th1 = cv2.threshold(img, <span class="number">100</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Otsu阈值法</span></span><br><span class="line">ret2, th2 = cv2.threshold(img, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先进行高斯滤波，再使用Otsu阈值法</span></span><br><span class="line">blur = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">ret3, th3 = cv2.threshold(blur, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br></pre></td></tr></table></figure><p>下面我们用Matplotlib把原图、直方图和阈值图都显示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">images = [img, <span class="number">0</span>, th1, img, <span class="number">0</span>, th2, blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">'Original'</span>, <span class="string">'Histogram'</span>, <span class="string">'Global(v=100)'</span>,</span><br><span class="line">          <span class="string">'Original'</span>, <span class="string">'Histogram'</span>, <span class="string">"Otsu's"</span>,</span><br><span class="line">          <span class="string">'Gaussian filtered Image'</span>, <span class="string">'Histogram'</span>, <span class="string">"Otsu's"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 绘制原图</span></span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i * <span class="number">3</span>], <span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span>], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制直方图plt.hist，ravel函数将数组降成一维</span></span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">2</span>)</span><br><span class="line">    plt.hist(images[i * <span class="number">3</span>].ravel(), <span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">1</span>], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制阈值图</span></span><br><span class="line">    plt.subplot(<span class="number">3</span>, <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">3</span>)</span><br><span class="line">    plt.imshow(images[i * <span class="number">3</span> + <span class="number">2</span>], <span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i * <span class="number">3</span> + <span class="number">2</span>], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_otsu_vs_simple_thresholding.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_otsu_vs_simple_thresholding.jpg" alt="固定阈值 vs Otsu阈值"></picture></p><p>可以看到，Otsu阈值明显优于固定阈值，省去了不断尝试阈值判断效果好坏的过程。其中，绘制直方图时，使用了numpy中的<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">ravel()</a>函数，它会将原矩阵压缩成一维数组，便于画直方图。</p><h2 id="Otsu算法详解"><a href="#Otsu算法详解" class="headerlink" title="Otsu算法详解"></a>Otsu算法详解</h2><p>Otsu阈值法将整幅图分为前景（目标）和背景，以下是一些符号规定：</p><ul><li>$ T $：分割阈值</li><li>$ N_0 $：前景像素点数</li><li>$ N_1 $：背景像素点数</li><li>$ \omega_0 $：前景的像素点数占整幅图像的比例</li><li>$ \omega_1 $：背景的像素点数占整幅图像的比例</li><li>$ \mu_0 $：前景的平均像素值</li><li>$ \mu_1 $：背景的平均像素值</li><li>$ \mu $：整幅图的平均像素值</li><li>$ rows\times cols $：图像的行数和列数</li></ul><p>结合下图会更容易理解一些，有一副大小为4×4的图片，假设阈值T为1，那么：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_otsu_theory_sample.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_otsu_theory_sample.jpg" alt=""></picture></p><p>其实很好理解，$ N_0+N_1 $就是总的像素点个数，也就是行数乘列数：<br>$$<br>N_0+N_1=rows\times cols<br>$$<br>$ \omega_0 $和$ \omega_1 $是前/背景所占的比例，也就是：<br>$$<br>\omega_0=\frac{N_0}{rows\times cols}<br>$$<br>$$<br>\omega_1=\frac{N_1}{rows\times cols}<br>$$<br>$$<br>\omega_0+\omega_1=1 \tag{1}<br>$$<br>整幅图的平均像素值就是：<br>$$<br>\mu=\omega_0\times \mu_0+\omega_1\times \mu_1  \tag{2}<br>$$</p><p>此时，我们定义一个前景$ \mu_0 $与背景$ \mu_1 $的方差$ g $：</p><p>$$<br>g=\omega_0(\mu_0-\mu)^2+\omega_1(\mu_1-\mu)^2  \tag{3}<br>$$</p><p>将前述的1/2/3公式整合在一起，便是：</p><p>$$<br>g=\omega_0\omega_1(\mu_0-\mu_1)^2<br>$$</p><p><strong>$ g $就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别也就越大，效果越好。Otsu算法便是遍历阈值T，使得$ g $最大，所以又称为最大类间方差法。</strong>基本上双峰图片的阈值T在两峰之间的谷底。</p><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv2.GaussianBlur()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8704.%20Otsu%E9%98%88%E5%80%BC%E6%B3%95" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">numpy.ravel</a></li><li><a href="https://en.wikipedia.org/wiki/Otsu%27s_method" target="_blank" rel="noopener">Otsu’s Method(wikipedia)</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li><li><a href="https://blog.csdn.net/u011776903/article/details/73274802" target="_blank" rel="noopener">一维OTSU法、最小交叉熵法、二维OTSU法及C++源码</a></li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4310076" target="_blank" rel="noopener">Otsu N. A threshold selection method from gray-level histograms[J]. IEEE transactions on systems, man, and cybernetics, 1979, 9(1): 62-66.</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分图像处理任务都需要先进行二值化操作，阈值的选取很关键，Otsu阈值法会自动计算阈值。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="阈值" scheme="http://www.codec.wang/tags/%E9%98%88%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程6：阈值分割</title>
    <link href="http://www.codec.wang/opencv-python-image-thresholding/"/>
    <id>http://www.codec.wang/opencv-python-image-thresholding/</id>
    <published>2017-12-07T13:14:44.000Z</published>
    <updated>2020-04-07T04:43:45.351Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用不同的阈值方法”二值化”图像。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>使用固定阈值、自适应阈值和Otsu阈值法”二值化”图像</li><li>OpenCV函数：<code>cv2.threshold()</code>, <code>cv2.adaptiveThreshold()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h3><p>固定阈值分割很直接，一句话说就是像素点值大于阈值变成一类值，小于阈值变成另一类值。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_threshold_binary_demo.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_threshold_binary_demo.jpg" alt=""></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度图读入</span></span><br><span class="line">img = cv2.imread(<span class="string">'gradient.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阈值分割</span></span><br><span class="line">ret, th = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">cv2.imshow(<span class="string">'thresh'</span>, th)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p><ul><li>参数1：要处理的原图，<strong>一般是灰度图</strong></li><li>参数2：设定的阈值</li><li>参数3：最大阈值，一般为255</li><li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">ThresholdTypes</a></li></ul><p>下面结合代码理解下这5种阈值方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用5种不同的阈值方法</span></span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">ret, th2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line">ret, th3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TRUNC)</span><br><span class="line">ret, th4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO)</span><br><span class="line">ret, th5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_TOZERO_INV)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original'</span>, <span class="string">'BINARY'</span>, <span class="string">'BINARY_INV'</span>, <span class="string">'TRUNC'</span>, <span class="string">'TOZERO'</span>, <span class="string">'TOZERO_INV'</span>]</span><br><span class="line">images = [img, th1, th2, th3, th4, th5]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Matplotlib显示</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    plt.imshow(images[i], <span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])  <span class="comment"># 隐藏坐标轴</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_different_threshold_demo.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_different_threshold_demo.jpg" alt="5种不同的阈值方式结果"></picture></p><blockquote><p>经验之谈：很多人误以为阈值分割就是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%80%BC%E5%8C%96" target="_blank" rel="noopener">二值化</a>。从上图中可以发现，两者并不等同，阈值分割结果是两类值，而不是两个值，所以教程开头我把二值化加了引号。</p></blockquote><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_different_thresholds_theory.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_different_thresholds_theory.jpg" alt=""></picture></p><h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<em>它并不适用于明暗分布不均的图片</em>。 <code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。它有5个参数，其实很好理解，先看下效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自适应阈值对比固定阈值</span></span><br><span class="line">img = cv2.imread(<span class="string">'sudoku.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定阈值</span></span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 自适应阈值</span></span><br><span class="line">th2 = cv2.adaptiveThreshold(</span><br><span class="line">    img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">4</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(</span><br><span class="line">    img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">17</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">titles = [<span class="string">'Original'</span>, <span class="string">'Global(v = 127)'</span>, <span class="string">'Adaptive Mean'</span>, <span class="string">'Adaptive Gaussian'</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">'gray'</span>)</span><br><span class="line">    plt.title(titles[i], fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_adaptive_vs_global_thresholding.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_adaptive_vs_global_thresholding.jpg" alt="自适应阈值对比固定阈值"></picture></p><ul><li>参数1：要处理的原图</li><li>参数2：最大阈值，一般为255</li><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方式（跟前面讲的那5种相同）</li><li>参数5：小区域的面积，如11就是11*11的小块</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><p>如果你没看懂上面的参数也不要紧，暂时会用就行，当然我建议你调整下参数看看不同的结果。</p><h3 id="Otsu阈值"><a href="#Otsu阈值" class="headerlink" title="Otsu阈值"></a>Otsu阈值</h3><p>在前面固定阈值中，我们是随便选了一个阈值如127，那如何知道我们选的这个阈值效果好不好呢？答案是：不断尝试，所以这种方法在很多文献中都被称为经验阈值。<a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>就提供了一种自动高效的二值化方法，不过我们直方图还没学，这里暂时略过。</p><p>好吧，我知道我激起了你的兴趣，~ o(<em>￣▽￣</em>)o，有能力的童鞋可以看下<a href="#练习">练习题</a>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>cv2.threshold()</code>用来进行固定阈值分割。固定阈值不适用于光线不均匀的图片，所以用 <code>cv2.adaptiveThreshold()</code>进行自适应阈值分割。</li><li>二值化跟阈值分割并不等同。针对不同的图片，可以采用不同的阈值方法。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>Otsu阈值是一种高效的二值化算法，请阅读<a href="/opencv-python-extra-otsu-thresholding/">番外篇：Otsu阈值法</a></li></ol><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57" target="_blank" rel="noopener">cv2.threshold()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3" target="_blank" rel="noopener">cv2.adaptiveThreshold()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/06.%20%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用不同的阈值方法”二值化”图像。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="阈值" scheme="http://www.codec.wang/tags/%E9%98%88%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程5：颜色空间转换</title>
    <link href="http://www.codec.wang/opencv-python-changing-colorspaces/"/>
    <id>http://www.codec.wang/opencv-python-changing-colorspaces/</id>
    <published>2017-12-07T07:21:19.000Z</published>
    <updated>2020-04-07T04:43:13.915Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何进行图片的颜色空间转换，视频中追踪特定颜色的物体。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>颜色空间转换，如BGR↔Gray，BGR↔HSV等</li><li>追踪视频中特定颜色的物体</li><li>OpenCV函数：<code>cv2.cvtColor()</code>, <code>cv2.inRange()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line"><span class="comment"># 转换为灰度图</span></span><br><span class="line">img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'img'</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">'gray'</span>, img_gray)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>cv2.cvtColor()</code>用来进行颜色模型转换，参数1是要转换的图片，参数2是转换模式， <code>COLOR_BGR2GRAY</code>表示BGR→Gray，可用下面的代码显示所有的转换模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> i.startswith(<span class="string">'COLOR_'</span>)]</span><br><span class="line">print(flags)</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R*0.299+G*0.587+B*0.114</code>。</p></blockquote><h3 id="视频中特定颜色物体追踪"><a href="#视频中特定颜色物体追踪" class="headerlink" title="视频中特定颜色物体追踪"></a>视频中特定颜色物体追踪</h3><p><a href="https://baike.baidu.com/item/HSV/547122" target="_blank" rel="noopener">HSV</a>是一个常用于颜色识别的模型，相比BGR更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p><blockquote><p>经验之谈：OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p></blockquote><p>现在，我们实现一个使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p><ol><li>捕获视频中的一帧</li><li>从BGR转换到HSV</li><li>提取蓝色范围的物体</li><li>只显示蓝色物体</li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_blue_object_tracking.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_blue_object_tracking.jpg" alt="跟踪视频中的蓝色物体"></picture></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 蓝色的范围，不同光照条件下不一样，可灵活调整</span></span><br><span class="line">lower_blue = np.array([<span class="number">100</span>, <span class="number">110</span>, <span class="number">110</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">130</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 1.捕获视频中的一帧</span></span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.从BGR转换到HSV</span></span><br><span class="line">    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.inRange()：介于lower/upper之间的为白色，其余黑色</span></span><br><span class="line">    mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.只保留原图中的蓝色部分</span></span><br><span class="line">    res = cv2.bitwise_and(frame, frame, mask=mask)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>, frame)</span><br><span class="line">    cv2.imshow(<span class="string">'mask'</span>, mask)</span><br><span class="line">    cv2.imshow(<span class="string">'res'</span>, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>其中，<code>bitwise_and()</code>函数暂时不用管，后面会讲到。那蓝色的HSV值的上下限lower和upper范围是怎么得到的呢？其实很简单，我们先把标准蓝色的BGR值用<code>cvtColor()</code>转换下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blue = np.uint8([[[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]]])</span><br><span class="line">hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV)</span><br><span class="line">print(hsv_blue)  <span class="comment"># [[[120 255 255]]]</span></span><br></pre></td></tr></table></figure><p>结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。</p><blockquote><p>经验之谈：<a href="https://baike.baidu.com/item/Lab/1514615" target="_blank" rel="noopener">Lab</a>颜色空间也经常用来做颜色识别，有兴趣的同学可以了解下。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>cv2.cvtColor()</code>函数用来进行颜色空间转换，常用BGR↔Gray，BGR↔HSV。</li><li>HSV颜色模型常用于颜色识别。要想知道某种颜色在HSV下的值，可以将它的BGR值用<code>cvtColor()</code>转换得到。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>尝试在视频中同时提取红色、蓝色、绿色的物体。（效果如下）</li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_exercise_tracking_three_colors.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_exercise_tracking_three_colors.jpg" alt="同时追踪3种颜色"></picture></p><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981" target="_blank" rel="noopener">cv2.inRange()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14" target="_blank" rel="noopener">cv2.bitwise_and()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/05.%20%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html" target="_blank" rel="noopener">Changing Colorspaces</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何进行图片的颜色空间转换，视频中追踪特定颜色的物体。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="HSV" scheme="http://www.codec.wang/tags/HSV/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程4：图像基本操作</title>
    <link href="http://www.codec.wang/opencv-python-basic-operations/"/>
    <id>http://www.codec.wang/opencv-python-basic-operations/</id>
    <published>2017-12-07T04:13:15.000Z</published>
    <updated>2020-04-07T04:42:36.501Z</updated>
    
    <content type="html"><![CDATA[<p>学习获取和修改像素点的值，ROI感兴趣区域，通道分离合并等基本操作。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>访问和修改图片像素点的值</li><li>获取图片的宽、高、通道数等属性</li><li>了解感兴趣区域ROI</li><li>分离和合并图像通道</li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h3><p>我们先读入一张图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br></pre></td></tr></table></figure><p>通过行列的坐标来获取某像素点的值，对于彩色图，结果是B,G,R三个值的列表，对于灰度图或单通道图，只有一个值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">px = img[<span class="number">100</span>, <span class="number">90</span>]</span><br><span class="line">print(px)  <span class="comment"># [103 98 197]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只获取蓝色blue通道的值</span></span><br><span class="line">px_blue = img[<span class="number">100</span>, <span class="number">90</span>, <span class="number">0</span>]</span><br><span class="line">print(px_blue)  <span class="comment"># 103</span></span><br></pre></td></tr></table></figure><p>还记得吗？行对应y，列对应x，所以其实是<code>img[y, x]</code>，需要注意噢(●ˇ∀ˇ●)。容易混淆的话，可以只记行和列，行在前，列在后。</p><p>修改像素的值也是同样的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img[<span class="number">100</span>, <span class="number">90</span>] = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]</span><br><span class="line">print(img[<span class="number">100</span>, <span class="number">90</span>])  <span class="comment"># [255 255 255]</span></span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：还有一种性能更好的方式，获取：<code>img.item(100,100,0)</code>，修改：<code>img.itemset((100,100,0),255)</code>，但这种方式只能B,G,R逐一进行。</p></blockquote><p>注意：这步操作只是内存中的img像素点值变了，因为没有保存，所以原图并没有更改。</p><h3 id="图片属性"><a href="#图片属性" class="headerlink" title="图片属性"></a>图片属性</h3><p><code>img.shape</code>获取图像的形状，图片是彩色的话，返回一个包含<strong>行数（高度）、列数（宽度）和通道数</strong>的元组，灰度图只返回行数和列数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(img.shape)  <span class="comment"># (263, 247, 3)</span></span><br><span class="line"><span class="comment"># 形状中包括行数、列数和通道数</span></span><br><span class="line">height, width, channels = img.shape</span><br><span class="line"><span class="comment"># img是灰度图的话：height, width = img.shape</span></span><br></pre></td></tr></table></figure><p><code>img.dtype</code>获取图像数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(img.dtype)  <span class="comment"># uint8</span></span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：多数错误是因为数据类型不对导致的，所以健壮的代码应该对这个属性加以判断。</p></blockquote><p><code>img.size</code>获取图像总像素数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(img.size)  <span class="comment"># 263*247*3=194883</span></span><br></pre></td></tr></table></figure><h3 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h3><p><a href="https://baike.baidu.com/item/ROI/1125333#viewPageContent" target="_blank" rel="noopener">ROI</a>：Region of Interest，感兴趣区域。什么意思呢？比如我们要检测眼睛，因为眼睛肯定在脸上，所以我们感兴趣的只有脸这部分，其他都不care，所以可以单独把脸截取出来，这样就可以大大节省计算量，提高运行速度。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_lena_face_roi_crop.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_lena_face_roi_crop.jpg" alt="只关心脸( ╯□╰ )"></picture></p><p>截取ROI非常简单，指定图片的范围即可（后面我们学了特征后，就可以自动截取辣，(ง •_•)ง）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取脸部ROI</span></span><br><span class="line">face = img[<span class="number">100</span>:<span class="number">200</span>, <span class="number">115</span>:<span class="number">188</span>]</span><br><span class="line">cv2.imshow(<span class="string">'face'</span>, face)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="通道分割与合并"><a href="#通道分割与合并" class="headerlink" title="通道分割与合并"></a>通道分割与合并</h3><p>彩色图的BGR三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用<code>cv2.split()</code>和<code>cv2.merge()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b, g, r = cv2.split(img)</span><br><span class="line">img = cv2.merge((b, g, r))</span><br></pre></td></tr></table></figure><p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = img[:, :, <span class="number">0</span>]</span><br><span class="line">cv2.imshow(<span class="string">'blue'</span>, b)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>img[y,x]</code>获取/设置像素点值，<code>img.shape</code>：图片的形状（行数、列数、通道数）,<code>img.dtype</code>：图像的数据类型。</li><li><code>img[y1:y2,x1:x2]</code>进行ROI截取，<code>cv2.split()/cv2.merge()</code>通道分割/合并。更推荐的获取单通道方式：<code>b = img[:, :, 0]</code>。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>打开lena.jpg，将帽子部分（高：25<del>120，宽：50</del>220）的红色通道截取出来并显示。</li></ol><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga0547c7fed86152d7e9d0096029c8518a" target="_blank" rel="noopener">cv2.split()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga7d7b4d6c6ee504b30a20b1680029c7b4" target="_blank" rel="noopener">cv2.merge()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/04.%20%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html#basic-ops" target="_blank" rel="noopener">Basic Operations on Images</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习获取和修改像素点的值，ROI感兴趣区域，通道分离合并等基本操作。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="ROI" scheme="http://www.codec.wang/tags/ROI/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇3：滑动条</title>
    <link href="http://www.codec.wang/opencv-python-extra-trackbar/"/>
    <id>http://www.codec.wang/opencv-python-extra-trackbar/</id>
    <published>2017-12-06T14:23:11.000Z</published>
    <updated>2020-04-07T04:54:38.499Z</updated>
    
    <content type="html"><![CDATA[<p>学习使用滑动条动态调整参数。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="滑动条的使用"><a href="#滑动条的使用" class="headerlink" title="滑动条的使用"></a>滑动条的使用</h2><p>首先我们需要创建一个滑动条，如<code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code>，其中</p><ul><li>参数1：滑动条的名称</li><li>参数2：所在窗口的名称</li><li>参数3：当前的值</li><li>参数4：最大值</li><li>参数5：回调函数名称，回调函数默认有一个表示当前值的参数</li></ul><p>创建好之后，可以在回调函数中获取滑动条的值，也可以用：<code>cv2.getTrackbarPos()</code>得到，其中，参数1是滑动条的名称，参数2是窗口的名称。</p><h2 id="RGB调色板"><a href="#RGB调色板" class="headerlink" title="RGB调色板"></a>RGB调色板</h2><p>下面我们实现一个RGB的调色板，理解下滑动条的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回调函数，x表示滑块的位置，本例暂不使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">img = np.zeros((<span class="number">300</span>, <span class="number">512</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建RGB三个滑动条</span></span><br><span class="line">cv2.createTrackbar(<span class="string">'R'</span>, <span class="string">'image'</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'G'</span>, <span class="string">'image'</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line">cv2.createTrackbar(<span class="string">'B'</span>, <span class="string">'image'</span>, <span class="number">0</span>, <span class="number">255</span>, nothing)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    cv2.imshow(<span class="string">'image'</span>, img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取滑块的值</span></span><br><span class="line">    r = cv2.getTrackbarPos(<span class="string">'R'</span>, <span class="string">'image'</span>)</span><br><span class="line">    g = cv2.getTrackbarPos(<span class="string">'G'</span>, <span class="string">'image'</span>)</span><br><span class="line">    b = cv2.getTrackbarPos(<span class="string">'B'</span>, <span class="string">'image'</span>)</span><br><span class="line">    <span class="comment"># 设定img的颜色</span></span><br><span class="line">    img[:] = [b, g, r]</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_track_bar_rgb.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_track_bar_rgb.jpg" alt=""></picture></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>cv2.createTrackbar()</code>用来创建滑动条，可以在回调函数中或使用<code>cv2.getTrackbarPos()</code>得到滑块的位置</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#gaf78d2155d30b728fc413803745b67a9b" target="_blank" rel="noopener">cv2.createTrackbar()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga122632e9e91b9ec06943472c55d9cda8" target="_blank" rel="noopener">cv2.getTrackbarPos()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8703.%20%E6%BB%91%E5%8A%A8%E6%9D%A1" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_trackbar/py_trackbar.html" target="_blank" rel="noopener">Trackbar as the Color Palette</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习使用滑动条动态调整参数。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="滑动条" scheme="http://www.codec.wang/tags/%E6%BB%91%E5%8A%A8%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程3：打开摄像头</title>
    <link href="http://www.codec.wang/opencv-python-open-camera/"/>
    <id>http://www.codec.wang/opencv-python-open-camera/</id>
    <published>2017-12-06T08:38:02.000Z</published>
    <updated>2019-05-02T15:09:34.866Z</updated>
    
    <content type="html"><![CDATA[<p>学习打开摄像头捕获照片、播放本地视频、录制视频等。<a id="more"></a>图片/视频等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>打开摄像头并捕获照片</li><li>播放本地视频，录制视频</li><li>OpenCV函数：<code>cv2.VideoCapture()</code>, <code>cv2.VideoWriter()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h3><p>要使用摄像头，需要使用<code>cv2.VideoCapture(0)</code>创建VideoCapture对象，参数0指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第2个摄像头就可以传入1，依此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开摄像头并灰度化显示</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 获取一帧</span></span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line">    <span class="comment"># 将这帧转换为灰度图</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><code>capture.read()</code>函数返回的第1个参数ret(return value缩写)是一个布尔值，表示当前这一帧是否获取正确。<code>cv2.cvtColor()</code>用来转换颜色，这里将彩色图转成灰度图。</p><p>另外，通过<code>cap.get(propId)</code>可以获取摄像头的一些属性，比如捕获的分辨率，亮度和对比度等。propId是从0~18的数字，代表不同的属性，完整的属性列表可以参考：<a href="https://docs.opencv.org/4.0.0/d4/d15/group__videoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d" target="_blank" rel="noopener">VideoCaptureProperties</a>。也可以使用<code>cap.set(propId,value)</code>来修改属性值。比如说，我们在while之前添加下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取捕获的分辨率</span></span><br><span class="line"><span class="comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span></span><br><span class="line">width, height = capture.get(<span class="number">3</span>), capture.get(<span class="number">4</span>)</span><br><span class="line">print(width, height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以原分辨率的一倍来捕获</span></span><br><span class="line">capture.set(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="number">2</span>)</span><br><span class="line">capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到。</p></blockquote><h3 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a>播放本地视频</h3><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>cv2.waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为25或30。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 播放本地视频</span></span><br><span class="line">capture = cv2.VideoCapture(<span class="string">'demo_video.mp4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">30</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h3><p>之前我们保存图片用的是<code>cv2.imwrite()</code>，要保存视频，我们需要创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：</p><ul><li>输出的文件名，如’output.avi’</li><li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin" target="_blank" rel="noopener">FourCC</a>码</li><li>帧率<a href="https://baike.baidu.com/item/FPS/3227416" target="_blank" rel="noopener">FPS</a></li><li>要保存的分辨率大小</li></ul><p>FourCC是用来指定视频编码方式的四字节码，所有的编码可参考<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs</a>。如MJPG编码可以这样写： <code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编码方式并创建VideoWriter对象</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'MJPG'</span>)</span><br><span class="line">outfile = cv2.VideoWriter(<span class="string">'output.avi'</span>, fourcc, <span class="number">25.</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(capture.isOpened()):</span><br><span class="line">    ret, frame = capture.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        outfile.write(frame)  <span class="comment"># 写入文件</span></span><br><span class="line">        cv2.imshow(<span class="string">'frame'</span>, frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>使用<code>cv2.VideoCapture()</code>创建视频对象，然后在循环中一帧帧显示图像。参数传入数字时，代表打开摄像头，传入本地视频路径时，表示播放本地视频。</li><li><code>cap.get(propId)</code>获取视频属性，<code>cap.set(propId,value)</code>设置视频属性。</li><li><code>cv2.VideoWriter()</code>创建视频写入对象，用来录制/保存视频。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>请先阅读<a href="/opencv-python-extra-trackbar/">番外篇：滑动条</a>，然后实现一个可以拖动滑块播放视频的功能。（提示：需要用到 <code>cv2.CAP_PROP_FRAME_COUNT</code>和<code>cv2.CAP_PROP_POS_FRAMES</code>两个属性）。</li></ol><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html" target="_blank" rel="noopener">VideoCapture Object</a></li><li><a href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html" target="_blank" rel="noopener">VideoWriter Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/03.%20%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs by FOURCC</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html" target="_blank" rel="noopener">Getting Started with Videos</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习打开摄像头捕获照片、播放本地视频、录制视频等。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇2：无损保存和Matplotlib使用</title>
    <link href="http://www.codec.wang/opencv-python-extra-high-quality-save-and-using-matplotlib/"/>
    <id>http://www.codec.wang/opencv-python-extra-high-quality-save-and-using-matplotlib/</id>
    <published>2017-12-06T07:55:15.000Z</published>
    <updated>2020-04-07T04:55:18.324Z</updated>
    
    <content type="html"><![CDATA[<p>了解常用图片格式和OpenCV高质量保存图片的方式，学习如何使用Matplotlib显示OpenCV图像。<a id="more"></a></p><hr><h2 id="无损保存"><a href="#无损保存" class="headerlink" title="无损保存"></a>无损保存</h2><p>事实上，我们日常看到的大部分图片都是压缩过的，那么都有哪些常见的图片格式呢？</p><h3 id="常用图片格式"><a href="#常用图片格式" class="headerlink" title="常用图片格式"></a>常用图片格式</h3><ul><li><p><a href="https://baike.baidu.com/item/BMP/35116" target="_blank" rel="noopener">bmp</a></p><ul><li>全称：Bitmap</li><li><strong>不压缩</strong></li></ul></li><li><p><a href="https://baike.baidu.com/item/JPEG" target="_blank" rel="noopener">jpg</a></p><ul><li>全称：Joint Photographic Experts Group</li><li><strong>有损压缩方式</strong></li></ul></li><li><p><a href="https://baike.baidu.com/item/PNG" target="_blank" rel="noopener">png</a></p><ul><li>全称：Portable Network Graphics</li><li><strong>无损压缩方式</strong></li></ul></li></ul><p>简单来说，同一个文件保存成不同的格式后，文件大小上bmp肯定是最大的，而png和jpg，不同的压缩比结果会有所不同。可以用画图工具新建一副100×100的图像，分别保存成这三种格式来验证：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_high_save_mspaint_format.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_high_save_mspaint_format.jpg" alt=""></picture></p><h3 id="高质量保存"><a href="#高质量保存" class="headerlink" title="高质量保存"></a>高质量保存</h3><p>用cv2.imwrite()保存图片时，可以传入第三个参数（请参考<a href="#接口文档">接口文档</a>），用于控制保存质量：</p><ul><li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg质量控制，取值0~100，值越大，质量越好，默认为95</li><li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png质量控制，取值0~9，值越大，压缩比越高，默认为1</li></ul><p>还有诸如<code>CV_IMWRITE_WEBP_QUALITY</code>的参量，不常用，请参考：<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a>。</p><p>举例来说，原图lena.jpg的分辨率是350×350，大小49.7KB。我们把它转成不同格式看下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">new_img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bmp</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_bmp.bmp'</span>,new_img) <span class="comment"># 文件大小：359KB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># jpg 默认95%质量</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_jpg95.jpg'</span>,new_img) <span class="comment"># 文件大小：52.3KB</span></span><br><span class="line"><span class="comment"># jpg 20%质量</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_jpg20.jpg'</span>,new_img,[int(cv2.IMWRITE_JPEG_QUALITY),<span class="number">20</span>]) <span class="comment"># 文件大小：8.01KB</span></span><br><span class="line"><span class="comment"># jpg 100%质量</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_jpg100.jpg'</span>,new_img,[int(cv2.IMWRITE_JPEG_QUALITY),<span class="number">100</span>]) <span class="comment"># 文件大小：82.5KB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># png 默认1压缩比</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_png1.png'</span>,new_img) <span class="comment"># 文件大小：240KB</span></span><br><span class="line"><span class="comment"># png 9压缩比</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_png9.png'</span>,new_img,[int(cv2.IMWRITE_PNG_COMPRESSION),<span class="number">9</span>]) <span class="comment"># 文件大小：207KB</span></span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>bmp文件是最大的，没有任何压缩（1个像素点1byte，3通道的彩色图总大小：350×350×3/1024 ≈ 359 KB）</li><li>jpg/png本身就有压缩的，所以就算是100%的质量保存，体积也比bmp小很多</li><li>jpg的容量优势很明显，这也是它为什么如此流行的原因</li></ul><blockquote><p>思考：为什么原图49.7KB，保存成bmp或其他格式反而大了呢？</p></blockquote><p>这是个很有趣的问题，很多童鞋都问过我。这里需要明确的是保存新格式时，<strong>容量大小跟原图的容量没有直接关系，而是取决于原图的分辨率大小和原图本身的内容（压缩方式）</strong>，所以lena.jpg保存成不压缩的bmp格式时，容量大小就是固定的350×350×3/1024 ≈ 359 KB；另外，容量变大不代表画质提升噢，不然就逆天了<del>~</del></p><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Matplotlib是Python的一个很常用的绘图库，有兴趣的可以去<a href="www.matplotlib.org/">官网</a>学习更多内容。</p><h3 id="显示灰度图"><a href="#显示灰度图" class="headerlink" title="显示灰度图"></a>显示灰度图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度图显示，cmap(color map)设置为gray</span></span><br><span class="line">plt.imshow(img, cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_matplotlib_show_gray_image.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_matplotlib_show_gray_image.jpg" alt=""></picture></p><h3 id="显示彩色图"><a href="#显示彩色图" class="headerlink" title="显示彩色图"></a>显示彩色图</h3><p><strong>OpenCV中的图像是以BGR的通道顺序存储的</strong>，但Matplotlib是以RGB模式显示的，所以直接在Matplotlib中显示OpenCV图像会出现问题，因此需要转换一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line">img2 = img[:, :, ::<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 或使用</span></span><br><span class="line"><span class="comment"># img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示不正确的图</span></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示正确的图</span></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([]) <span class="comment"># 隐藏x和y轴</span></span><br><span class="line">plt.imshow(img2)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><p><code>img[:,:,0]</code>表示图片的蓝色通道，<code>img[:,:,::-1]</code>就表示BGR翻转，变成RGB，说明一下：</p></blockquote><p>熟悉Python的童鞋应该知道，对一个字符串s翻转可以这样写：<code>s[::-1]</code>，’abc’变成’cba’，-1表示逆序。图片是二维的，所以完整地复制一副图像就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img2 = img[:,:] <span class="comment"># 写全就是：img2 = img[0:height,0:width]</span></span><br></pre></td></tr></table></figure><p>而图片是有三个通道，相当于一个长度为3的字符串，所以通道翻转与图片复制组合起来便是<code>img[:,:,::-1]</code>。</p><p>结果如下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_matplotlib_show_color_image.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_matplotlib_show_color_image.jpg" alt=""></picture></p><h3 id="加载和保存图片"><a href="#加载和保存图片" class="headerlink" title="加载和保存图片"></a>加载和保存图片</h3><p>不使用OpenCV，Matplotlib也可以加载和保存图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> pli</span><br><span class="line"></span><br><span class="line">img = pli.imread(<span class="string">'lena.jpg'</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图片，需放在show()函数之前</span></span><br><span class="line">plt.savefig(<span class="string">'lena2.jpg'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8702.%20%E6%97%A0%E6%8D%9F%E4%BF%9D%E5%AD%98%E5%92%8CMatplotlib%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://segmentfault.com/a/1190000013589397" target="_blank" rel="noopener">聊一聊几种常用web图片格式</a></li><li><a href="www.matplotlib.org/">Matplotlib官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解常用图片格式和OpenCV高质量保存图片的方式，学习如何使用Matplotlib显示OpenCV图像。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="Matplotlib" scheme="http://www.codec.wang/tags/Matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程2：基本元素-图片</title>
    <link href="http://www.codec.wang/opencv-python-basic-element-image/"/>
    <id>http://www.codec.wang/opencv-python-basic-element-image/</id>
    <published>2017-12-06T07:52:06.000Z</published>
    <updated>2020-04-07T04:41:46.757Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何加载图片，显示并保存图片。<a id="more"></a>图片等可到<a href="#引用">源码处</a>下载。</p><hr><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>加载图片，显示图片，保存图片</li><li>OpenCV函数：<code>cv2.imread()</code>, <code>cv2.imshow()</code>, <code>cv2.imwrite()</code></li></ul><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>大部分人可能都知道电脑上的彩色图是以RGB(红-绿-蓝，Red-Green-Blue)颜色模式显示的，但OpenCV中彩色图是以B-G-R通道顺序存储的，灰度图只有一个通道。</p><p>图像坐标的起始点是在左上角，所以行对应的是y，列对应的是x：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_image_coordinate_channels.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_image_coordinate_channels.jpg" alt=""></picture></p><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>使用<code>cv2.imread()</code>来读入一张图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载灰度图</span></span><br><span class="line">img = cv2.imread(<span class="string">'lena.jpg'</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><p>参数1：图片的文件名</p><ul><li>如果图片放在当前文件夹下，直接写文件名就行了，如’lena.jpg’</li><li>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</li></ul></li><li><p>参数2：读入方式，省略即采用默认值</p><ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul></li></ul><blockquote><p>经验之谈：路径中不能有中文噢，并且没有加载成功的话是不会报错的，<code>print(img)</code>的结果为None，后面处理才会报错，算是个小坑。</p></blockquote><h3 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h3><p>使用<code>cv2.imshow()</code>显示图片，窗口会自适应图片的大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'lena'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数1是窗口的名字，参数2是要显示的图片。不同窗口之间用窗口名区分，所以窗口名相同就表示是同一个窗口，显示结果如下：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_show_lena_gray.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_show_lena_gray.jpg" alt=""></picture></p><p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间（毫秒ms）。时间一到，会继续执行接下来的程序，传入0的话表示一直等待。等待期间也可以获取用户的按键输入：<code>k = cv2.waitKey(0)</code>（<a href="#练习">练习1</a>）。</p><p>我们也可以先用<code>cv2.namedWindow()</code>创建一个窗口，之后再显示图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先定义窗口，后显示图片</span></span><br><span class="line">cv2.namedWindow(<span class="string">'lena2'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">'lena2'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数1依旧是窗口的名字，参数2默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口大小自适应图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。</p><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>使用<code>cv2.imwrite()</code>保存图片，参数1是包含后缀名的文件名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">'lena_gray.jpg'</span>, img)</span><br></pre></td></tr></table></figure><p>Nice，是不是很简单呐，再接再厉噢(●’◡’●)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>cv2.imread()</code>读入图片、<code>cv2.imshow()</code>显示图片、<code>cv2.imwrite()</code>保存图片。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><p>打开lena.jpg并显示，如果按下’s’，就保存图片为’lena_save.bmp’，否则就结束程序。</p></li><li><p>Matplotlib是Python中常用的一个绘图库，请学习<a href="/opencv-python-extra-high-quality-save-and-using-matplotlib/">番外篇：无损保存和Matplotlib使用</a>。</p></li></ol><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/d3/d63/classcv_1_1Mat.html" target="_blank" rel="noopener">Mat Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56" target="_blank" rel="noopener">cv2.imread()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563" target="_blank" rel="noopener">cv2.imshow()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b" target="_blank" rel="noopener">cv.namedWindow()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/02.%20%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87" target="_blank" rel="noopener">本节源码</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" target="_blank" rel="noopener">Getting Started with Images</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何加载图片，显示并保存图片。
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程番外篇1：代码性能优化</title>
    <link href="http://www.codec.wang/opencv-python-extra-code-optimization/"/>
    <id>http://www.codec.wang/opencv-python-extra-code-optimization/</id>
    <published>2017-12-06T07:51:52.000Z</published>
    <updated>2019-05-11T11:42:29.351Z</updated>
    
    <content type="html"><![CDATA[<p>学习如何评估和优化代码性能。（本节还没更新完…………）<a id="more"></a></p><p>完成一项任务很重要，高效地完成更重要。图像处理是对矩阵的操作，数据量巨大。如果代码写的不好，性能差距将很大，所以这节我们来了解下如何评估和提升代码性能。</p><h2 id="评估代码运行时间"><a href="#评估代码运行时间" class="headerlink" title="评估代码运行时间"></a>评估代码运行时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">start = cv2.getTickCount()</span><br><span class="line"><span class="comment"># 这里写测试代码...</span></span><br><span class="line">end = cv2.getTickCount()</span><br><span class="line">print((end - start) / cv2.getTickFrequency())</span><br></pre></td></tr></table></figure><p>这段代码就是用来测量程序运行时间的（单位：s），其中<code>cv2.getTickCount()</code>函数得到电脑启动以来的时钟周期数，<code>cv2.getTickFrequency()</code>返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用Python中的time模块计时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line"><span class="comment"># 这里写测试代码...</span></span><br><span class="line">end = time.clock()</span><br><span class="line">print(end - start)</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：如果你使用的是<a href="https://baike.baidu.com/item/ipython" target="_blank" rel="noopener">IPython</a>或<a href="https://baike.baidu.com/item/Jupyter" target="_blank" rel="noopener">Jupyter Notebook</a>开发环境，性能分析将会非常方便，详情请参考：<a href="http://pynash.org/2013/03/06/timing-and-profiling/" target="_blank" rel="noopener">Timing and Profiling in IPython</a></p></blockquote><h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><ul><li>数据元素少时用Python语法，数据元素多时用Numpy：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">z = np.uint8([<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试比较下面三句话各自的运行时间</span></span><br><span class="line">y = x * x * x   <span class="comment"># (1.6410249677846285e-06)</span></span><br><span class="line">y = x**<span class="number">3</span>        <span class="comment"># (2.461537451676943e-06)</span></span><br><span class="line">y = z * z * z   <span class="comment"># 最慢 (3.1179474387907945e-05)</span></span><br></pre></td></tr></table></figure><p>所以Numpy的运行速度并不一定比Python本身语法快，元素数量较少时，请用Python本身格式。</p><ul><li>尽量避免使用循环，尤其嵌套循环，因为极其慢！！！</li><li>优先使用OpenCV/Numpy中封装好的函数</li><li>尽量将数据向量化，变成Numpy的数据格式</li><li>尽量避免数组的复制操作</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" target="_blank" rel="noopener">cv2.getTickCount()</a></li><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c" target="_blank" rel="noopener">cv2.getTickFrequency()</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/%E7%95%AA%E5%A4%96%E7%AF%8701.%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">本节源码</a></li><li><a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" target="_blank" rel="noopener">Python Optimization Techniques</a></li><li><a href="http://pynash.org/2013/03/06/timing-and-profiling/" target="_blank" rel="noopener">Timing and Profiling in IPython</a></li><li><a href="http://www.scipy-lectures.org/advanced/advanced_numpy/index.html#advanced-numpy" target="_blank" rel="noopener">Advanced Numpy</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习如何评估和优化代码性能。（本节还没更新完…………）
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python+OpenCV教程1：简介与安装</title>
    <link href="http://www.codec.wang/opencv-python-introduction-and-installation/"/>
    <id>http://www.codec.wang/opencv-python-introduction-and-installation/</id>
    <published>2017-12-06T07:50:59.000Z</published>
    <updated>2020-04-07T04:41:05.345Z</updated>
    
    <content type="html"><![CDATA[<p>相信大部分人知道的OpenCV都是用C++来开发的，那为什么我推荐使用Python呢？<a id="more"></a></p><blockquote><p>本教程翻译自<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">OpenCV官方英文教程</a>，我按照使用度和难易度翻译，重新编写了大量原创内容，将不常用和较难的部分写成番外篇，浅显易懂，很easy的辣。每节的源码、图片和练习题答案均可在<a href="#引用">引用</a>处找到噢(⊙o⊙)</p></blockquote><hr><h2 id="Python照样快！"><a href="#Python照样快！" class="headerlink" title="Python照样快！"></a>Python照样快！</h2><p>众所周知，虽然Python语法简洁，编写高效，但相比C/C++运行慢很多。然而Python还有个重要的特性：它是一门胶水语言！Python可以很容易地扩展C/C++。<strong>OpenCV-Python</strong>就是用Python包装了C++的实现，背后实际就是C++的代码在跑，所以代码的运行速度跟原生C/C++速度一样快。</p><p>我举两个简单的例子就一目了然了：一个是读入图片，另一个是调整图片的对比度和亮度：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_python_vs_cplus_speed.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_python_vs_cplus_speed.jpg" alt=""></picture></p><p><strong>可以看到某些情况下Python的运行速度甚至好于C++，代码行数也直接少一半多！</strong>另外，图像是矩阵数据，OpenCV-Python原生支持<a href="https://baike.baidu.com/item/numpy" target="_blank" rel="noopener">Numpy</a>，相当于Python中的Matlab，为矩阵运算、科学计算提供了极大的便利性。</p><h2 id="人工智能浪潮"><a href="#人工智能浪潮" class="headerlink" title="人工智能浪潮"></a>人工智能浪潮</h2><p>近些年，人工智能相关技术的快速发展大家有目共睹，不必多说。在编程语言方面，更多人希望的是具备高效开发效率、跨平台、高度扩展性的语言，尤其是一些AI巨头优先推出支持Python语言的深度学习框架，如Facebook的<a href="https://pytorch.org/" target="_blank" rel="noopener">PyTorch</a>、Google的<a href="https://tensorflow.google.cn/" target="_blank" rel="noopener">Tensorflow</a>等，可以说Python是名副其实的“网红语言”了。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_ai_ml_dl2.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_ai_ml_dl2.jpg" alt=""></picture></p><p>从<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE编程语言排行榜</a>也可以看到，Python发展迅猛，已经逼近C++的份额。这个排行榜每月更新，我就不截图了，编写时TOP5：Java/C/C++/Python/C#。</p><h2 id="人生苦短，我用Python"><a href="#人生苦短，我用Python" class="headerlink" title="人生苦短，我用Python"></a>人生苦短，我用Python</h2><ul><li>如果你搞科研用，果断放弃C++（Matlab？出门左拐）</li><li>如果你是快速原型开发，验证方案，果断放弃C++</li><li>如果你懒的配置OpenCV环境，果断放弃C++</li><li>如果你的程序是在支持Python的较高硬件环境下运行，果断放弃C++</li><li>如果你担心Python写不了界面，那是你的问题o_o ….</li><li>除非你的程序是MFC或已经用C++编写其他模块或是嵌入式设备，那就用C++吧</li></ul><p><strong>“人生苦短，我用Python！！！”</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>本教程编写时使用的软件版本是：OpenCV 3.x，Python 3.x。</p></blockquote><p>要安装OpenCV，只需cmd下的一条指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><p>pip是Python的包管理器，如果你还没安装Python，强烈推荐安装<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">Anaconda</a>，它包含了大量的科学计算包，不用后期一个个安装。即使你已经装了Python也没有影响，Anaconda相当于虚拟环境，互不干扰。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>进入Anaconda<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">官网</a>，下载最新版本的安装文件，速度比较慢的话，可以去<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华开源镜像站</a>。</p><ul><li><p>Windows版下载的是exe文件，双击可以直接安装，安装时记得勾选 <code>Add Anaconda to my PATH environment variable</code>，添加到环境变量中。</p></li><li><p>Linux版下载的是sh文件，下载完成后，终端切换到下载目录，执行<code>bash Anaconda3-xx.sh</code>，Linux版也会提示添加环境变量，记得输yes就行。</p></li></ul><h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>Python安装好之后，可以在cmd中输入<code>python --version</code>来查看Python的版本信息。对于OpenCV，打开Python的开发环境，输入<code>import cv2</code>，运行没有报错说明一切正常。要查看OpenCV的版本，可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cv2.__version__)  <span class="comment"># '3.4.1'</span></span><br></pre></td></tr></table></figure><blockquote><p>Python开发环境我用的是<a href="http://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>，也可以用<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a>/<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>/Jupyter Notebook(Anaconda自带)，或者直接在命令行里敲，自己习惯就行。</p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>pip识别不了：环境变量中没有pip的目录，找到pip目录，添加到用户（或系统）变量的path中。</li><li>下载速度很慢：可<a href="https://pypi.org/search/?q=opencv-python" target="_blank" rel="noopener">到此处</a>下载离线版。下载完成后，cmd切换到下载目录，输入 <code>pip install 文件名</code>安装。</li></ol><h2 id="学习软件"><a href="#学习软件" class="headerlink" title="学习软件"></a>学习软件</h2><p>为了便于学习OpenCV，我写了一个教学款软件<a href="https://github.com/ex2tron/LearnOpenCVEdu" target="_blank" rel="noopener">LearnOpenCVEdu</a>，目前只开发了一部分功能，有兴趣的童鞋可以支持一下噢😊</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cv2_learn_opencv_edu_soft_screenshot.jpg_webp"><img class="image" src="http://blog.codec.wang/cv2_learn_opencv_edu_soft_screenshot.jpg" alt="大家随手点个Star吧(●ˇ∀ˇ●)"></picture></p><blockquote><p>经验之谈：虽然从一开始我就推荐大家使用OpenCV-Python进行图像处理，但<em>想要深入理解OpenCV</em>，C++还是必须的，尤其是<strong>OpenCV源码</strong>！</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/tree/master/01.%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">本节源码</a></li></ul><h3 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h3><ul><li><a href="https://docs.opencv.org/" target="_blank" rel="noopener"><strong>OpenCV Docs官方文档</strong></a></li><li><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">OpenCV 官方Github</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html" target="_blank" rel="noopener">官方英文教程：OpenCV-Python Tutorials</a></li><li><a href="http://www.learnopencv.com" target="_blank" rel="noopener">LearnOpenCV</a>、<a href="https://github.com/spmallick/learnopencv" target="_blank" rel="noopener">LearnOpenCV Github</a></li><li><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="noopener">Numpy Quickstart Tutorial</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html" target="_blank" rel="noopener">OpenCV 中文教程</a></li></ul><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><a href="http://programmingcomputervision.com/" target="_blank" rel="noopener">Programming Computer Vision with Python</a>、<a href="https://www.amazon.cn/dp/B00L3Y3NEM/ref=sr_1_1?ie=UTF8&qid=1543929834&sr=8-1&keywords=Python+%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89" target="_blank" rel="noopener">中文书</a></li><li><a href="https://www.pyimagesearch.com/practical-python-opencv/" target="_blank" rel="noopener">https://www.pyimagesearch.com/practical-python-opencv/</a></li></ul><h3 id="名校视觉研究所-课程"><a href="#名校视觉研究所-课程" class="headerlink" title="名校视觉研究所/课程"></a>名校视觉研究所/课程</h3><ul><li><a href="http://graphics.cs.cmu.edu/" target="_blank" rel="noopener">卡内基梅隆大学</a></li><li><a href="https://www.cs.toronto.edu/~guerzhoy/320/" target="_blank" rel="noopener">多伦多大学</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大部分人知道的OpenCV都是用C++来开发的，那为什么我推荐使用Python呢？
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Brand7 2.0更名&quot;品牌漆&quot;正式上架咯！</title>
    <link href="http://www.codec.wang/brand7-2-release/"/>
    <id>http://www.codec.wang/brand7-2-release/</id>
    <published>2017-11-26T11:04:32.000Z</published>
    <updated>2020-04-07T04:38:41.178Z</updated>
    
    <content type="html"><![CDATA[<p>隔了一年更新，良心都有点痛了( ╯□╰ )<a id="more"></a></p><blockquote><p><em>示威的人做的不对的话，引起示威的人呢？</em>  ——<a href="https://movie.douban.com/subject/21937445/" target="_blank" rel="noopener">《辩护人》</a></p></blockquote><p>当初Brand7写完的时候，一直想写一个关于电影的APP，甚至做出了雏形：MovieBackdrops，可惜，时间不多，事情却很多。前段时间闭关，摸着自己的良心，终于把Brand7更新了一把，来看看更新内容吧：</p><p><strong><a href="https://www.microsoft.com/store/productId/9NBLGGH546QC" target="_blank" rel="noopener">品牌漆</a>（Brand7）是一款Win10 UWP猜品牌的小游戏，里面涵盖了汽车、娱乐、时尚、生活、餐饮、科技、旅游七个类别的550个品牌。Ver2.0.1更新日志如下：</strong></p><ol><li><p>更名“品牌漆”</p></li><li><p>全新Logo</p></li><li><p>全新启动界面</p></li><li><p>新增50个品牌，现共550个品牌</p></li><li><p>全面中文版（英文被很多人吐槽看不懂( ╯□╰ )）</p></li><li><p>界面UI调整</p></li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/brand7_v2_comparation.jpg_webp"><img class="image" src="http://blog.codec.wang/brand7_v2_comparation.jpg" alt="新旧版对比：中文版"></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/brand7_v2_ui.jpg_webp"><img class="image" src="http://blog.codec.wang/brand7_v2_ui.jpg" alt="完成界面"></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/brand7_v2_startui.jpg_webp"><img class="image" src="http://blog.codec.wang/brand7_v2_startui.jpg" alt="新的启动界面"></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/brand7_v2_share.jpg_webp"><img class="image" src="http://blog.codec.wang/brand7_v2_share.jpg" alt="分享界面"></picture></p><p>可以在Win10应用商店中搜索“品牌漆”进行下载，或<a href="https://www.microsoft.com/store/productId/9NBLGGH546QC" target="_blank" rel="noopener">点击此处</a>。</p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;隔了一年更新，良心都有点痛了( ╯□╰ )
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Brand7" scheme="http://www.codec.wang/tags/Brand7/"/>
    
      <category term="品牌漆" scheme="http://www.codec.wang/tags/%E5%93%81%E7%89%8C%E6%BC%86/"/>
    
  </entry>
  
  <entry>
    <title>【视觉与图像】OpenCV篇：Python+OpenCV实用教程</title>
    <link href="http://www.codec.wang/opencv-python/"/>
    <id>http://www.codec.wang/opencv-python/</id>
    <published>2017-10-10T14:22:13.000Z</published>
    <updated>2020-04-07T03:57:57.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录 "></a>目录 <a id="more"></a></h3><h4 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h4><ol><li><a href="/opencv-python-introduction-and-installation/">简介与安装</a>（了解安装OpenCV-Python） | <a href="/opencv-python-extra-code-optimization/">番外篇1：代码性能优化</a></li><li><a href="/opencv-python-basic-element-image/">基本元素-图片</a>（图片载入/显示/保存） | <a href="/opencv-python-extra-high-quality-save-and-using-matplotlib/">番外篇2：无损保存和Matplotlib使用</a></li><li><a href="/opencv-python-open-camera/">打开摄像头</a>（打开摄像头捕获图片/播放保存视频） | <a href="/opencv-python-extra-trackbar/">番外篇3：滑动条</a></li><li><a href="/opencv-python-basic-operations/">图像基本操作</a>（访问像素点/ROI/通道分离合并/图片属性）</li><li><a href="/opencv-python-changing-colorspaces/">颜色空间转换</a>（颜色空间转换/追踪特定颜色物体）</li><li><a href="/opencv-python-image-thresholding/">阈值分割</a>（阈值分割/二值化） | <a href="/opencv-python-extra-otsu-thresholding/">番外篇4：Otsu阈值法</a></li><li><a href="/opencv-python-image-geometric-transformation/">图像几何变换</a>（旋转/平移/缩放/翻转） | <a href="/opencv-python-extra-warpaffine-warpperspective/">番外篇5：仿射变换与透视变换</a></li><li><a href="/opencv-python-drawing-function/">绘图功能</a>（画线/画圆/画矩形/添加文字） | <a href="/opencv-python-extra-drawing-with-mouse/">番外篇6：鼠标绘图</a></li></ol><p><a href="/opencv-python-clock-drawing/"><strong>挑战任务：画动态时钟</strong></a> | <a href="/opencv-python-using-pyqt5-create-gui/"><strong>拓展挑战：PyQt5编写GUI界面</strong></a></p><h4 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h4><ol><li><a href="/opencv-python-image-blending/">图像混合</a>（算数运算/混合/按位运算） | <a href="/opencv-python-extra-contrast-brightness/">番外篇7：亮度与对比度</a></li><li><a href="/opencv-python-smoothing-images/">平滑图像</a>（卷积/滤波/模糊/降噪） | <a href="/opencv-python-extra-padding-and-convolution/">番外篇8：卷积基础(图片边框)</a></li><li><a href="/opencv-python-edge-detection/">边缘检测</a>（Canny/Sobel） | <a href="/opencv-python-extra-image-gradients/">番外篇9：图像梯度</a></li><li><a href="/opencv-python-erode-and-dilate/">腐蚀与膨胀</a>（形态学操作/腐蚀/膨胀/开运算/闭运算）</li><li><a href="/opencv-python-contours/">轮廓</a> （寻找/绘制轮廓）  | <a href="/opencv-python-extra-contours-hierarchy/">番外篇10：轮廓层级</a></li><li><a href="/opencv-python-contour-features/">轮廓特征</a> （面积/周长/最小外接矩(圆)/形状匹配） | <a href="/opencv-python-extra-convex-hull/">番外篇11：凸包及更多轮廓特征</a></li><li><a href="/opencv-python-histograms/">直方图</a>（计算绘制直方图/均衡化）</li><li><a href="/opencv-python-template-matching/">模板匹配</a>（大图中找小图）</li><li><a href="/opencv-python-hough-transform/"> 霍夫变换</a>（提取直线/圆）</li></ol><p><a href="/opencv-python-lane-road-detection/"><strong>挑战任务：车道检测</strong></a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录 &quot;&gt;&lt;/a&gt;目录
    
    </summary>
    
    
      <category term="机器视觉" scheme="http://www.codec.wang/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Python" scheme="http://www.codec.wang/tags/Python/"/>
    
      <category term="图像处理" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【利器】GitKraken：酷炫的Git GUI客户端</title>
    <link href="http://www.codec.wang/tools-gitkraken/"/>
    <id>http://www.codec.wang/tools-gitkraken/</id>
    <published>2017-10-05T09:33:20.000Z</published>
    <updated>2020-04-07T03:50:49.653Z</updated>
    
    <content type="html"><![CDATA[<p>不喜欢敲命令？那么这款酷炫的Git客户端让你逼格满满！<a id="more"></a></p><blockquote><p><em>真正的忘记是不需要努力的。</em>——<a href="https://movie.douban.com/subject/5045678/" target="_blank" rel="noopener">《大鱼海棠》</a></p></blockquote><hr><p>废话一段先：以前上班的时候，公司里版本管理系统用的是perforce，你应该、可能没听过( ╯□╰ )。总之，就是集中式版本管理系统，相比于git的分布式有很多缺陷，具体可以看“<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374027586935cf69c53637d8458c9aec27dd546a6cd6000" target="_blank" rel="noopener">集中式vs分布式</a>”。但作为一款商业软件，perforce提供的优秀客户端体验还是相当不错的。使用git后，一直都是敲命令的，一是因为习惯，毕竟码代码逼格高嘛，二是因为git的GUI客户端要不很丑，要不功能捉急，总之不想用。之后，体验了这个软件，又同类似的<a href="http://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a>对比了下，无奈，我，还是喜欢颜值高的~ o(<em>￣▽￣</em>)o另外，以前外教老师提问说《加勒比海盗2》中的那个怪物叫啥，阅片无数的我，那天竟然没回答上，装逼失败，所以对这只“挪威海怪kraken”影响特别深刻。好了，开始正题吧~</p><ul><li>官网/下载：<a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken</a></li></ul><p>GitKraken对Windows/Linux/Mac三大主流平台都支持，其方便之处在于，它不需要安装配置，双击打开就可以了。打开之后，可以选择用Github账号登陆，需要Github授权：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/gitkraken_sign_in_with_github.png_webp"><img class="image" src="http://blog.codec.wang/gitkraken_sign_in_with_github.png" alt="使用Github授权登录"></picture></p><h2 id="打开-克隆-初始化"><a href="#打开-克隆-初始化" class="headerlink" title="打开/克隆/初始化"></a>打开/克隆/初始化</h2><p>GitKranken支持打开本地仓库，从指定的URL或Github、Gitlab、Bitbucket等上面直接克隆。前面我们已经用Github直接登陆了，所以，从Github克隆时，会直接列出你当前的所有仓库项目，非常方便。当然，也可以连接到Gitlab/Bitbucket平台：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/gitkraken_clone_from_github.png_webp"><img class="image" src="http://blog.codec.wang/gitkraken_clone_from_github.png" alt=""></picture></p><p>初始化/新建项目也非常方便，在Init选项中，可以选择初始化一个本地仓库或类似Github之类的远程仓库。GitKraken初始化时还提供了.gitignore的文件的相关模板：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/gitkraken_init_github_repo.png_webp"><img class="image" src="http://blog.codec.wang/gitkraken_init_github_repo.png" alt=""></picture></p><h2 id="界面-功能"><a href="#界面-功能" class="headerlink" title="界面/功能"></a>界面/功能</h2><p>打开一个仓库后，主界面如下图，酷炫简洁，顶部提供了常用的Git功能，就不细说了。我主要提及一下，如何进行版本差分：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/gitkraken_main_ui.png_webp"><img class="image" src="http://blog.codec.wang/gitkraken_main_ui.png" alt=""></picture></p><p>在提交日志的主界面，如果要比较任意两个版本之间的差分，按住Ctrl键，选择要比较的版本，右边会自动列出两个版本之间所修改的文件，点击文件就可以看到diff了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/gitkraken_view_commits_diff.png_webp"><img class="image" src="http://blog.codec.wang/gitkraken_view_commits_diff.png" alt=""></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/gitkraken_view_file_diff.png_webp"><img class="image" src="http://blog.codec.wang/gitkraken_view_file_diff.png" alt=""></picture></p><p>当然，最新版本（本文使用的是3.1版本）的GitKraken提供了Merge和Diff工具的自定义（File-Preferences-General中设置），比如说我最常用的Merge工具是WinMerge，就可以在这里配置。</p><p>抛砖引玉，大致介绍了一下，其实熟悉Git的话，这个工具使用起来还是蛮简单的~ o(<em>￣▽￣</em>)o</p><p><em>2019年3月19日更新：最近我一直用VSCode，集成的git功能再加上gitlens这款插件，体验也很棒。</em></p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不喜欢敲命令？那么这款酷炫的Git客户端让你逼格满满！
    
    </summary>
    
    
      <category term="利器篇" scheme="http://www.codec.wang/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="Git" scheme="http://www.codec.wang/tags/Git/"/>
    
      <category term="GitKraken" scheme="http://www.codec.wang/tags/GitKraken/"/>
    
  </entry>
  
  <entry>
    <title>【利器】七牛云：每月免费10G的图床</title>
    <link href="http://www.codec.wang/tools-qiniuyun/"/>
    <id>http://www.codec.wang/tools-qiniuyun/</id>
    <published>2017-09-18T11:55:38.000Z</published>
    <updated>2020-04-07T03:49:03.065Z</updated>
    
    <content type="html"><![CDATA[<p>随着越来越多的人开始使用Markdown写自己的独立博客，一个好用稳定的图床是必不可少的了。<a id="more"></a></p><hr><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>在<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>之前，我使用过国外的<a href="https://www.getcloudapp.com/" target="_blank" rel="noopener">Cloud App</a>和<a href="https://www.aliyun.com/product/oss?utm_content=se_877546" target="_blank" rel="noopener">阿里云的OSS对象存储</a>。</p><ol><li><p>首先，国外的东西在国内稳定性和速度都是相对较差的，我试着在阿里云和Cloud App上上传同一张图片并生成外链，Cloud App要比阿里的加载速度延迟1-2s，阿里基本秒开。</p></li><li><p>阿里的OSS对象存储虽然很稳定，但是并不提供免费的空间。相对来说，七牛云提供的每月10G免费流量，对于博客来说，绰绰有余了。</p></li><li><p>另外，七牛云提供了诸多的图片处理接口，如水印、格式转换、缩放等，很实用，很强大。</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>注册并登陆<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a>，在七牛云的产品列表中，添加一个<code>对象存储</code>，如这里取名为<code>picblog</code>：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/create_new_bucket.png_webp"><img class="image" src="http://blog.codec.wang/create_new_bucket.png" alt="创建新的存储空间"></picture></p><p>创建好之后，七牛云会自动生成一个测试域名：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/test_domain_name.png_webp"><img class="image" src="http://blog.codec.wang/test_domain_name.png" alt="测试域名"></picture></p><p>这个域名就是你文件的前缀了。比如，我们点击”内容管理”，点击”上传文件”，选择一幅图片上传。上传完成后，复制该文件的外链地址：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/copy_file_link.png_webp"><img class="image" src="http://blog.codec.wang/copy_file_link.png" alt="拷贝外链地址"></picture></p><p>这个地址就是你的外链地址辣，你可以在浏览器中直接访问，比如：<a href="http://blog.codec.wang/mycli_demo.gif_webp" target="_blank" rel="noopener">mysql_demo</a></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="添加二级域名"><a href="#添加二级域名" class="headerlink" title="添加二级域名"></a>添加二级域名</h3><p>七牛云默认的测试域名有时间限制，貌似一个月就过期不能用了。所以，你如果已经购买了域名的话，可以在这里绑定自己的二级域名，这样既好记又方便管理。</p><p>比如，这里我已经在万网上购买了<code>ex2tron.xin</code>的域名，这里我演示如何将七牛云的存储空间绑定<code>pic.ex2tron.xin</code>这个域名。</p><p>在七牛云的存储空间页面，点击”绑定域名”，只需要在加速域名处填写要绑定的域名，其他项保持默认即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加速域名： pic.ex2tron.xin</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/bucket_binding_domain_name.png_webp"><img class="image" src="http://blog.codec.wang/bucket_binding_domain_name.png" alt="自定义域名"></picture></p><p>创建后，系统会配置一段时间，等待处理完成，会显示一个诸如<code>xxx.qiniudns.com</code>的CNAME记录值，记下此值，后面要用到。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cname_for_binding.png_webp"><img class="image" src="http://blog.codec.wang/cname_for_binding.png" alt=""></picture></p><h3 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h3><p>打开万网的域名控制台，添加一条CNAME的解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">记录类型：CNAME</span><br><span class="line">主机记录：pic</span><br><span class="line">记录值：xxx.qiniudns.com</span><br><span class="line"># 其他选型保持默认</span><br></pre></td></tr></table></figure><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/add_dns_for_qiniu.png_webp"><img class="image" src="http://blog.codec.wang/add_dns_for_qiniu.png" alt="添加域名解析"></picture></p><p>这样，你上传的图片外链就是：<code>http://pic.ex2tron.xin/filename.png</code>之类的了。</p><h2 id="添加图片样式"><a href="#添加图片样式" class="headerlink" title="添加图片样式"></a>添加图片样式</h2><p>利用七牛云做图床的另外一个强大之处在于丰富的图片样式。点击”图片样式”-“新建图片样式”，七牛云提供了如下很多种场景：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/api_for_image_process.png_webp"><img class="image" src="http://blog.codec.wang/api_for_image_process.png" alt="添加图片样式"></picture></p><p>比如，这里我们选择”指定宽高，强行缩放+打图片水印”，然后添加一个文字水印，可以调整文字的字体样式，位置等等：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/add_water_mark_api.png_webp"><img class="image" src="http://blog.codec.wang/add_water_mark_api.png" alt="水印功能"></picture></p><p>调整好之后，为样式取个名称，如<code>webpic</code>，这样，只要在原来外链的后面添加<code>-webpic</code>就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;pic.ex2tron.xin&#x2F;filename.png-webpic</span><br></pre></td></tr></table></figure><p>其中<code>-</code>这个连接符可以通过存储空间控制面板的”样式分隔符设置”中进行修改。</p><h2 id="图床工具"><a href="#图床工具" class="headerlink" title="图床工具"></a>图床工具</h2><p>对于七牛云，每张图片都在网页端上传还是比较麻烦的，所以用一些图床客户端工具会更加快速。</p><p>这里推荐两款工具：</p><p><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">MPic</a>图床神器。打开软件后，设置好自己的AK和SK（可在七牛云的个人中心-密钥管理中看到）。MPic支持文件拖拽上传，点击复制就可以复制外链，非常方便：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/mpic_qiniu.png_webp"><img class="image" src="http://blog.codec.wang/mpic_qiniu.png" alt="第三方七牛云工具"></picture></p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着越来越多的人开始使用Markdown写自己的独立博客，一个好用稳定的图床是必不可少的了。
    
    </summary>
    
    
      <category term="利器篇" scheme="http://www.codec.wang/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="七牛" scheme="http://www.codec.wang/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="图床" scheme="http://www.codec.wang/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages轻松搭博客(4)：自有服务器部署</title>
    <link href="http://www.codec.wang/hexo-blog-with-github-pages-4/"/>
    <id>http://www.codec.wang/hexo-blog-with-github-pages-4/</id>
    <published>2017-09-13T14:11:12.000Z</published>
    <updated>2020-04-07T04:40:16.635Z</updated>
    
    <content type="html"><![CDATA[<p>将博客放在Github上有很多优点，比如免费、易管理、免费<code>xxx.github.io</code>的域名等，但访问速度嘛，就很一般了。对于喜欢折腾的童鞋，如果有一台自己的服务器，也可以把博客部署在云上。<a id="more"></a></p><hr><p>之前我们购买了独立域名<code>www.ex2tron.top</code>，并将域名解析到了Github。现在我们要把博客放在云服务器上，并且将域名解析到这台服务器，好，开干！</p><blockquote><p>说明：以阿里云服务器为例，之前我已经使用apache部署了一个web应用，所以我后面会讲到apache如何配置多个域名。当然你也可以使用nginx，部署流程都类似。</p></blockquote><h2 id="服务器环境配置"><a href="#服务器环境配置" class="headerlink" title="服务器环境配置"></a>服务器环境配置</h2><p>用<code>ssh user@ip</code>连接到服务器后，先更新下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>查看git有没有安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version # 没安装的话：sudo apt install git</span><br></pre></td></tr></table></figure><p>不建议使用root账号，所以这里添加一个名为git的新用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br><span class="line">adduser git sudo # 添加到sudo中</span><br></pre></td></tr></table></figure><p>切换到git用户，并新建用户目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su git # 切换git用户</span><br><span class="line">cd</span><br><span class="line">mkdir .ssh &amp;&amp; cd .ssh</span><br></pre></td></tr></table></figure><p>然后将本地PC上ssh的<code>id_rsa.pub</code>文件内容复制到该目录的<code>authorized_keys</code>文件中，可以直接使用vim编辑，也可以在本机PC上使用scp命令（新版Windows10都已经自带ssh和scp等工具，可参考：<a href="/how-to-use-ssh-on-windows10/">如何使用Windows 10的OpenSSH Client和Server</a>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp .ssh/id_rsa.pub user@ip:/home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>这个时候可以退出ssh连接，并使用git用户直接登录了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@ip</span><br></pre></td></tr></table></figure><h2 id="Git远程仓库及同步"><a href="#Git远程仓库及同步" class="headerlink" title="Git远程仓库及同步"></a>Git远程仓库及同步</h2><blockquote><p>此处可参考我之前的Blog：<a href="/set-up-your-own-git-server/">搭建自己的Github/Git服务器</a></p></blockquote><p>跟GitHub一样，我们需要建一个博客的远程仓库。在git用户的主目录下创建仓库目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/git/hexoblog.git</span><br><span class="line">sudo chown -R git:git hexoblog.git # 不修改权限的话，无法推送</span><br><span class="line">cd /home/git/hexoblog.git</span><br><span class="line">git init --bare # 初始化仓库</span><br></pre></td></tr></table></figure><p>接下来需要修改本地Hexo的配置文件<code>_config.yml</code>。首先将<code>url</code>改成你的服务器公网ip或域名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: http:&#x2F;&#x2F;www.ex2tron.top&#x2F;</span><br></pre></td></tr></table></figure><p>其次在<code>deploy</code>项这里，如果你将博客推送到多个平台的话，直接新增一条就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo: git@47.101.xxx.xxx:&#x2F;home&#x2F;git&#x2F;hexoblog.git</span><br></pre></td></tr></table></figure><p>现在可以运行<code>hexo g -d</code>正常push了。</p><p>如果<code>hexo d</code>推送的时候出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote: fatal: Unable to create temporary file &#39;&#x2F;home&#x2F;git&#x2F;hexoblog.git&#x2F;.&#x2F;objects&#x2F;pack&#x2F;tmp_pack_XXXXXX&#39;: Permission denied</span><br><span class="line">fatal: sha1 file &#39;&lt;stdout&gt;&#39; write error: Broken pipe</span><br></pre></td></tr></table></figure><p>说明是git权限的原因，你有可能少执行了这句话噢：<code>sudo chown -R git:git hexoblog.git</code></p><h2 id="apache2配置"><a href="#apache2配置" class="headerlink" title="apache2配置"></a>apache2配置</h2><p>首先自然是安装apache2咯：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure><p>在<code>/var/www/</code>下面创建网站的根目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/www/html/hexoblog</span><br></pre></td></tr></table></figure><p>正常来说，这是我们第一次使用apache配置，后面会讲到我的情况。编辑apache2的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure><p>找到<code>DocumentRoot</code>项，并做如下更改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot /var/www/html/hexoblog</span><br></pre></td></tr></table></figure><p>最后重启apache生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure><p>前面提到过，我已经在apache2配置过一个web应用和域名了，这个时候可以在conf文件中新增一项配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 之前的：</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">......</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br><span class="line"># 新增的：</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ServerName www.ex2tron.top</span><br><span class="line">        ServerAlias www.ex2tron.top</span><br><span class="line">        DocumentRoot &#x2F;var&#x2F;www&#x2F;html&#x2F;hexoblog&#x2F;</span><br><span class="line">        &lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;hexoblog&#x2F;&quot;&gt;</span><br><span class="line">                Order deny,allow</span><br><span class="line">                Allow from all</span><br><span class="line">        &lt;&#x2F;Directory&gt;</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure><h2 id="创建Git钩子"><a href="#创建Git钩子" class="headerlink" title="创建Git钩子"></a>创建Git钩子</h2><p>现在远程仓库创建好了，但是需要将Hexo的静态HTML文件传送到<code>/var/www/html/hexoblog</code>下面才行。切换到远程仓库hexoblog.git目录下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/git/hexoblog.git/hooks/</span><br></pre></td></tr></table></figure><p>创建并编辑一个新的钩子文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo touch post-receive</span><br><span class="line">sudo vim post-receive</span><br></pre></td></tr></table></figure><p>在其中加入两行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/html/hexoblog --git-dir=/home/git/hexoblog.git checkout -f</span><br></pre></td></tr></table></figure><p>赋予可执行权限给文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x post-receive</span><br></pre></td></tr></table></figure><p>最后一定要确保git用户有权限操作博客目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown git:git -R /var/www/html</span><br></pre></td></tr></table></figure><p>这样，每次<code>hexo d</code>的时候就会自动同步文件到<code>/var/www/html/hexoblog/</code>博客目录下。此时，访问<code>www.ex2tron.top</code>便可以浏览你的博客辣，当然别忘了将你的域名解析到服务器IP噢，awesome！</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="/hexo-blog-with-github-pages-3/">Hexo+Github Pages轻松搭博客(3)：绑定独立域名</a></li><li><a href="https://www.cnblogs.com/scarecrowlxb/p/6218678.html" target="_blank" rel="noopener">apache解析多个域名</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将博客放在Github上有很多优点，比如免费、易管理、免费&lt;code&gt;xxx.github.io&lt;/code&gt;的域名等，但访问速度嘛，就很一般了。对于喜欢折腾的童鞋，如果有一台自己的服务器，也可以把博客部署在云上。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Hexo" scheme="http://www.codec.wang/tags/Hexo/"/>
    
      <category term="Github" scheme="http://www.codec.wang/tags/Github/"/>
    
      <category term="阿里云" scheme="http://www.codec.wang/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages轻松搭博客(3)：绑定独立域名</title>
    <link href="http://www.codec.wang/hexo-blog-with-github-pages-3/"/>
    <id>http://www.codec.wang/hexo-blog-with-github-pages-3/</id>
    <published>2017-09-13T13:25:24.000Z</published>
    <updated>2020-04-07T04:40:24.468Z</updated>
    
    <content type="html"><![CDATA[<p>嫌<code>username.github.io</code>不够高大上？？那就来个高大上的独立域名吧。<a id="more"></a></p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>域名可以去很多地方购买，非.com/.cn的域名也比较便宜，我这里以万网为例，打开<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>主页：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hexo_wanwang_home_page.jpg_webp"><img class="image" src="http://blog.codec.wang/hexo_wanwang_home_page.jpg" alt=""></picture></p><p>查找你想购买的域名，比如我购买``ex2tron.top`这个域名。.top域名的价格还是很便宜的，划算：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hexo_wanwang_top_domain_price.png_webp"><img class="image" src="http://blog.codec.wang/hexo_wanwang_top_domain_price.png" alt=""></picture></p><p>购买需要登陆阿里云的账号。购买成功后，按照提示进行实名认证和拍照备案，认证过程需要几天。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名认证完成后，登陆<a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云控制台</a>，在左侧导航栏找到”域名与网站（万网）”——“云解析DNS”：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hexo_dns_domain_aliyun_navigation.jpg_webp"><img class="image" src="http://blog.codec.wang/hexo_dns_domain_aliyun_navigation.jpg" alt=""></picture></p><p>选择你的域名，点击”解析设置”，我们添加三条解析：</p><ul><li>记录类型：CNAME，主机记录：www，路线：默认，记录值：<code>username.github.io</code></li><li>记录类型：A，主机记录：@，路线：默认，记录值：<code>192.30.252.153</code></li><li>记录类型：A，主机记录：@，路线：默认，记录值：<code>192.30.252.154</code></li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hexo_add_new_dns_for_new_domain.jpg_webp"><img class="image" src="http://blog.codec.wang/hexo_add_new_dns_for_new_domain.jpg" alt=""></picture></p><p>（图上文字小的话，可以点击查看大图）</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hexo_github_dns_domain_settings.jpg_webp"><img class="image" src="http://blog.codec.wang/hexo_github_dns_domain_settings.jpg" alt=""></picture></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>设置完成后，在本地的hexo博客的source目录下，新建一个名为CNAME的文件（没有任何后缀），编辑文件内容为你的域名，如<code>ex2tron.top</code>。这里如果在域名上加<code>www</code>的话，访问时会跳转到<code>www.ex2tron.top</code>，为了简洁起见，我这里就不加了。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/hexo_source_directory_cname_file.jpg_webp"><img class="image" src="http://blog.codec.wang/hexo_source_directory_cname_file.jpg" alt=""></picture></p><p>配置完成后，重新发布博客就可以用独立域名<a href="http://ex2tron.top" target="_blank" rel="noopener">ex2tron.top</a>来访问博客辣( •̀ ω •́ )✧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://blog.csdn.net/linshuhe1/article/details/73013730" target="_blank" rel="noopener">Hexo个人免费博客(五) 使用自己的域名</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嫌&lt;code&gt;username.github.io&lt;/code&gt;不够高大上？？那就来个高大上的独立域名吧。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Hexo" scheme="http://www.codec.wang/tags/Hexo/"/>
    
      <category term="Github" scheme="http://www.codec.wang/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages轻松搭博客(2)：在Github上部署</title>
    <link href="http://www.codec.wang/hexo-blog-with-github-pages-2/"/>
    <id>http://www.codec.wang/hexo-blog-with-github-pages-2/</id>
    <published>2017-09-13T12:15:47.000Z</published>
    <updated>2020-04-07T04:39:39.356Z</updated>
    
    <content type="html"><![CDATA[<p>使用免费的Github Pages服务或者部署在自己服务器上，别人就可以访问你的博客啦！<a id="more"></a></p><hr><h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><p>首先登陆<a href="https://github.com/" target="_blank" rel="noopener">Github</a>，没有账号的话，先注册一个。新建一个名为<code>username.github.io</code>的仓库，<strong>username必须与你的账户名相同</strong>，比如我的就是<code>ex2tron.github.io</code>，这就是你博客的域名地址了（绑定独立域名之后再说）。<strong>新建时注意勾选”<em>Initialize this repository with a README</em>“</strong>，因为这个仓库必须不能为空。</p><blockquote><p>如果你是git新用户的话，推荐看：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="noopener">廖雪峰的Git教程-远程仓库</a></p></blockquote><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/create_github_pages_repository.png_webp"><img class="image" src="http://blog.codec.wang/create_github_pages_repository.png" alt="新建Github Pages仓库"></picture></p><p>接下来打开博客目录下的_config.yml配置文件，定位到最后的deploy选项，修改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:ex2tron/ex2tron.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><strong>注意冒号后面有个空格</strong>，不然会出错滴<del>~</del>配置好之后，使用下面的命令就可以部署到Github上了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>这样通过Github提供的域名地址（如我的：<a href="https://ex2tron.github.io" target="_blank" rel="noopener">https://ex2tron.github.io</a>）就可以访问你的博客了，简单快速高效！</p><h2 id="发布新博客"><a href="#发布新博客" class="headerlink" title="发布新博客"></a>发布新博客</h2><p>博客搭建起来之后，就可以用Markdown写博客辣，使用下面的命令，创建新博客（如名为：我的第一篇博客）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">'我的第一篇博客'</span></span><br></pre></td></tr></table></figure><p>此命令会在博客目录<code>\source\_posts\</code>下生成“我的第一篇博客.md”文件，这就是你的博客源文件啦，文件开头如下，记得冒号后面有空格噢，不然会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2017-09-13 20:15:47</span><br><span class="line">tags: #文章标签，格式：[1,2,3]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>不熟悉Markdown语法的可以看：<a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明</a>。写完之后依然使用之前的三条命令发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>后面两条指令也可以简化为一条：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><h2 id="常出现的问题"><a href="#常出现的问题" class="headerlink" title="常出现的问题"></a>常出现的问题</h2><ol><li><p>在hexo d进行部署时，如果出现<code>ERROR Deployer not found: git</code>的问题，可以先用下面的命令修复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>如果你没配置过ssh导致部署失败（可以通过<code>ssh -T username@example.com</code>来测试ssh有无配置成功），可以参考这篇文章：<a href="http://www.cnblogs.com/xsilence/p/6001938.html" target="_blank" rel="noopener">针对github权限导致hexo部署失败的解决方案</a></p></li></ol><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用免费的Github Pages服务或者部署在自己服务器上，别人就可以访问你的博客啦！
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Hexo" scheme="http://www.codec.wang/tags/Hexo/"/>
    
      <category term="Github" scheme="http://www.codec.wang/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Pages轻松搭博客(1)：安装Hexo</title>
    <link href="http://www.codec.wang/hexo-blog-with-github-pages-1/"/>
    <id>http://www.codec.wang/hexo-blog-with-github-pages-1/</id>
    <published>2017-09-13T08:07:06.000Z</published>
    <updated>2020-04-07T04:39:20.232Z</updated>
    
    <content type="html"><![CDATA[<p>想用Github Pages轻松搭建自己的博客，用Hexo，10分钟！<a id="more"></a></p><blockquote><p>废话区域：我在接触Hexo（可以读作Hack So）之前，绝对没少尝试建立一个完全自由、自己说了算的独立博客：WordPress定位重量级，功能强大，生成的是动态网站，依赖数据库……太繁琐了，放弃<del>而Jekyll和Hexo都是静态建站工具，但Jekyll的依赖项也很多，也不简约，不想用</del>最后才是名气相对不高的Hexo，相信我，熟练的情况下，10分钟就可以搭出来。</p></blockquote><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>是一个免费的静态Blog生成工具。简单来说，就是把你写的Markdown博客文件生成静态网页，把这个网页放在Github或者你自己的服务器上就可以快速访问了。软件界，从来不缺自动化工具(ง •_•)ง</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网文档：<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Docs</a></p><p>Hexo安装前，你的电脑上需要先有下面这两个东西：</p><ul><li><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>如果已经安装了的话，命令行下一句话就好啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="初始化博客目录"><a href="#初始化博客目录" class="headerlink" title="初始化博客目录"></a>初始化博客目录</h2><p>在你的本地新建一个存放博客的目录，比如”<em>D:\MyHexoBlog</em>“，然后在这个目录右键，选择”<em>Git Bash Here</em>“，输入下面两条命令进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>初始化完成之后，你的目录结构应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>如果没有出错的话，继续执行下面的指令启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g </span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>启动之后，在浏览器中访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，是不是看到了漂亮的Hexo博客页面了。不过目前这个博客还是运行在你本机上的，下篇我们看一下怎么样让别人也能访问这个博客。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/default_hexo_theme.png_webp"><img class="image" src="http://blog.codec.wang/default_hexo_theme.png" alt="default_hexo_index"></picture></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo Docs</a></li><li><a href="http://blog.csdn.net/cl534854121/article/details/76121066" target="_blank" rel="noopener">Hexo+Github搭建个人博客(一)——开始搭建</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想用Github Pages轻松搭建自己的博客，用Hexo，10分钟！
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Hexo" scheme="http://www.codec.wang/tags/Hexo/"/>
    
      <category term="Github" scheme="http://www.codec.wang/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>【利器】用VS Code写Markdown</title>
    <link href="http://www.codec.wang/tools-markdown-in-vscode/"/>
    <id>http://www.codec.wang/tools-markdown-in-vscode/</id>
    <published>2017-09-11T07:11:22.000Z</published>
    <updated>2020-04-07T03:49:58.806Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown以其简洁、优雅整齐的风格，成为目前非常流行的博客文件格式。甚至有人说：每个人都应该用Markdown写博客<a id="more"></a>。关于Markdown相较富文本的优势，我就不细说了。</p><hr><h2 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h2><p>支持Markdown的工具有很多，大家可以参考网上，如这篇文章：<a href="https://sspai.com/post/32483" target="_blank" rel="noopener">码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点</a>。就我自己目前在Windows上使用的而言有：<a href="http://www.jianshu.com/" target="_blank" rel="noopener">简书</a>、<a href="http://note.youdao.com/" target="_blank" rel="noopener">有道云笔记</a>、<a href="https://www.typora.io/#windows" target="_blank" rel="noopener">Typora</a>、<a href="https://code.visualstudio.com" target="_blank" rel="noopener">VSCode</a></p><p>简书本身就是一个博客平台，有道云笔记是类似OneNote和印象笔迹的应用。如果你已经在使用这两个平台的话，就不用多说了。但如果只是想用一个单纯的Markdown编辑器的话，推荐极致简洁的Typora。虽说界面简洁，但功能强大，不仅内置了常见的一些Markdown样式，还支持PDF/HTML等多种格式导出，我常用的就是Typora：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/markdown_in_typora.png_webp"><img class="image" src="http://blog.codec.wang/markdown_in_typora.png" alt=""></picture></p><p>你是一枚文青的话，千万不要错过这款编辑器。不过，对于程序猿来说，VSCode才显得更有味道。</p><h2 id="用VSCode写Markdown"><a href="#用VSCode写Markdown" class="headerlink" title="用VSCode写Markdown"></a>用VSCode写Markdown</h2><p>VSCode是目前很火的一款编辑器，就不过多介绍了。现在版本的VSCode默认已经支持Markdown预览，无需下载插件。用VSCode打开md文件或将当前文件更改为Markdown格式就可以开始书写了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/markdown_in_vscode.png_webp"><img class="image" src="http://blog.codec.wang/markdown_in_vscode.png" alt=""></picture></p><p>VSCode支持两种预览方式：</p><ul><li>按下<code>Ctrl+K V</code>，像上图一样左右同步实时预览</li><li>按下<code>Ctrl+Shift+V</code>，只预览最终渲染结果</li></ul><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/editor_preview_Synchronization.gif_webp"><img class="image" src="http://blog.codec.wang/editor_preview_Synchronization.gif" alt=""></picture></p><p>如上图，编写和预览界面是实时同步的，不需要的话，可以按下<code>Ctrl+,</code>组合键，添加如下两条设置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"markdown.preview.scrollEditorWithPreview": false,</span><br><span class="line">"markdown.preview.scrollPreviewWithEditorSelection": false</span><br></pre></td></tr></table></figure><p>另外，目前VSCode预览样式中，中文的显示很别扭。所以可以下载第三方的CSS样式，这里推荐<a href="https://github.com/ex2tron/BlogCode/blob/master/markdown-github.css" target="_blank" rel="noopener">Github风格的CSS</a></p><p>下载完成后，配置CSS文件的设置如下即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"markdown.styles": [</span><br><span class="line">    <span class="string">"file:///D:/markdown-github.css"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>另外，VSCode中有很多Markdown相关的插件，如<code>Markdown All in One</code>和<code>Markdown Theme Kit</code>等，大家可以下载下来尝试一下哈！</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://code.visualstudio.com/docs/languages/markdown" target="_blank" rel="noopener">Markdown editing with Visual Studio Code</a></p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown以其简洁、优雅整齐的风格，成为目前非常流行的博客文件格式。甚至有人说：每个人都应该用Markdown写博客
    
    </summary>
    
    
      <category term="利器篇" scheme="http://www.codec.wang/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="Markdown" scheme="http://www.codec.wang/tags/Markdown/"/>
    
      <category term="VSCode" scheme="http://www.codec.wang/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>【利器】MyCLI：自动补全和语法高亮的MySQL命令行工具</title>
    <link href="http://www.codec.wang/tools-mycli/"/>
    <id>http://www.codec.wang/tools-mycli/</id>
    <published>2017-09-11T06:32:14.000Z</published>
    <updated>2020-04-07T03:51:13.241Z</updated>
    
    <content type="html"><![CDATA[<p>mycli是MySQL命令行工具，支持关键字语法高亮和自动补全，看上面的动图你就知道了。<a id="more"></a></p><hr><p>mycli不仅能在命令行中提示MySQL的关键字，更牛掰的是数据库名、表名、字段名都可以提示，非常方便。如果你经常在命令行里码MySQL命令，相信这款工具一定会让你满意。</p><ul><li>官网：<a href="http://www.mycli.net/" target="_blank" rel="noopener">MyCLI</a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>其实mycli是一个Python的包，所以你已经安装了Python(pip)的话，用下面一条指令就好了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mycli</span><br></pre></td></tr></table></figure><p>如果出现问题，可以参考<a href="http://www.mycli.net/" target="_blank" rel="noopener">官网</a>，有详细的说明。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/install_mycli.png_webp"><img class="image" src="http://blog.codec.wang/install_mycli.png" alt=""></picture></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装好之后，在命令行下，将以往登陆MySQL用的mysql换成mycli，不用加<code>-p</code>选项就可以了：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/login_with_mycli.png_webp"><img class="image" src="http://blog.codec.wang/login_with_mycli.png" alt=""></picture></p><p>好了，大家觉得好用的话，欢迎扩散噢！</p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mycli是MySQL命令行工具，支持关键字语法高亮和自动补全，看上面的动图你就知道了。
    
    </summary>
    
    
      <category term="利器篇" scheme="http://www.codec.wang/categories/%E5%88%A9%E5%99%A8%E7%AF%87/"/>
    
    
      <category term="MyCLI" scheme="http://www.codec.wang/tags/MyCLI/"/>
    
      <category term="MySQL" scheme="http://www.codec.wang/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Qt+OpenCV环境搭建</title>
    <link href="http://www.codec.wang/qt-opencv-installation-guide/"/>
    <id>http://www.codec.wang/qt-opencv-installation-guide/</id>
    <published>2017-07-27T00:17:00.000Z</published>
    <updated>2020-04-07T04:47:01.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows下的配置"><a href="#Windows下的配置" class="headerlink" title="Windows下的配置"></a>Windows下的配置</h2><blockquote><p><em>念念不忘，必有回响。</em>——<a href="https://movie.douban.com/subject/3821067/" target="_blank" rel="noopener">《一代宗师》</a></p></blockquote><p>我电脑上安装的Qt版本信息：Qt 5.8/Qt Creator 4.2.1/MinGW 5.3.0<a id="more"></a></p><p><a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">Qt官方下载</a> </p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/qt_opencv_environment_demo1.jpg_webp"><img class="image" src="http://blog.codec.wang/qt_opencv_environment_demo1.jpg" alt=""></picture></p><p>首先用CMake编译OpenCV3.2，参考：<a href="/cmake-make-opencv/">CMake编译OpenCV3.2（Qt平台）</a>。针对Qt5.8+OpenCV3.2我已经编译好了，可以直接<a href="https://pan.baidu.com/s/1miaCDL2" target="_blank" rel="noopener">下载</a>。</p><p>编译好之后，把下面三个文件夹提取出来放在一个新目录下，比如：<code>D:\QtOpenCV</code></p><ol><li>OpenCV安装目录下的build\include文件夹</li><li>CMake生成后的lib文件夹</li><li>CMake生成后的bin文件夹</li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/qt_opencv_environment_demo2.jpg_webp"><img class="image" src="http://blog.codec.wang/qt_opencv_environment_demo2.jpg" alt=""></picture></p><p>放好之后，将上图<strong>bin的路径（<code>D:\QtOpenCV\bin</code>）添加到系统环境变量</strong>，此时最好重启资源管理器或注销一下，以使得环境变量更改生效。</p><p>然后打开Qt的pro文件，在<code>SOURCES</code>前面添加如下的OpenCV的依赖项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># INCLUDEPATH 头文件路径</span></span><br><span class="line">INCLUDEPATH +=  D:\QtOpenCV\include\opencv\</span><br><span class="line">                D:\QtOpenCV\include\opencv2\</span><br><span class="line">                D:\QtOpenCV\include</span><br><span class="line"><span class="comment"># LIBS 库文件，-L指定库路径 -llib指定程序用到的lib库</span></span><br><span class="line"><span class="comment"># 使用下面方法包含所有库</span></span><br><span class="line"><span class="comment"># LIBS += -L D:\QtOpenCV\lib\libopencv_*.a</span></span><br><span class="line"><span class="comment"># 或使用下面方法只包含要使用的库</span></span><br><span class="line">LIBS += -L D:\QtOpenCV\lib\</span><br><span class="line">        -llibopencv_highgui320.dll.a\</span><br><span class="line">-llibopencv_imgproc320.dll.a</span><br></pre></td></tr></table></figure><p>这样就配置完成啦，这里有一些OpenCV的示例代码，可以参考一下：<a href="https://github.com/ex2tron/BlogCode/tree/master/OpenCV-C++-Sample" target="_blank" rel="noopener">C++ OpenCV示例</a></p><h2 id="Ubuntu下的配置"><a href="#Ubuntu下的配置" class="headerlink" title="Ubuntu下的配置"></a>Ubuntu下的配置</h2><p>Ubuntu下如果不用CMake自行安装的话，就简单多了，在终端里面输入下面几条指令就搞定了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Qt5</span></span><br><span class="line">sudo apt-get install cmake qt5-default qtcreator</span><br><span class="line"><span class="comment"># 安装opencv</span></span><br><span class="line">sudo apt-get install libopencv-dev</span><br><span class="line">sudo apt-get install libcv-dev</span><br></pre></td></tr></table></figure><p>同样，在Qt的pro文件中添加OpenCV的依赖项就可以调用了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /usr/include\</span><br><span class="line">/usr/include/opencv\</span><br><span class="line">/usr/include/opencv2</span><br><span class="line">LIBS  += -L/usr/lib\</span><br><span class="line">-llibopencv_highgui\</span><br><span class="line">-llibopencv_core\</span><br><span class="line">-llibopencv_imgproc\</span><br><span class="line">-llibopencv_calib3d</span><br></pre></td></tr></table></figure><p>如果<code>LIBS</code>像上面这样加不进去的话，可以一个一个加，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBS  += -L/usr/lib/libopencv_highgui.so</span><br><span class="line">LIBS  += -L/usr/lib/libopencv_core.so</span><br></pre></td></tr></table></figure><p>另外，不同版本和不同平台库的位置可能不同，比如树莓派下，库文件可能在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS  += -L/usr/lib/arm-linux-gnueabihf\</span><br></pre></td></tr></table></figure><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Windows下的配置&quot;&gt;&lt;a href=&quot;#Windows下的配置&quot; class=&quot;headerlink&quot; title=&quot;Windows下的配置&quot;&gt;&lt;/a&gt;Windows下的配置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;念念不忘，必有回响。&lt;/em&gt;——&lt;a href=&quot;https://movie.douban.com/subject/3821067/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《一代宗师》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我电脑上安装的Qt版本信息：Qt 5.8/Qt Creator 4.2.1/MinGW 5.3.0
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="CMake" scheme="http://www.codec.wang/tags/CMake/"/>
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Qt" scheme="http://www.codec.wang/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>CMake编译OpenCV3.2（Qt平台）</title>
    <link href="http://www.codec.wang/cmake-make-opencv/"/>
    <id>http://www.codec.wang/cmake-make-opencv/</id>
    <published>2017-07-26T14:25:29.000Z</published>
    <updated>2020-04-07T04:39:01.936Z</updated>
    
    <content type="html"><![CDATA[<p>最近，需要在Windows下搭建一个Qt和OpenCV的环境，可惜官方OpenCV3.2的build里面并不是针对Qt平台的。所以，需要用CMake编译OpenCV的源码。<a id="more"></a></p><hr><ul><li><a href="https://cmake.org/download/" target="_blank" rel="noopener">CMake V3.9.0</a></li><li><a href="http://opencv.org/releases.html" target="_blank" rel="noopener">OpenCV V3.2.0</a></li><li><a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">Qt V5.8.0</a></li></ul><blockquote><p><em>所有的大人都曾经是小孩，虽然只有少数的人记得。</em></br></p><p><em>All grown-ups were once children… but only few of them remember it.</em>《<a href="https://movie.douban.com/subject/20645098/" target="_blank" rel="noopener">小王子</a>》</p></blockquote><h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><p>安装完CMake后，打开cmake-gui，如下图所示：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo1.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo1.jpg" alt=""></picture></p><ol><li>选择OpenCV3.2源码所在位置，我的是在：<code>D:\ProgramFiles\OpenCV3\sources</code></li><li>选择编译生成的目录</li><li>最后点击”Configure”，如下图所示：</li></ol><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo2.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo2.jpg" alt=""></picture></p><p>选择“MinGW Makefiles”并勾选“Specify native compilers”，点击“Next”：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo3.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo3.jpg" alt=""></picture></p><p>这里分别选择Qt安装目录下gcc和g++的路径，点击“Finish”，等待配置完成。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo4.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo4.jpg" alt=""></picture></p><p>配置完成后，勾选“WITH_OPENGL”和“WITH_QT”，点击“Generate”就可以了。如果发生错误：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo5.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo5.jpg" alt=""></picture></p><p><strong>将Qt的相关路径配置如下：</strong></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo6.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo6.jpg" alt=""></picture></p><p><strong>先点击“Configure”，再次点击“Generate”就可以生成了。</strong>然后在cmd下切换到生成的目录，我的是<code>D:\OpenCVBuild</code>，执行命令：<code>mingw32-make</code>开始编译（25分钟左右）：</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo7.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo7.jpg" alt=""></picture></p><p>编译好之后，再执行<code>mingw32-make install</code>就完成了。</p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo8.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo8.jpg" alt=""></picture></p><p><picture class="picture"><source type="image/webp" srcset="http://blog.codec.wang/cmake_opencv_qt_demo9.jpg_webp"><img class="image" src="http://blog.codec.wang/cmake_opencv_qt_demo9.jpg" alt=""></picture></p><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，需要在Windows下搭建一个Qt和OpenCV的环境，可惜官方OpenCV3.2的build里面并不是针对Qt平台的。所以，需要用CMake编译OpenCV的源码。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="CMake" scheme="http://www.codec.wang/tags/CMake/"/>
    
      <category term="OpenCV" scheme="http://www.codec.wang/tags/OpenCV/"/>
    
      <category term="Qt" scheme="http://www.codec.wang/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【云服务】搭建自己的Github/Git服务器</title>
    <link href="http://www.codec.wang/set-up-your-own-git-server/"/>
    <id>http://www.codec.wang/set-up-your-own-git-server/</id>
    <published>2017-06-04T11:38:56.000Z</published>
    <updated>2020-04-07T03:53:46.869Z</updated>
    
    <content type="html"><![CDATA[<p>Github是目前最流行的托管开源代码的远程仓库，但如果想要创建私有仓库，不公开代码的话，Github是收费的。<a id="more"></a>但像我们这种穷苦的孩子，只能选择自己搭一个Git服务器咯。</p><p><strong>2019-1-8更新：微软收购Github后，私有代码库从此免费！！喜大普奔啊！</strong></p><hr><p>我们需要一台Linux电脑，可以当作局域网内的Github。当然如果你有阿里云之类的服务器的话就更好了，有网的地方就可以push/pull代码，我这里以自己的本地Ubuntu电脑为例：</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>一句话，没啥好说的(+_+)</p><h2 id="新建git用户并配置"><a href="#新建git用户并配置" class="headerlink" title="新建git用户并配置"></a>新建git用户并配置</h2><p>创建用于运行Git服务的用户<code>git</code>，新建账号时，会提示你输入该用户的密码，其他保持默认即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br></pre></td></tr></table></figure><p><code>adduser</code>指令会在/home目录下生成以git名命名的文件夹，代表git用户目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /home</span><br></pre></td></tr></table></figure><p>在git用户目录下新建<code>.ssh</code>文件夹和<code>authorized_keys</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/git/.ssh</span><br><span class="line">touch /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>熟悉ssh的同学应该知道<code>authorized_keys</code>文件用于收集所有需要登录到此Git服务器的客户端公钥，一行一个。如果你已经生成过ssh密钥的话，Windows系统会在<code>C:\Users\用户名\.ssh\</code>，Linux系统一般在<code>/home/user/.ssh/</code>下，没有生成的话，可以用下面的指令生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>将<code>id_rsa.pub</code>中的内容拷贝到服务器的authorized_keys文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"pub_key_content"</span> &gt;&gt; /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>现在其实就跟Github一样的流程了，首先在建立一个新仓库，比如在<code>/home/git/repos</code>下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/git/repos</span><br><span class="line"><span class="built_in">cd</span> /home/git/repos/</span><br><span class="line">sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>然后将<code>sample.git</code>仓库的用户和组都改成<code>git</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>这样就建好了远程仓库，接下来你可以将已有的本地仓库关联或者克隆到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server_ip:/home/git/repos/sample.git</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@server_ip:/home/git/repos/sample.git</span><br></pre></td></tr></table></figure><h2 id="还有点小问题"><a href="#还有点小问题" class="headerlink" title="还有点小问题~"></a>还有点小问题<del>~</del></h2><p>前面新建用户的步骤完成后，<code>git</code>用户是可以直接在终端登陆服务器的，因此需要禁止<code>git</code>用户登陆shell，编辑<code>/etc/passwd</code>文件，找到git的一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>将启动环境改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p><code>git-shell</code>是一个每次一登录就退出的程序，这样配置之后，<code>git</code>用户可以使用ssh管理仓库，但无法登陆shell。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">廖雪峰Git教程</a></li></ul><blockquote><p><em>生命不息，折腾不止，Excelsior!</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Github是目前最流行的托管开源代码的远程仓库，但如果想要创建私有仓库，不公开代码的话，Github是收费的。
    
    </summary>
    
    
      <category term="Build篇" scheme="http://www.codec.wang/categories/Build%E7%AF%87/"/>
    
    
      <category term="Build" scheme="http://www.codec.wang/tags/Build/"/>
    
      <category term="Github" scheme="http://www.codec.wang/tags/Github/"/>
    
      <category term="Git Sever" scheme="http://www.codec.wang/tags/Git-Sever/"/>
    
  </entry>
  
</feed>
